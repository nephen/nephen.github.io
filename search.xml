<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ssl/tls是什么？是怎么工作的？]]></title>
    <url>%2F2018%2F12%2F10%2Fssl-tls%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[最近在思考一个关于邮箱服务器的问题，其中涉及到了SSL/TLS加密传输，于是想研究一下什么，到底是怎么实现加密的，通过查找各方面的资料，发现这个涉及到的东西还蛮多的，可以单独写一篇文章整理一下自己的理解。 SSL/TLS是什么？SSL（安全套接字层）是一种标准安全协议，用于在在线通信中建立Web服务器和浏览器之间的加密链接。 那TLS又是什么？Transport Layer Security (TLS)是SSL协议（Secure Sockets Layer）的升级版，TLS 1.0通常被标示为SSL 3.1，TLS 1.1为SSL 3.2，TLS 1.2为SSL 3.3。现在习惯将这个两个组合在一起称为SSL/TLS，只要知道它是一种用于加密的安全协议就好了。 当网页期望用户提交机密数据（包括个人信息，密码或信用卡详细信息）时，网页应使用加密，这个时候web服务器就应该使用HTTPS协议来传输数据，它其实就是HTTP和SSL/TLS结合实现的；同样的还有SMTPS，它是加密的简单邮件通信协议，这样在传输邮件的时候就不是明文传输了，一般我们在设置邮箱服务器的时候可以选择是否勾选SSL/TLS的，如果没有勾选的话邮件就是明文传输了。 SSL/TLS有什么作用？这里参考了网上的一些观点：不使用SSL/TLS的HTTP通信，就是不加密的通信。所有信息明文传播，带来了三大风险。 窃听风险（eavesdropping）：第三方可以获知通信内容。 篡改风险（tampering）：第三方可以修改通信内容。 冒充风险（pretending）：第三方可以冒充他人身份参与通信。 SSL/TLS协议是为了解决这三大风险而设计的，希望达到 所有信息都是加密传播，第三方无法窃听。 具有校验机制，一旦被篡改，通信双方会立刻发现。 配备身份证书，防止身份被冒充。 SSL证书先说明一下：SSL/TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。 在讲SSL/TLS的工作流程之前，先要说明一下SSL证书这个东西，来思考一个问题：基本思路里面的公钥加密法，如何保证公钥不被篡改？答案是：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。 那SSL证书是什么？怎么保证它是可信任的？SSL 证书就是遵守 SSL协议，由受信任的数字证书颁发机构CA，在验证服务器身份后颁发，具有服务器身份验证和数据传输加密功能。怎么才能申请到SSL证书？或者说影响该证书申请的因素有哪些？影响证书的因素：申请中提到的企业/公司是否有合法身份以及申请人是否控制证书​​中提到的域名。 申请到证书的步骤是怎么样的？ 制作CSR文件CSR就是Certificate Signing Request证书请求文件。这个文件是由申请人制作，在制作的同时，系统会产生2个密钥，一个是公钥就是这个CSR文件，另外一个是私钥，存放在服务器上。要制作CSR文件，申请人可以参考WEB SERVER的文档，一般APACHE等，使用OPENSSL命令行来生成KEY+CSR2个文件。 CA认证域名认证，一般通过对管理员邮箱认证的方式，这种方式认证速度快，但是签发的证书中没有企业的名称；企业文档认证，需要提供企业的营业执照。一般需要3-5个工作日。 也有需要同时认证以上2种方式的证书，叫EV证书，这种证书可以使IE7以上的浏览器地址栏变成绿色，所以认证也最严格。 证书的安装在收到CA的证书后，可以将证书部署上服务器，一般APACHE文件直接将KEY+CER复制到文件上，然后修改HTTPD.CONF文件。 注意：证书分为单域证书、通配符证书、多域证书、扩展验证证书，申请证书的时候要看是申请那一类了。 证书在什么情况下被使用？是怎么使用的？ 我们在点击web站点的时候，比如输入https://www.domain.com ，进行dns解析后web服务器进行响应，web服务器自动传送https://www.domain.com 网站的数字证书给用户，上文说到了，证书是安装在web服务器里面的，证书里面含有公钥，所以这里相当于服务器把公钥传递给了客户端，当然服务器那里还有自己的私钥，具体过程如下图。 客户端是使用浏览器进行操作的，不同版本的浏览器自动产生40位或128位的会话密钥，用于对交易的信息进行加密，也就是说客户向服务器索要公钥后还要与服务器协商生成一个“会话秘钥”。如下图，第三步获取到crt证书后，需要检验证书是否有效，如果无效则会显示警告信息，有效则生成一个随机数，即会话密钥，这个会话密钥再使用crt里面的公钥加密后传输给web服务器，服务器使用自己的私钥进行解密，获取浏览器生成的随机“会话密钥”，现在客户端服务器都知道这个“会话密钥”了，后续通信都用这个会话密钥进行加密通信了。 SSL是怎么工作的？简单概括就是： 客户端向服务器端索要并验证公钥。 双方协商生成”对话密钥”。 双方采用”对话密钥”进行加密通信。具体是怎么协商生成“会话密钥”的，上文提到了，这里还有一个疑问，为什么不直接使用crt证书里面的公钥进行加密，再使用服务器里面的私钥进行解密呢？更何况服务器里面的私钥也可以进行加密，crt里面的证书再进行解密即可。原因为：每一次对话（session），客户端和服务器端都生成一个”会话密钥”（session key），用它来加密信息。由于”对话密钥”是对称加密，所以运算速度非常快，而服务器公钥加密是非对称加密，比较耗时间，所以证书里面的公钥只用于加密”会话密钥”本身，这样就减少了加密运算的消耗时间。 那么会话密钥和公钥有什么区别呢？ 会话加密是非对称加密，服务器和客户端协商后生产一个会话密钥，所以服务器和客户端是共享一个相同的密钥的，当然不是服务器和所有客户端共享一个相同的密钥，而是每个客户端都有自己的密钥，比较这个会话密钥是客户端（浏览器）随机生成的，所以服务器需要维护多个密钥。 公钥是采用的非对称加密，服务器把证书（公钥）下发给每个用户正在使用的客户端（浏览器），所以是客户端共享公钥，服务器只掌控私钥，服务端与客户端密钥是一个1对多的关系，客户端发送的加密信息只能服务端解密，安全级别也更高，但是由于非对称加密太慢了，才采用了不同客户端不同密钥的“会话密钥”来解决这个问题。 具体TLS/SSL里面涉及到的非对称加密和对称加密的区别以及算法如下图所示： 总的来说，客户端（浏览器）与web服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用”会话密钥”加密内容，会话密钥即图中的随机数。 结束语对SSL/TLS涉及到的底层原理做了一个大概的说明，对学习过程中遇到的一些问题做了理解和解答，把一些问题理清楚后，对概念的理解就更加深刻了，比如明白了某个技术的由来背景，为什么会出现这个东西，问题的初衷是什么？怎么实现的？有哪些应用场景，如果把这些都调查清楚，那无论是对这个技术的使用还是新技术的创新都是有好处了，比只会用这个东西来做一些事情局限于表面工程要好得多，之前听大佬讲，有的人工作了6,7年，比别人刚毕业处理工作1,2年写出来的文章还要屎，听后感觉都可怕和悲哀，好好沉淀下去，打好基础，哪怕是寒冬来了也就不慌了，后续有时间再研究一下SSL证书申请的具体事宜。]]></content>
      <categories>
        <category>技术杂记</category>
      </categories>
      <tags>
        <tag>SSL</tag>
        <tag>TLS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[客户端该怎么设置邮箱服务器？]]></title>
    <url>%2F2018%2F12%2F07%2F%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%A5%E6%80%8E%E4%B9%88%E8%AE%BE%E7%BD%AE%E9%82%AE%E7%AE%B1%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[最近发现一个问题，苹果手机在设置邮箱服务器来获取第三方邮件时总是报错，无法正常获取邮件，我思考了一下，这其中肯定是有原因的，不可能是手机软件的的问题，于是决定研究一下邮箱服务器的一些原理，解决这个看起来很基础的问题。 什么是邮箱服务器？所谓邮箱服务器即为网络上的客户端保存电子邮件（电子邮件）消息的远程或中央计算机称为邮件服务器。邮件服务器可以分为两大类：传出邮件服务器和传入邮件服务器。传出邮件服务器称为SMTP或简单邮件传输协议服务器。传入邮件服务器有两种主要类型。POP3或邮局协议版本3服务器以在PC本地硬盘上存储已发送和已接收的消息而闻名。 IMAP或Internet消息访问协议服务器始终在服务器上存储消息副本。 为什么要有邮箱服务器？如果没有这一系列的邮件服务器，您只能向电子邮件地址域与您自己的电子邮件地址匹配的人发送电子邮件。即，您只能将一个example.com帐户的邮件发送到另一个example.com帐户。 邮件发送的过程是怎样的？如上图，电子邮件发送协议是一种基于“推”的协议，主要包括SMTP；邮件接收协议则是一种基于“拉”的协议，主要包括POP协议和IMAP协议。其中用户代理UA(User Agent)是一个软件包(程序)，它的功能是：撰写、阅读、回复和转发报文，还能处理邮箱（如创建收信箱和发信箱）。共有两种类型的用户代理： 命令驱动和GUI。命令驱动属于早期的电子邮件，通过命令发送和接收邮件，而GUI则是包含图形界面，允许用户使用键盘和鼠标与软件进行交互。 再结合下来进一步理解，MTA充当邮局（分拣区域和邮件承运商），处理邮件传输，而MDA充当邮箱，邮箱存储邮件（只要其容量允许），直到收件人拿走它。使用称为MUA（邮件用户代理）的软件程序来检索邮件。当MUA是安装在用户系统上的程序时，它被称为电子邮件客户端。当它是用于与传入邮件服务器交互的Web界面时，它被称为webmail，这里的MUA与上图的UA是一个概念。 下面来详细看一下用户发送与邮件接收的过程： 单击“发送”按钮时，电子邮件客户端将使用SMTP协议连接到电子邮件提供商的SMTP服务器（邮件传输代理）。假设你使用的是Gmail，那么你的电子邮件客户端会联系Gmail的SMTP服务器 - smtp.gmail.com。 你的电子邮件客户端与SMTP服务器通信，为其提供你的（发件人）电子邮件地址，收件人的电子邮件地址，邮件正文和任何附件。 SMTP服务器处理收件人的电子邮件地址 - 尤其是其域。如果域名与发件人的域名相同，则邮件将直接路由到域的POP3或IMAP服务器 - 不需要在服务器之间进行路由。但是，如果域不同，则SMTP服务器必须与其他域的服务器通信。比如Gmail上的SMTP服务器会检查您的电子邮件中的收件人电子邮件地址。假设收件人是 person@google.com，则Gmail SMTP服务器会从DNS查找google.com的MX（邮件交换器）记录。 MX记录是DNS中的一条记录，用于指定负责接受该电子邮件的邮件服务器，如 alt1.aspmx.l.google.com、aspmx.l.google.com。从MX记录中检索google.com的SMTP服务器地址后，再查找它的IP地址即A记录，Gmail SMTP服务器根据IP地址将该电子邮件发送到google.com的SMTP服务器，一般选择MX首选项值比较低的服务器aspmx.l.google.com，首选项值代表优先级，如果传递失败，它将尝试返回的MX记录列表中的另一台服务器，依此类推，直到成功为止。如google.com的STMTP服务器为： google.com的SMTP服务器检查该服务器上是否存在“person”收件人。如果该服务器上存在该帐户，则会将该电子邮件转发到其自己的IMAP / POP3服务器（邮件传递代理/MDA）以存储此电子邮件。 现在，收件人可以使用Outlook（邮件用户代理）等电子邮件客户端连接到此服务器并阅读该电子邮件。为了防止每个人查看其他用户的电子邮件，收件人受到名为登录名和密码的用户名的保护。有时在发件人和收件人的SMTP服务器之间有多个站点，其实流程也是相同的。 电子邮件协议分类上文讲到了邮件服务器可以分为两大类：传出邮件服务器和传入邮件服务器。其中传出服务器采用的协议为SMTP，传入服务器采用的协议有POP3和IMAP两种。下面依次进行介绍。 SMTPSMTP 的全称是“Simple Mail Transfer Protocol”，即简单邮件传输协议。它是一组用于从源地址到目的地址传输邮件的规范，通过它来控制邮件的中转方式。SMTP 协议属于 TCP/IP 协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。 SMTP 服务器就是遵循 SMTP 协议的发送邮件服务器。 SMTP通常用于在Internet端口25上运行。在欧洲广泛使用的SMTP的替代方案是X.400。 许多邮件服务器现在支持扩展简单邮件传输协议（ESMTP），它允许多媒体文件作为电子邮件传递。 SMTP有认证，简单地说就是要求必须在提供了账户名和密码之后才可以登录 SMTP 服务器，这就使得那些垃圾邮件的散播者无可乘之机。 本质上来说，SMTP（简单邮件传输协议）是用于发送和接收电子邮件的TCP / IP协议。 理论上，SMTP可以通过TCP，UDP或某些第三方协议来处理。但如果你在邮件中间丢失了几个数据包，则收件人可能甚至不会收到该邮件，如果他们这样做，则可能会丢失密钥信息。 这使TCP更合适，因为它确保每个数据包都已传送。 SMTP的通信端口分为两种，一种是不支持加密的，邮件是明文传输，端口号为25，此端口主要用于SMTP中继。 SMTP中继是从电子邮件服务器到电子邮件服务器的电子邮件传输。另一种是加密端口，这里的加密指的是邮件通信会通过SSL/TLS加密传输，关于SSL/TLS更多请查看ssl/tls是什么？是怎么工作的？，此端口一般使用465端口，虽然端口465从未作为IETF的官方SMTP传输或提交渠道发布，但互联网号码分配机构（IANA）负责维护大部分核心互联网基础设施，为SMTPS注册了465端口。 POP3POP3是Post Office Protocol 3的简称，即邮局协议的第3个版本,它规定怎样将个人计算机连接到Internet的邮件服务器和下载电子邮件的电子协议。它是因特网电子邮件的第一个离线协议标准,POP3允许用户从服务器上把邮件存储到本地主机（即自己的计算机）上。就像邮局职员的实体版本一样，POP3接收并保留个人的电子邮件，直到他们拿走它为止。 POP3服务器则是遵循POP3协议的接收邮件服务器，用来接收电子邮件的。 POP3有两种工作方式：删除方式和保存方式，可以在客户端进行设置。删除方式就在每一次读取邮件后就把邮箱中的这个邮件删除， 保存方式就是在读取邮件后仍然在邮箱中保存这个邮件，该方式是通过对之前的POP3工作方式（即删除）的缺点进行弥补，对功能进行扩充。 POP3的优点在于它很简洁，可以以最少的错误来完成工作，但同时缺点就是它只适合那些使用单个设备检索邮件的人，如果使用删除模式服务端是没有备份邮件的，单个设备下载后其余登陆的设备就无法再进行下载了，如果设置了保存模式可以弥补这个缺点。 POP3端口也分为SSL/TLS加密端口995，和不加密端口110。 IMAPIMAP全称是Internet Mail Access Protocol，即交互式邮件存取协议，它是跟POP3类似邮件访问标准协议之一。 IMAP4服务器则是遵循IMAP协议的接收邮件服务器，用来接收电子邮件的。 不同的是，开启了IMAP后，你在电子邮件客户端收取的邮件仍然保留在服务器上，同时在客户端上的操作都会反馈到服务器上，如：删除邮件，标记已读等，服务器上的邮件也会做相应的动作。所以无论从浏览器登录邮箱或者客户端软件登录邮箱，看到的邮件以及状态都是一致的。 还有一个就是，如果选择阅读邮件，则会快速下载，以便可以看到 - 因为除非你需要打开电子邮件，否则不会下载电子邮件的，这样也就可以快速的查阅邮件列表了，不需要等所有邮件内容更新后才可以查看。 所以，相比POP3而言，IMAP有以下优点： 它允许你通过任意数量的设备从任何地方访问你的电子邮件。 它只会在你单击时下载邮件，无需等待所有新消息从服务器下载，然后才能阅读它们。 IMAP不会自动下载附件。因此，您可以更快地检查邮件，并可以更好地控制打开哪些附件。 IMAP可以像POP一样离线使用 - 您基本上可以享受两种协议的优势。 最后，IMAP端口也分为SSL/TLS加密端口993，和不加密端口143。 相关问题这里有一些问题，可能你也会遇到，我把它列举一下。 我的邮件服务器地址是什么？你的邮件服务器地址和其他信息应由你的电子邮件提供商提供。 通常，此信息可以在电子邮件提供商支持页面上找到，也可以在电子邮件提供商的文档中找到。 在你的电子邮件提供商的网站上，该信息可能会列为SMTP和POP3地址。 我可以在互联网上使用我想要的任何邮件服务器吗？不可以。在浏览Internet时使用的Internet服务提供商（ISP）通常会有可以访问电子邮件的邮件服务器（传入和传出电子邮件），但通常无法访问其他互联网服务提供商拥有的邮件服务器，原因是邮件服务器只接受某些IP地址（ISP提供的IP地址），如果你的IP地址超出此范围，你将被拒绝访问服务器。但是也有例外。 在某些情况下，你可以从其他ISP提供的POP3服务器下载电子邮件。 他们只会检查您的用户名和密码是否正确。并且Internet上还存在独立于Internet服务提供商的独立电子邮件服务器，如果你有访问用户名和密码，则可以通过它们发送和接收电子邮件。 许多Web托管服务提供这种独立的邮件服务器。 自己是否可以自己搭建？缺点是什么？可以自己搭建，缺点是涉及的模块比较多，比如MTA、MDA、IMAP或者POP3服务器等，自己搭建比较复杂，维护比较耗时。 MX记录是怎么查询的？可以先查阅怎么快速搭建一个美观实用的博客？了解一下DNS的基本原理和工作过程，发送邮件服务器将按照以下的顺序查找DNS中的MX记录。 查找goodix.com的权威名称服务器(如果挂在dnspod上,则会给出dnspod的服务器地址) 查询goodix.com名称服务器以获取MX记录 在DNS中查找MX记录服务器的A地址以获取其IP地址可以使用Windows自带工具查询SMTP服务器IP地址如下图： 怎么设置客户端？绕了这么多，终于回到了正题，其实如果真正弄懂了邮件传输的原理以及相关一些协议的作用，这样就比较简单了。如下图，收件服务器采用可以与服务器进行交互的IMAP协议，毕竟比较有优势，也可以查看163的网站查看主机名为imap.163.com,而发送服务器没得选，直接写smtp.163.com就可以了，这里的端口后不需要填，基本上都是默认的端口号。 端口号也是可以修改的，见下图，基本上设置都是差不多的，反过头来看，设置比较简单，要知道其中的原理还是要花一定时间的。 结束语最后再仔细想想，其实邮件收发的过程跟我们现实生活中寄快递是一样的逻辑，先把东西打包后交给快递公司接收点，然后快递公司派单送到中间的其他站点，这些接收点，中间点就相当于SMTP服务器，快递寄到了以后往往会存到某个附件的代收点，这个代收点就相当于POP3服务器或者IMAP服务器，用户接收到了短信就可以自己凭短信取件码去领，也可以过一段时间去领。 真是技术源于生活呀，我想创新也需要勤于对生活的思考吧。]]></content>
      <categories>
        <category>技术杂记</category>
      </categories>
      <tags>
        <tag>POP</tag>
        <tag>SMTP</tag>
        <tag>IMAP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看懂医疗险之基础常识]]></title>
    <url>%2F2018%2F12%2F03%2F%E7%9C%8B%E6%87%82%E5%8C%BB%E7%96%97%E9%99%A9%E4%B9%8B%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%AF%86%2F</url>
    <content type="text"><![CDATA[一直想写一篇文章，对零散的医疗险知识做一个比较直观的总结，在实际对比各款医疗险产品的时候能够形成自己的看法，找到属于自己的核心需求，不被商家的花样介绍所带偏，买到真正合适自己的产品。以下主要从医疗险的概念、功能、重点考察点几个方面展开说明。 什么是医疗险我们应该要想清楚这个问题，为什么买了重疾险还需要购买医疗险呢？ 带着这个疑问先要弄清楚这两者的概念上的区别： 重疾险 是由保险公司经办的以特定重大疾病，当被保人患有上述疾病时，由保险公司对所花医疗费用给予补偿的商业保险行为，俗称大病险。 重疾险对诞生，本质是为了解决收入中断的风险，治病的钱本是社会医疗险负责。 医疗险 健康医疗险以报销或者津贴的方式来弥补疾病造成的经济损失，俗称住院险。 治病产生的医疗费，不是重疾险的主要责任，而是医疗险的职责。 所以如果生的病不在重疾险保障范围，其他费用（治疗费用、药物费用、住院费用）怎么办？这个时候就应该是医疗险该起作用的时候了。一般来说，平时生病开销基本可以靠社保+储蓄来解决，而一款重疾险+医疗险，可以保证绝大多数病症，跟重疾险一样，在购买的时候注意如实告知。 医疗险的功能跟重疾险不一样，医疗险是实行报销制，而重疾险是定额给付型——只要确诊，就一次性支付现金，所以我们称之为医疗险的津贴功能，在保额范围内花了多少就报销多少。但是它存在两项限制需要注意一下，一个是存在给付天数限制，另一个是年度累计给付限制，比如平安e生保保险条款就写明在每一保单年度内，因疾病或意外住院的最高给付日数为180日，累计疾病或意外住院超过180日发生的医疗费用，不属于保险责任范围。 重点考察点购买一款保险之前最好本身对保险常识有一定的熟悉，同样对于医疗险，在购买之前，如果能够对其中一些常见的概念有一个谱的话，就能尽量的避免购买的过程中遇到一些坑，买到不太划算的产品。以下主要根据医疗险保什么？医疗险能够报多少？有哪些解决方案？有哪些常见的保障项目？以及一些常见的关注点等方面展开解析。 医疗险保什么？一般来说，保障的内容有医院、门诊、住院、手术、人工器官、外购药、垫付等。 就规定的就诊医院来说，一般为二级及以上公立甲等医院普通部，可以附加特需部/国际部或私立医院责任，但是保费更加贵，特别是住院的时候需要注意了，如果没有附加险，住特殊部是没法报销的。 门诊，由于出诊率高，保险公司赔付的概率大，所以保费较高，但是这部分花费较少，大部分可以通过社保+储蓄自行承担，这种类型的医疗险一般免赔额比较低，但是保费也不便宜，可以作为社保的补充，所以不做过多推荐。 住院部分，由于花费比较高，所以需要重点关注了，这种类型的保险保额也就比较高了，比较常见的是百万医疗险了。想想百万医疗险为什么能够生存下来？因为它是高免赔，通过控制小额赔付来降低成本。 对于这种百万医疗，一年最高赔偿200w还是300w没有说明本质对区别，如果一年花200w还治不好那估计就不是钱的问题了。 外购药报销环节，有的保险是不能外购药报销的，具体看清合同条款。 医疗险能报多少？首先从保费说起，一般医疗险为一年期消费产品，一年一买，保费随年龄增加，我想这是为了防止今年保完明年不能再保了的情况吧。 保额部分关乎到我们能够报销多少了，不能说越高越好，公立医院就算重病，治疗费用最高百万左右，上节也说了，再高其实也没有太大的意义了。 再一个比较重要的是免赔额，按照计费的方式分为次免赔和年免赔，次免赔是每次医疗费用超过免赔额部分才可以报销，而年免赔指一年内累计医疗费用超过免赔额部分才可以报销，一般年免赔的情况居多，需要看清合同条款。按照报销的方式又可以分为绝对免赔和相对免赔，绝对免赔指的是社保报销额度和规定的免赔额度两个都必须要减，也就是无论我们的社保报销多少，都一定要减去规定的免赔额度。而相对免赔，指的是社保报销额度与规定免赔额度只减一个，两个取其大。也就是说社保先报，如果社保报销的额度大于免赔规定的额度，则只减去社保报销的额度，不再减去免赔额度，社保报销额度小于免赔额度，则只减去免赔额度就可以了。目前市面上绝对免赔的产品比较多。 关于免赔额，再多说几句，通常，免赔额低，保额也低。而0免赔额最大对问题是：无法保证长期续保，可能是前期保险公司为了打开市场才推出这种产品，后续可能会停售。 影响能够报多少的还有报销比例，比例越高，报销越高，比例越低，报销也就越低，一般来说，以有无社保划分，经社保报销后可以报销高达100%（并非所有费用，如人工器官），如无医保，可能只能报销60% 另外还有报销范围，存在两种，一种是医保目录范围才能报销，这样目录外的药品器材无法报销，还有一种是不限医保目录范围，这种才能真正的100%报销，所以要仔细看清条款说明。 最后具体能报多少的计算公式给出来：一次就诊应当给付的保险金额 = （被保险人发生的医疗费用的有效金额-年免赔额余额）*赔付比例，对年免赔额余额的说明见平安e生保截图。 有哪些解决方案有了以上的一些说明，可以对市面上的一些保险做个分类，再根据自己的需求对号入座。低保额，低免赔：只要住院就能报销，理赔率极高，可以作为社保的补充，解决的是小额医疗风险的问题。 高保额，高免赔：保额是百万起步，免赔额一般为1w，过滤掉了大部分的医疗费用免赔，价格合理。这类保险中年人和老年人均可购买。 其他医疗保险：高端医疗保险，可以去公立医院特需部，私立医院就医，如有这个需求，可以购买高端医疗保险；海外医疗险，如需海外就医，选择海外医疗险。 一般有哪些保障项目这里只讨论百万医疗险，保障项目可以分为一般医疗保险金和恶性肿瘤医疗保险金，各自又包含： 一般医疗险 住院医疗费用 指定门诊医疗费用 住院前后门诊急诊费用 恶性肿瘤医疗保险金 恶性肿瘤住院医疗费用 恶性肿瘤特殊门诊医疗费用 恶性肿瘤住院前后门诊急诊费用 住院医疗费用有给付天数限制，指定门诊医疗费用需要注意具体指的是哪些治疗项目，住院前后指的是被保险人在住院前后各7日内，与该次住院相同原因而发生的门诊急诊医疗费用。 什么情况下使用恶性肿瘤医疗保险金？在保险期间内，被保险人在等待期后因初次确诊罹患恶性肿瘤，在医院接受治疗的，我们首先按照前款约定给付一般医疗保险金，当我们累计给付金额达到一般医疗保险金的保险金额后，我们依照下列约定给付恶性肿瘤医疗保险金。 一般这两种保险金保额相同，比如是100w的医疗险，恶性肿瘤保额也是100w。 从平安e生保截取了这部分的说明如下图： 还有哪些关注点除了以上这些还有一些值得关注的点，比如等待期，一般为30天-3个月，等待期越短越好。续保条件，这个对于医疗险来说就显得比较重要了，因为如果你买的是一年期消费产品，第二年还得重新续保的，而医疗险对健康状况要求严格，一年一续保，所以是否保证续保决定能否长期投保。需要注意的是：“可连续续保“不等同”保证续保“！不保证续保的最大可能是产品停售，故可以在同等保障情况下，买销量高多医疗险。也可以买5年保证续保，毕竟5年内无停售风险。 依上总结，人性化保险应该是这样的：当年理赔不影响次年续保，续保无需再次审核，续保无需健康告知。 再来思考一个问题，为什么医疗险很少有长期的？ 每年10%以上的医疗通胀率 现代医疗技术快速地更新换代 全国医疗费用跳跃式增长 我国正“跑步”进入老龄化社会 再来说说智能核保，先看传统核保，当我们在网上买保险时，核保流程就简化成一页标准化的健康告知。保险公司列出一系列问题，如果在这些问题中有符合项，就失去了投保资格。而对于有核保需求的客户，往往是带有一些小毛小病或既往史的，在健康告知出现问题后，进入智能核保看是否可以继续投保。所以智能核保的优点是，1）智能核保更宽松，让以前不能投保的部分人群可以买保险。2）投保的时候对于核保的情况不是特别了解，可以用智能核保来作为一种参考，并且不会留下任何核保痕迹。目前支付宝的好医保是上线了智能核保的，可以去体验一下。 写在最后写到这里，差不多把想说明的都梳理的说了一遍，最后再说一个需要注意的点，医疗险可以重复买，但不能重复赔，也就是说实际报销时，可以在A公司报销一半在B公司再报销另外一半。这点是与重疾险是不一样的，重疾险可以重复买，两家都赔，可以叠加。 这篇文章主要对医疗险基础常识进行一遍梳理，有遗漏的后续再添加，现在可以尝试着自己去看一些百万医疗的产品了，着重看保险条款，下一篇我会依照市面上存在的几款比较好的产品进行剖析介绍，看看实际的产品怎么分析选择。]]></content>
      <categories>
        <category>保险</category>
      </categories>
      <tags>
        <tag>医疗险</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[怎么快速搭建一个美观实用的博客？]]></title>
    <url>%2F2018%2F11%2F23%2F%E6%80%8E%E4%B9%88%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%BE%8E%E8%A7%82%E5%AE%9E%E7%94%A8%E7%9A%84%E5%8D%9A%E5%AE%A2%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[博客使用静态网站生成技术生成，静态网站生成是指静态生成网站的过程，即生成HTML文件，例如，在本地计算机中，然后将网站文件上载到服务器，该服务器在被请求时向用户提供服务。相比动态网站，有以下优点： 内容存储为平面文件，因此不需要数据库 静态网站不需要动态服务器端处理 静态网站比动态网站超快，因为它们不需要服务器端处理或数据库访问 静态网站比任何动态网站都更安全，因为可以利用的安全漏洞更少 缓存静态文件比缓存动态页面更有效 目前网上主流的静态站点生成器有三个，分别为Jekyll、Hugo、Hexo。其中Jekyll由Github用Ruby语言构建，您可以免费使用Github Pages来托管您的静态网站，并使用CNAME文件轻松将其与您的自定义顶级域名链接。它的主要弱点为随着网站内容的增长，构建过程变得非常慢。另外，Hugo是一个用Go构建的静态站点生成器。它被宣传为“世界上最快的网站构建框架”。它最近与Jekyll相比，但在人气方面迅速增长。它的主要缺点为可扩展性差和插件少。而Hexo是基于Node的开源静态生成器，可在MIT许可下使用。借助Node.js平台，Hexo允许您在几秒钟内生成数百个静态文件。主要有以下优点： 快速而令人难以置信的速度 使用一个部署命令部署到Github页面或任何其他主机 强大的Markdown支持 高度可扩展 可用的免费和开源主题 可用的免费插件 而且它的缺点是：Hexo有一个相对较大的社区，但大多数是非英语人士（来自中国），这个缺点从我们的角度来看就是优点啊。 根据以上分析，我采用的总体方案为：采用Hexo进行博客创建，其中使用Next主题进行配置，将生成的博客静态网站部署在自己搭建的vps服务器上，最后采用dnspot对域名进行解析。具体细节见下文。 Hexo环境搭建 安装参照https://hexo.io/zh-cn/docs/ 网站，主要包括Node.js、Hexo和Git安装，Node.js、Git可以直接下载安装包安装，Hexo可以在Git Bash命令行里面安装： 1$ npm install -g hexo-cli 建站环境搭建好后就可以开始建站了，同样在Git Bash里面输入命令行进行： 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install hexo --save 其中folder为你要建立的博客的文件夹。 相关命令站点建立好后，就可以开始写文章了，可以使用sublime编辑软件打开刚刚建好的folder博客文件夹，找到source/_posts目录即为要写的文章地址。涉及到的一些命令如下： 123456789101112#新建文章$ hexo new [layout] &lt;title&gt;#生成静态文件$ hexo generate#启动服务器$ hexo server#部署网站$ hexo deploy#生成完成后部署hexo g -d#清除缓存文件 (db.json) 和已生成的静态文件 (public)$ hexo clean Next主题 下载使用进入之前建好的博客文件夹根目录，打开Git Bash，使用git命令进行Next源代码下载： 1$ git clone https://github.com/iissnan/hexo-theme-next themes/next Git怎么使用子模块？ 通过在 git submodule add 命令后面加上想要跟踪的项目 URL 来添加新的子模块： 12345git submodule add https://github.com/iissnan/hexo-theme-next themes/next#查看cat .gitmodules#保持更新git submodule update --init --recursive 配置使用关于Next主题的配置使用，直接看官网就好。 Hexo本地配置 主题配置打开站点配置文件_config.yml，位于跟目录下，可以选择使用Next作为主题，参照官网进行配置就好。 部署配置部署其实就是怎么把生成的静态网站上传到服务器端，把部署方式和地址说明一下，我这里采用的是自己搭建的git服务器，也可以是github（那就要在github上新建 blogname-github-io 仓库） 1234deploy: type: gitrepo: git@你的服务器IP:/home/git/blog.gitbranch: master VPS搭建Hexo博客作为自己搭建服务器来说，这部分是重点了。 什么是vps？VPS（Virtual Private Server 虚拟专用服务器）技术，将一台服务器分割成多个虚拟专享服务器的优质服务。比如搬瓦工VPS是一款性价比较高的便宜VPS主机，且适合入门级网友学习Linux、建站和软件调试用途。搬瓦工VPS目前有洛杉矶MC、洛杉矶QN、凤凰城、佛罗里达、荷兰这8个数据中心，对中文速度较好的是洛杉矶和凤凰城。 基本原理在服务器上搭建一个Git仓库。在本地Hexo执行deploy后，博客文件会被push到这个Git仓库，然后这个仓库又会通过一个git-hooks的功能把文件同步到VPS的网站根目录，经过Nginx代理服务把网站展现给用户。参考下图 Git服务器设置在.git/hooks文件夹中创建一个钩子文件：post-receive，注意没有后缀.sample，这样每当git仓库接收到内容的时候，就会自动调用这个钩子，把内容同步到网站根目录。需要修改post-receive权限使其可执行，chown git:git -R post-update/chmod +x post-update。 debug需要注意的地方，实际问题通过git push origin master返回log查看即可。 Nginx设置web服务器选择Nginx，Nginx与Apache比较，有如下优点： Nginx轻量级，占用资源少，负载均衡，高并发处理强，静态内容处理高效。 Apache拥有丰富的模块组件支持，稳定性强，BUG少，动态内容处理强。 常见命令： 123456#安装Nginxyum install -y nginx#启动Nginx服务service nginx start#测试Nginx配置文件nginx -t 重点说一下Nginx的配置部分 123456#配置之前备份一下cp /etc/nginx/nginx.conf /etc/nginx/nginx.conf.bak#修改默认端口号vi /etc/nginx/conf.d/default.conf#修改配置文件vim /etc/nginx/nginx.conf 这样配置好后就可以通过http://vps服务器地址:端口号 来访问站点了。 域名解析最后一步，也是最难理解的一步，将服务器地址解析到域名。首先得买一个域名，通过一些相关的设定后，以后直接通过访问域名来访问站点了。 概念解读需要了解一些常识，什么叫DNS？DNS（域名系统）是一个庞大的服务器网络，包含地球上最大的数字数据库。该数据库由多个互联网机构维护，管理和监管，包括IANA（互联网号码分配机构）和ICANN（互联网名称与数字地址分配机构）。DNS是互联网的中央数据库，如果没有它，互联网将不会像现在一样存在。它一般处理的数据包括： 名字(name)：指的是域名 资源(resource)：包括A(主机地址，一般就是主机的IP)、NS(域名服务器记录（Name Server），返回保存下一级域名信息的服务器地址。该记录只能设置为域名，不能设置为IP地址。)、CNAME(规范名称记录（Canonical Name），返回另一个域名，即当前查询的域名是另一个域名的跳转)、MX(邮件记录（Mail eXchange），返回接收电子邮件的服务器地址)、TXT(任意字符串)等等。 基本处理原理见下图，下面会结合具体例子进行解读： 另外处理数据里面包含的NS指的是什么呢？它是名称服务器，是安装有DNS软件的Web服务器，特别是由Web主机管理的服务器，该主机专门用于管理与所有主机提供商的帐户关联的域名。 dnspot设置使用dnspos进行设定，注册账号就可以，这就是一个dns服务器，在国内，解析的比较快，设定如下：由于我是用godaddy购买的域名，还要在godaddy里面告诉它我使用了第三方的dns服务器，不使用dodaddy自带的了，因为自带的服务器在国外，解析肯定会慢些。 深扒dns可能你还是不理解什么叫dns，它是怎么工作的？我们使用dig工具来深入解读一下域名nephen.cn是怎么解析出它具体的服务器地址的？如果你使用的是linux系统，本身就自带了dig命令，如果是windows系统，使用网页版工具diggui就好了。输入如下：得出输出结果：再一一解读一下： 计算机查找相应IP地址的第一个位置是其本地DNS缓存，该缓存存储计算机最近检索到的信息，如果没有则进行DNS检索查询。 dig问8.8.8.8：根区域的名称服务器是什么？8.8.8.8回复：名称服务器为a.root-servers.net…dig随机挑选了k.root-servers.net并解析为193.0.14.129，端口号为53 dig问193.0.14.129：nephen.cn的地址是多少？193.0.14.129回复：我不知道，你可以问下cn.名称服务器，他们是a.dns.cn. … f.dns.cn.dig随机选择了e.dns.cn，解析地址为203.119.29.1，端口号为53 dig问203.119.29.1：nephen.cn的地址是多少？203.119.29.1回复：我不知道，可以问下nephen.cn名称服务器，他们是f1g1ns1.dnspod.net.，f1g1ns2.dnspod.net.dig随机选择了f1g1ns1.dnspod.net，解析地址为58.247.212.36，端口号为53 dig问58.247.212.36：nephen.cn的地址是多少？58.247.212.36回复：23.106.149.209如果使用的是nephen.github.io托管网页，那这里会回答为CNAME为nephen.github.io，重新进行递归查找真正的地址 递归服务器8.8.8.8从权威名称服务器检索nephen.cn的A记录，并将记录存储在其本地缓存中，缓存TTL时间更新一次。如果有其他人请求nephen.cn的主机记录，递归服务器将已经有了答案，不需要再次进行查找过程DNS解析器在查询DNS服务器之前始终检查本地缓存，包括当前DNS解析器缓存内容和从Hosts文件预加载的条目相关命令：C:> ipconfig /displaydns、C:> ipconfig /flushdns 递归服务器会将A记录返回给您的计算机。您的计算机将记录存储在其缓存中，从记录中读取IP地址，然后将此信息传递给您的浏览器。 当然windows也有自带的nslookup可以查询，直接就能查出解析后的地址，其中208.67.222.222为手动选择的递归服务器，跟上面例子中的8.8.8.8是一个性质的。 还可以使用一些别的网络工具，随便推荐几个： https://dnslookup.online/ https://network-tools.com https://www.whatsmydns.net 以上就是建站的整个过程，夹杂了一些对问题的思考，希望对你有所启发，每一个技术问题背后其实有很多东西需要弄明白的，当我们搞清楚以后心里才会觉得更加踏实，从另一个层面来讲，弄清楚了底层的技术原理，对出现问题也能更加快速的定位，对出现新的技术也能触类旁通。]]></content>
      <categories>
        <category>技术杂记</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
        <tag>vps</tag>
        <tag>dns</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F11%2F23%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[想知道自己买的是什么基金吗？]]></title>
    <url>%2F2018%2F10%2F31%2F%E6%83%B3%E7%9F%A5%E9%81%93%E8%87%AA%E5%B7%B1%E4%B9%B0%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%E5%9F%BA%E9%87%91%E5%90%97%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[之所以说这个话题，是我发现身边有些小伙伴对于自己买的基金是什么类型的根本不知道，可能只是看到描述的最近年化率还不错就入手了，其实基金跟保险一样，有它们自己的分类，需要了解清楚再买，买错了可能就达不到想要的目的了，比如你想保大病结果买成了意外险明显就不合适了。 根据天天基金网站最新的数据统计，现在市场上基金公司一共140家，发行基金7542只。 在我们常用的APP-支付宝的财富栏目，可以看到基金的排行榜，分为业绩排行、定投排行和估值排行，你一直往下拉，数量也不少。 基金这么多，看上去眼花缭乱，选择越多，选择的难度就越大，而且市面上基金的名字看上去也五花八门，容易被它那高大上、具有诱惑力的名字所迷惑，那么怎么保证买到自己想要的那种类型的基呢？ 下面就简单的从基金的名字入手教你怎么一眼看透基金～ 基金名字组成先说结论，看到基金名字，直接进行结构分析：从哪儿来（公司名称）+投资些什么（投资方向/基金特点）+性格是什么样的（基金类型）。 在天天基金网，搜索“基金公司”，可以看到根据管理规模大小排行的基金公司如下，通过这个排行，可以知道市面上主要存在哪些基金公司，这样大概可以看出名字里面哪个代表基金公司了，一般为第一个名词。想要了解下基金公司的更多信息，可以自行百度搜索，如规模排名第一的天弘基金，是它通过推出首只互联网基金——天弘增利宝货币基金（余额宝），改变了整个基金行业的新业态哦。 投资方向包括哪些呢？1、追踪某种特定指数的基金，称之为指数基金，该基金投资该指数的成分股，或者将构成这个指数的股票按比例一揽子全部买入。名字中带有“中证100、上证50、沪深300……”等字眼的基金都为指数基金，比如博时沪深300指数A(050002)是跟踪沪深300指数的基金。 A股（人民币普通股）市场主要分为这么几种宽基指数： 上证50指数，它是上海证券所市场规模最大、流动性好的最具有代表性的50只股票，反应上海证券市场最具市场影响力的龙头企业的整体状况，可以看作是大陆这个班级的学霸。 沪深300指数，由上海和深圳交易所市值排名前300的上市公司组成的指数，是国内影响力最大、最重要的指数。 中证500指数，沪深前800的上市公司中，剩下的500家组成，代表中国股市中小型上市公司的平均水平。就是大陆这个班级的普通学生咯。 创业板指数，指专门选择在创业板上市的小型企业，由于规模不够大，盈利不够多，被主板上市挡在门外。 红利指数，这是由高分红的企业组成的指数，即上证交易所过去两年现金分红最高、市值最大、流动性最好的50家公司，是上证A股最优质的核心资产，它们是学霸中的高富帅。 当然并不是投资红利指数的上涨机会越大，要知道，越是普通学生，他的上涨空间也就越大，所以成立至今上证500的收益上涨是最大的，为500%。 PS：上证综指是股民常说的“大盘指数”，其走势波动记录了我国股票市场20多年来的风风雨雨，成为我国金融市场的晴雨表。对于深圳市场来说，最重要的指数莫过于“深证成指”了。深证成指更能反映出我国新兴产业的发展动态。这两种指数属于综合指数，这类指数参考意义大于投资意义，更多时候还是作为观察市场整体走势的一个指标。 2、投资某个主题的基金，如养老、环保、消费、电子信息、互联网，主要集中投资于某一主题的行业和企业中，并不按照一般的行业划分方法来选择投资标的，而是根据经济体未来发展的趋势，将某一或某些主题作为选择行业和投资的标准，满足投资者对特定投资对象的个性化需求。可以在支付宝的热门主题找到该类基金。 也可以在天天基金网通过主题基金搜到相关的基金，在这个上面看到的会更加全面些，也可以更多的了解基金的其余信息。 3、限制在某个市场投资的基金，如名字中带有“沪港深”的基金，可以参与港股通交易；名字中带有“QDII”的基金，可以投资境外的证券市场。 没有投资方向则找基金特点有的基金名字里面不一定含有投资方向，但你会发现它有以下特点，即包含一些高大上的名字，大致有：优选、精选、成长、量化、价值、红利、稳健、灵活配置等。 需要注意的是，叫“优选”的，不一定选的都是优秀精英，除了指数基金，这些基金都是主动型基金，好不好要看基金经理，而不是只看名字。 挑几个代表性的说下 “价值”，一般都是指投资于大盘蓝筹股和价值长期增长型的产品，也可以理解为未来有潜力。简单地说就是不追逐市场热点、题材股，而是用长远的眼光寻找有稳定业绩增长的企业。这类基金重仓股配置多为像银行、钢铁、地产这样表现较为稳健的价值型股票。 有“量化”的，人工智能知道吧，这个一般都是用大数据建立投资模型来指导投资策略的。 名称中有“红利”二字的基金，这类基金往往对分红有特殊规定，比如，信诚四季红规定每个季度对收益实施分红。 “灵活配置”，指的是可根据市场情况灵活调整股票和债券的投资比例，保证高风险、高收益的资产和低风险、低收益的资产能够实现适时的动态组合，属于混合基金里面的一种投资方式。 对于某些挂羊皮卖狗肉的基金，可以通过行业配置和资产配置来识别，如某些互联网主题的基金包含的大部分却是制造业的股票，这样就偏题了。支付宝在基金页面的基金档案信息里面可以查到。 该基金属于什么类型？基金类型可以大致分为如下： 货币基金，仅投资于货币市场，包括央行短期票据、银行协议存款、国债逆回购、剩余期限在1年以内的短期债券等常见的货币市场工具，具有很高的流动性，同时违约风险很小，因此通常也被看做是无风险的投资方式。 债券基金，80%以上投资于债券。 股票基金，80%以上投资于股票，风险比较大。 混合基金，投资了股票和债券，可以投资股票和债券的投资占比，实现收益风险平衡。根据资产配置比例分为：偏股型基金（股票配置比例50%-70%，债券比例在20%-40%）、偏债型基金（与偏股型基金正好相反）、平衡型基金（股票、债券比例比较平均，大致在40%-60%左右）、配置型基金（在资产配置上没有明确的限制，可以空仓操作，也可以满仓操作（有的上限95%），随意配置股票、债券、现金的组合）。 所以如果名字后面含有混合就代表是混合基金，含有债券则是债券基金，含有货币则为货币基金，当然货基的年化率一般低于4%也可以看出来。 混合型基金最大的价值在于其资产配置，其股票仓位的约束要比股票型基金和债券型基金要少，比如股票型基金股票仓位始终要保持80%以上，哪怕是熊市来了也无法规避风险；债券型基金股票仓位不得超过20%，牛市里只能眼睁睁看着别人的收益飞涨，无法达到收益的最大化。所以相比较于股票基金而言，混合基金配置比例更加灵活，可以分散投资、降低风险，当在股市非常低迷时，可以讲股票的资金占比调整的非常低，增加债券的资金占比，而当股市市场向好的时候，可以加大股票的仓位，所谓进可攻，退可守，就看基金经理的能力如何了，故选择这类型股票时，需要着重看资产的配置比例、基金经理的更换频率（太频繁了果断放弃）、基金经理的选股择时能力。可以在天天基金网看该基金经理的业绩评价，如下。对于上面提到的混合型基金，特别是灵活配置型，我们需要了解它的一个投资范围，到底灵活到一个什么程度，好根据自己的风险承受能力来觉得是否可以接受，这种情况下，可以通过登录“巨潮网”，输入该基金的代码，找到“招募说明书”，这说明书非常重要，在这里面可以找到很多信息，比如基金管理人、基金托管人、基金的投资、基金的运作方式等，就拿灵活配置来说，可以看基金投资部分，找到该基金规定的投资比例是怎样的，如下，可以看出股票最低可以空仓处理，最高可以达到95%，哪怕你买的货币基金，也可以看看该说明书，有一些在其他地方找不到的信息。 名字后面的字母代表啥？最后，基金名字后面其实大部分都是带有字母的，我觉得很多人是没太注意的，它其实是一个类型的分类，在货币基金后面的字母有它不一样的意义，而在股票型/混合型/债券型基金后面的字符意义也不一样。 我通过思维导图整理了一下：具体基金abc对于情况是不是这样的，在支付宝中可以在基金页面的交易规则进行详情了解。 针对货币基金部分，虽然写的是0申购费率，但是也是会扣除一定其它费用的。货币基金扣除的其它费用是包括销售服务费、管理费、托管费，一般是在0.2%-0.7%/年，从最低到最高相差了3倍多，这也是货币基金的最大的差异。 再说下股票/债券/混合基金的A/B类的共同点，1）要收取一定的基金管理费和托管费（从基金资产中扣除），但没有销售服务费。2）后端收费份额的赎回费与前端收费份额一样，随着持有期限增加而降低。 根据以上描述，可以发现其实货币基金我们大部分购买的是A类，混合/债券/股票基金大部分也是够买的A类，因为不知道要持有多久，当然如果你是玩短线当选择C类是比较划算的。 说了这么多，来看一个实例，名字为国富金融地产混合C（001393），分解名字，发行基金公司为国富富兰克基金管理有限公司，投资方向为金融地产主题，基金类型为混合型基金，属于C类基金，即买入时无需申购费，卖出时无需赎回费用，将费用转接到了销售服务费用上，销售服务费每年0.5%，如果是短期购买比较A/B类有优势。 写到这里，差不多结束了，可知，从基金的名字里面可以看出这只基金是从哪里来的，用来投资了什么，有哪些特点，性格是怎么样的，如股票型的偏激进嘛，知道的更多这样心里是不是更加有底气了呢。 除了知道这只基金的一些基本信息，文中部分提到了该怎么选择一只合适的基金，认识它是基础，怎么选择好的基金也有一定的技巧，有很多值得思考的地方，选择好了可以让我们的基金更加稳健的增值，规避一些不必要的风险，所以除了认识它我们还有很多东西需要去了解学习，后续我再慢慢的分享出来，对我自己来说也算是知识的一种总结吧。]]></content>
      <categories>
        <category>理财</category>
      </categories>
      <tags>
        <tag>基金</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[怎么快速了解行业现状？]]></title>
    <url>%2F2018%2F10%2F21%2F%E6%80%8E%E4%B9%88%E5%BF%AB%E9%80%9F%E4%BA%86%E8%A7%A3%E8%A1%8C%E4%B8%9A%E7%8E%B0%E7%8A%B6%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[本文说到的行业现状，指的是该行业在现阶段的发展处于一个什么样的水平，即行业内的竞争情况如何。 如果是创业者，主要想弄明白是否还可以继续从市场分到一杯羹；如果是投资者，投资该行业的风险有多大，是否值得投入；如果是从业者，想对自己选择的方向做一个比较理性的判断，该行业在市场能够提供的岗位是否足够的多，因为太少使得竞争的压力久越大。考虑这个问题的人，因个人所处的身份环境不一样而想要得到的信息可能会存在一定的差异，但是怎样去快速的了解这个行业，这种方法是大同小异的，都可以拿去参考。 不了解这些方法的人凭感觉进入该行业，像是闭着眼睛走路的人，其实心里没有太多的底气，而明白了这种方法，就可以用行业的数据来说话，做事更有把握以及方向更加明确，所以我更愿意觉得这也是一种新的思维模式，让你有一种新的视角来看待它，有了更多可以思考的角度。 当然，我也不敢说，用了我这个方法就一定能对行业了解的有多透彻，我所要分享的就是一种思维模式，希望能够开启你通往这个世界的大门，到底能走多远就要看你的态度和能力了。 网上面会有更多全面系统、更加专业的方法，我说的方法相对比而言比较简单，但是实操性也比较强，只要会使用互联网的人都可以学习应用。 我们在讨论一个行业的时候，会用红海或者蓝海来描述当前的一个行业发展情况，“蓝海”和“红海”是两个相对应的经济学名词。“蓝海”指的是未知的、尚待开发的市场空间，即俗语所说的“吃螃蟹的人、开辟蓝海领域第一人”。“红海”则指的是已知的、竞争相当激烈的市场。在红海中，产业边界是明晰和确定的，游戏的竞争规则是已知的。 红海对于小公司来说发展就比较困难了，可能要从一些细分领域着手寻求生存了，但毕竟规则已经形成，想要做大超越竞争对手难度很大，而处于蓝海这个阶段，大家都在努力拼搏，争取在目前的市场里面分到自己的一杯羹，这个阶段对于企业来说一切皆有可能。对于创业者来说，选择蓝海最合适，而对于投资者来说，在红海里面选择规则的制定者更加靠谱，因为蓝海里面的公司谁能活到最后都是说不准的事。 那么怎么判断该行业到底是蓝海还是红海呢？先来看一个概念——【市场集中度，它指的是特定市场中前几位最大企业所占的销售份额。一般来讲，一个市场，市场集中度越高，说明大企业的市场支配能力越强，则企业间的竞争程度就越低；反之，竞争加剧】。符号表示为CRN，表示前N家企业。 为了更好的描述行业发展阶段，可以根据市场竞争情况分为四种竞争格局：完全竞争、垄断竞争、寡头垄断、完全垄断，这四种竞争的竞争程度依次减弱，最好到完全垄断的时候，竞争企业已经非常少了，因为少数的企业占领了整个市场的销售额，小公司已经吃不到什么饭了。 是不是可以利用CRN的值和四种竞争格局来判断红海还是蓝海呢？一般而言，CN4的值越大，企业的数量就越少，竞争程度就越弱，当CN4&gt;=70%时，就达到了完全垄断的情况，当然也可以用CN8来判断，具体关系可以见下图。 那么我们该如何获取到这些数据呢？其实可以完全利用好别人已经分析好的行业分析报告，专业的事找专业的人嘛，我们要弄清楚的是该如何获取到这些报告，以及怎么从报告里面获取到这部分的数据信息，这也是我想要分享给大家的。 百度搜索慧博投研，下载PC客户端，进入软件首页后，点击行业高级搜索，在标题关键字栏目输入要查找的关键字，可以带有市场份额、市场集中度等辅助词查询，并调整时间为最近一年，重点看带有“深度研究”字样的报告或者页数比较多的报告。以指纹行业为例，输入指纹关键字，可以找到”海通证券-电子元器件行业专题报告：屏下指纹风起云涌，关学方案独占鳌头-180912”的报告，打开进入该报告，如果下载了该报告的话，可以搜索市场份额、市场占有率等关键字，比如我搜到市场占有率的图表如下，可以看出当前的CR4为23.1%+19.1%+18.1%+6%=66.3%，处于寡头垄断阶段，基本处于红海的程度了。 你也可以下载慧博投资分析的APP进行查询，另外除了慧博还有萝卜投研、股票研究报告网、中国产业信息研究网甚至你的微信都可以进行搜索。 需要说明的是，行业研究报告一般由证券公司撰写，我们把它看成是一部电影的影评就好了，需要多看几种，综合分析，其实除了了解市场份额（竞争格局）外，还可以研究下其它的一些东西，看别人怎么分析市场动态的，就看你怎么利用了，多阅读，多思考，学会从不同角度来看待一些问题，也许这里能够开启你思维的另一扇门。]]></content>
      <categories>
        <category>理财</category>
      </categories>
      <tags>
        <tag>行业</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人人都需要懂一点的财务知识]]></title>
    <url>%2F2018%2F10%2F14%2F%E4%BA%BA%E4%BA%BA%E9%83%BD%E9%9C%80%E8%A6%81%E6%87%82%E4%B8%80%E7%82%B9%E7%9A%84%E8%B4%A2%E5%8A%A1%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[相信有的小伙伴已经感受到了最近的大环境不是很好，有很多的企业出现了裁员的情况，没被裁员的可能得到了降薪的待遇，所以现在这段时间是特别不建议轻易裸辞的，除非某些特殊原因或者本身能力比较强，否则还是安安心心静下来认真积累，等到天气好转就可以大展身手了。 说到工作，跟对平台很重要，比如大学毕业生一般比较推荐校招时尽量进入业内比较大的公司，如互联网的BAT，明白大公司的工作方式，另外再出来找工作也有名企的光环，怎么说都是比较划算的，有能力为什么不进呢。而在当前环境下跳槽时就要注意了，要学会看要找的公司到底值不值得进，比如还在A轮阶段的公司风险就比较大，如果是上市公司学会看公司的财务报表分析当前的经营状况就显得比较重要了，公司发展好至少在员工薪资预算这块会给的高些嘛，与hr谈价钱的空间也相对要高些，大部分人跳槽多多少少跟薪资还是有点挂钩的吧。 上面说这个例子，其实就想说明为什么人人需要懂一点财务知识，首先要内心认可这个观点才会开始行动去学习知识嘛，知识学起来是简单的，有这个认识就比较难，其实说到财务知识，投资炒股的朋友更应该有这个需求，前几天祖国大江南北一片绿，股市出现了各种跌停，股市里面七亏二平一赢，要想在股市里面不做一颗任人收割的韭菜，这个时候就是最好的学习时机了，追涨杀跌的投机派是很难进入“一赢”的队列的。 也许你会说，这些例子看起来跟我也没啥关系，那我想大部分人应该是企业中的一员——员工吧，员工如果能够站在老板的角度来看待一些问题，具有主人翁的责任感，我相信应该没有哪个老板会拒绝这样的好员工吧，当然如果你本身就是企业的领导——经理人，因为经理人相当于拿了投资人的钱在为企业创造价值，如果能够创造出一份出色的财务报表，为企业制作更大的效益，这样在绩效上就会有很好的说辞，所以前提是能够学会看懂报表，学会从报表中分析问题，做出更好的决策显得非常重要了。 说到财务知识的作用，稍微总结一下，可以看下财务报表的常见分析情形： 投资者进行投资决策 主管部门对经理层进行考核 政府对企业经营合理性进行考验 金融机构是否提供信贷 经营者希望改善公司运营效率 下面为会引入财务报表的概念，并结合一些实际的例子进行分析。 首先要说的是资产负债表，它记录企业瞬间的生产经营状况，就像一张快照，即会计主体在特定时点的财务状况。会计主体指的是组织或者组织中的某一部分，它是可以独立衡量其经济运行的单位。一般这种快照会分为三种：季度报表、半年报表、年度报表。我们可以从理杏仁网站看到各个上市公司的财务报表信息，比如我截图了贵州茅台的资产负债表部分情况如下： 关于资产负债表，关键要弄懂这个恒等式：资产=负债+所有者权限，其中左边资产部分代表公司资金的用途，可以看成是由东西和物品组成，右边负债和所有者权限代表公司资金的来源，可以看成是由人物组成：债主和投资人。 一般公司对资产负债表是采用基于权责发生制的记账方式，即凡在本期发生应归属于本期的收入，不论是否在本期已实际收到或未收到的货币资金，均应作为本期的收入处理，比如只要公司给了货到客户，哪怕客户的钱公司还没有收到，都要计入一笔营业收入。实行这种制度，有利于正确反映各期的费用水平和盈亏状况。 资产负债表之所以是一个恒等式，举个例子你就明白了，若企业向银行借款100w，则该企业资产中货币资金增加100w，而负债也同时增加100w，会计等式左右两边保持平衡。若企业通过现金增资（指投资者用现金增加资本）向股东取得100w，则其资产中的货币资金增加100w，而所有者权限同时也增加100w，会计等式左右两边仍保持平衡。若企业回收客户欠款100w，则其资产中的货币资金增加100w，而应收账款减少100w。由于等式左边同时增加及减少100w，因此仍然保持平衡。 资产负债表恒等式左边（资金来源）与右边（资金用途）间有着密切的关系，经营良好的保险公司，客户续约率都在8成以上，客户所交的保费（属于负债）能提供公司长期稳定的资金来源，而如果短期的资产来源投资在中长期才能回收的资产用途上（所谓“以短支长”），就容易造成资金周转失灵。 再详细说明下资产负债表恒等式的三部分。 资产部分，指为公司所拥有、能创造未来现金流入或者减少未来现金流出的经济来源。比如创造未来收入的有货币基金（获得利息）、存货（销售获得现金）、应收账款（产品卖出去后还没到账的钱）、投资房地产（租金）、设备（制作产品以供销售）；减少未来现金流出的有预付房租、保险费用等；公司所拥有的有无形资产，比如商誉。 负债部分，指公司对外在其他组织所承受对经济负担，比如应付及预收款项、应付职工薪酬的预计负债、应计所得税、长期借款。以及部分估值，比如公司需要估计法律诉讼案所造成对可能损失。 所有者权限部分，资产扣除负债后，由公司所有者享有的剩余权益，又称为“净资产”或者“账面净值”，上市公司的所有者是股东，故所有者权益为股东权益。 关于等式三个部分各个项目的详细介绍就不说了，可以见后面的思维导图，挑几个重点讲下。 资产部分里面的固定资产项目，如厂房、设备，一般会采用累计折旧的方式来记账，毕竟固定资产会老化嘛，我们把资产价值的消耗，有系统地分摊在每一个会计周期间，以便计算损益。而折旧分为直线折旧和双倍余额递减折旧，第二种更好，开始几年折旧费用比较高，从而营业所得税减少，因为通货膨胀的原因，当前所得税的减少要比未来所得税的减少更好。注意土地不提列折旧，归类为非折旧资产。 资产部分里面的商誉部分，它是无形资产的一种，证明企业有赚得超额盈余的能力，很难用可靠及客观的方法衡量，只能在交易发生时认列商誉。商誉是收购方付出的代价与被收购方的可辨认净资产公允价值的差额，说白了就是企业在并购其他企业的时候买贵了，没地方去，就在资产负债表上堆积出来的项目。举个例子，现实生活中有两家超市开在一起，竞争压力大，其中一家超市A老板看不下去，想把另外一家超市B给买下来，超市B的老板知道自己的超市只值100w，但是这个时候他就可以坐地起价，喊到150w，如果A超市老板以150w成交了，那多出来的50w就是商誉了。考虑到这点，我们在选择投资企业的时候会使用PB（不含商誉），这个具体是啥这里就不说了，留个悬念。 所有者权限部分包含三个项目：普通股本、溢价、保留盈余。普通股本为股票的面值与股份总数的乘积即为股本，股本应当等于企业的注册资本。它有两个作用：一表明认购者在股份公司投资中所占的比例，二作为首次发行定价的一个依据。上海深圳交易所发行的股票法定面值为1元人民币，若流通在外股数为1亿股，则该公司股本为1亿人民币。当股权发行时，所收取的投资款超过面值的部分，称为股本溢价。若有一家中国大陆企业以每股4元上市，其溢价即为3元，我国股票的发行通常采用溢价(即高于票面价值)发行，这就是上市公司的魅力。保留盈余为历年来在生产经营活动中所实现的净利润尚未以现金股利方式发还股东、仍保留在企业的部分。 理解了资产负债表相关的基本概念后，基础铺垫打好以后，来看下要做的重点事情，怎么从财务报表的角度分析问题，财务报表的加总性太高，不能直接提供管理问题的答案，但能协助管理者及投资人发现问题、深入问题。 看资产负债表部分，可以试着从以下几个方面来分析流动性比率：指的是流动资产/流动负债，这类比率主要用来分析公司偿付短期债务的能力，流动资产指短期可以变现的资产，而流动负债指的是短期需要偿还的债务。可以这么说，如果公司的流动比率很低，且创造现金流量的能力又不好，那么发生财务危机的机会就会增加。该项可以从理杏仁网站搜索公司名字后在资产负债表栏目找到。 负债比率：指的是总负债除以总资产的相对比率，越大则财务压力越大，越有可能面临倒闭，但因营业活动及产业特性不同，比如银行负债比率非常高，而一般的制造业公司很怕早就发生财务危机了。这类比率主要用来分析公司偿付长期债务的能力。另外我们还要学会分析负债的组成结构，比如流动负债占比，对于经营效率和竞争力不佳的公司来说，流动负债占总负债比率增加会提高经营风险。也不排除这种情况，如果经营效率高，流动负债占总负债比率高的话，就可以利用规模优势与经营效率，让往来供应商提供无息营运资金，所以分析问题往往要从多个角度来看待，从不同项目之间寻找关联，找出财务报表发生变化的本质问题。 还有一些分析指标涉及到其他的报表，再来看一下利润表吧。 资产负债表是记录某一个时刻点的生产经营状况，那相邻两个时刻点之间到底发生了什么呢？这就是利润表的概念了。它记录一个期间的经营情况，一段时间内是亏钱还是赚钱，像一部电影，称为利润表，也称之为损益表，只是觉得大家都是想着赚钱的，你叫个损益表感觉不太吉利，后面改称为利润表了。 这里不做详细的介绍，在利润表里，同样知道这个公式很重要，营业利润=营业收入-营业成本-三费，三费包括管理费用，销售费用，财务费用；而营业利润-所得税=净利润。这些项目可以通过理杏仁网站搜索公司名字在利润表项目找到。 通过利润表，可以看出公司的盈利状况，一般来说，长期稳定的营收及获利增长，是企业竞争力的最具体表现，比如我们可以看一个公司的营业收入增长率及时了解公司业绩的变化，年度营收增长率等于（本年度营业收入-去年年度营业收入）/去年年度营业收入，季度营收增长率同理，只要发现最近的年度/季度营收增长率有一个为负数，就可以把它踢出白马股的行列，这是创建白马股组合的基本技巧哦。 创建白马股组合还有一个比较重要的，也是与利润表长期稳定获利关系比较大的，首先要知道的基本理论是，ROE越高，股票的年化收益率就越高，ROE为净资产收益率，它等于净利润除以净资产。而我们选择白马股的这个条件就是连续7年ROE&gt;=15%，具体怎么利用这个条件筛选，可以看下同花顺网站下的i问财进行搜索，当然也可以在利润表里面找到ROE的信息，看吧，如果你长期不够优秀，我就可以把你踢出局，为了我资本的安全，我不相信什么小概率事件，我只愿意用数据来说话。这里的白马股指的是股票中的白马王子，你希望它能稳定为你赚钱而精心挑选的。 利润表分析还有其它的指标，如周转性比率。这类比率主要用来分析公司财务的周转能力。一般说来，周转率应高一些，而周转一周所需时日应少一些，表明公司财务资金周转快，资本运用效率高。这类比率中较常用的有净资产周转率、应收帐款周转率、存货周转率、固定资产周转率，可以在理杏仁网站的财务指标-营运能力找到。另外还有获利性比率。这类比率主要用于分析公司的获利能力和营运效率。这类比率中较常用的为营业额获利率和投资额报酬率。可以在理杏仁网站的财务指标-盈利能力找到。 最后再说下现金流量表，有人说这是财务报表里面最重要的一个表。这是开支流水账，记录了公司花出去多少钱，收到多少钱，钱到底花到哪了，所以需要现金流量表，它以现金为基础基于现金收付制编制的财务状况变动表，反映了企业一定期间内现金流入和流出。它之所以非常重要，举个生活中的例子，只顾着在高速上狂飙的老司机你，却忘了油箱快没有油了，是不是很悲哀，当万科把活下去当作目标的时候，你就应该意识到现金流对于一个企业的重要性，当恒大率先开始房价降价到时候，你以为他们想降价？还不是被资金链逼得，他们都是负债上万亿的，每个月都有好多利息要还，他们每月本息不是几千块，而是几十亿甚至几百亿，每个月都有销售计划和回款计划，一旦现金吃紧就感觉快还不上了，就要加速销售和回款，卖不掉只能降价了。所以把这份表说是最重要的表也是有它的道理的。 现金流量表由三大活动现金流量的搭配，可以看出企业的性格与特质。 经营活动，如果应收账款增加，代表还没收到钱，对现金会产生不利影响；如果存货增加，代表没有收到钱，对现金也会产生不利影响；如果应付账款增加，代表还没付钱，会对现金产生有利影响。 投资活动和筹资活动，对于高度增长且对未来乐观对公司，往往会将经营活动带来对现金再全部投资，甚至投资金额会超过经营活动现金的净流入，使公司必须以筹资方式应对。再多余的钱可以用来购买自己公司的股票与发放现金股利。这里可以看出企业不只是靠生产经营赚钱的，还得利用钱生钱，利用的好不好就是企业的竞争力了。 三份报表基本用我的理解过了一遍，如果还是不明白的可以多查资料，这里顺便推荐两本书《世界上最简单的会计书》、《财报就是一本故事书》，有兴趣的可以更加深入的研究。再结合以上的知识点，讲一下我们在股市选白马股的一些别的技巧。 需要知道的是，财务报表也是可以美化的，这个时候就要有一双慧眼来分辨了。 收入美化，其根本原因就是“真货假卖”，由前面介绍的权责发生制可以知道，只要货给出去了，无论是否收到钱，就可以计入营业收入，这个时候如果你单独看公司的营业收入怎么厉害你就有可能被骗了，需要结合应收账款来看，货给出去了，但是没有收到钱，这个时候会计会把它统计到应收账款中。故如果连续两年应收账款上升幅度大于营业收入上升幅度，这家公司就要警惕了，当然银行股没有应收账款，无需考虑。 资产美化，什么？资产也是假的，对的，完全有这个可能，问题就是出在存货上咯，因为存货是资产的一部分，生产很多存货没有卖出去是很有风险的，再说，存货是公司自己统计的，谁知道这里面是否存在蹊跷呢，如果存货增长的幅度非常大，即连续两年存货增长大于营业收入的增长，那么存货可能有问题。 以上为了排除特殊情况，均采用连续两年加以判断，如果两年都不满足，基本可以踢除白马股了。 可以看出，投资人（如基金经理、散户）为了资本安全，会站在财务报表数据分析的角度来看待公司的发展经营状况，是否能够继续赚钱，是否有继续持有的价值，当前市场有没有低估它的价值，而经理人站在为企业谋取更多利益的基础上，更应该站在投资人的角度来看待这些问题，让财务报表变得更加好看，从财务报表中提前发现一些问题的端倪，为企业的发展制定更好的决策。 以上是我对财务报表的一些简单理解，基本理论部分参考了文中推荐的书籍，初看起来也并没有那么难，但其中一些道理需要花一些时间去琢磨了，有异议的部分欢迎后台提出，也欢迎点赞转发，寒冬来了，大家一起学习进步。]]></content>
      <categories>
        <category>理财</category>
      </categories>
      <tags>
        <tag>理财</tag>
        <tag>财务报表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何确定每月定投金额？]]></title>
    <url>%2F2018%2F10%2F02%2F%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E6%AF%8F%E6%9C%88%E5%AE%9A%E6%8A%95%E9%87%91%E9%A2%9D%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[上一篇文章讲到了复利的三要素、复利的威力以及怎么善用复利的力量。 这一篇来点实在的，怎么善用复利的力量之开始投资理财，很多人都持有这样的想法：现在没什么钱，每个月到手的工资来也匆匆去也匆匆，想把生活过得滋润点根本存不下什么钱，但有个事实要告诉你，你不理财，财不理你，其实还有一个事实要告诉你，开始理财其实并不需要多少钱。 看一个例子，假设30岁的你决定从现在开始，每个月花一件衣服的钱开始基金定投，这件衣服也不是什么国际名牌，仅需263元人民币，风雨无阻，一直投到60岁，假设按照年化率10%的收益来计算，猜猜你能得到多少钱呢？答案是60W，如果你的投资水平比一般人要厉害一点，能够达到15%，最终收益将得到184W元。 所以钱多钱少根本不是什么大问题，难道一个月一件衣服的钱都省不出来了？那得好好反省下自己的消费方式或者赚钱方式了。 投资什么呢？具体不做过多推荐，不是本文重点，以上例子讲到的是基金定投，所谓基金定投，即“基金定期定额投资”，顾名思义，就是在固定的时间、以固定的金额、分批次地自动申购指定的开放式基金。它相比“一次性投资”，定投具有定期投资，积少成多、摊薄成本，分散风险；无需择时，克服人性、长期投资，收益可观等特点，适用于广泛人群。 在讲怎么计算每月定投金额之前，再来重温下复利的相关计算。 公式很简单，FV=PV*(1+RATE)NPER(次方)其中PV为现值，代表期初投资的本金；RATE为利率，用来复利计算的；NPER为投资多久的期限，需要和利率进行对应，如果期限单位为年，则利率应该为年化利率； 用这个公式来搞点事情，告诉你一个家族资产百万倍增长的惊天秘密，无论你的初期成本是多少，只要你的年化利率能够达到15%，复利100年，最终获得资产将为初期成本的100W倍。 该公式还有一个非常不错的用法，用来预估现在的钱由于通货膨胀的影响在未来还能够值多少钱，假设通货膨胀的年利率为5%（虽然事实上远不止5%），15年过去后，当初的100块还值得多少钱呢？答案是48元。公式就是用复利的公式进行反推即可，为PV=FV/(1+RATE)NPER(次方)。 虽然很简单，但毕竟还是要经过几步加减乘除开方运算嘛，有没有什么办法直接能够算出货币贬值一半的时间呢？有的，看72法则。 所谓的“72法则”就是以1%的复利来计息，经过72年以后，你的本金就会变成原来的一倍。所以将72除以“年投资回报率”，就是投资本金翻倍所需要的年数。例如：投资回报率为10%，那么你需要72/10＝7.2年；投资回报率为15%，那么你需要72/15＝4.8年，缩短了两年多。 再回归刚刚货币贬值一半所需时间的问题，具体怎么算，72法则反推嘛，知道增值1倍的时间也可以知道贬值一半的时间，比如我们假设通货膨胀为3%，那么72/3=24年，我们就知道我们的1万块钱，在24年后只相当于5千块钱。这就很快了吧，一个除法就搞定啦。 接下来回归本文的重点，怎么计算每月定投金额，这个问题完整的题目应该是：如果你的投资能力还可以，自认为能够达到年化率为15%的水平，你对未来充满憧憬，希望在10年后拥有自己的一辆跑车，需要花费55W，这笔钱就想要投资理财来给你出，那么怎么算出从现在开始每月需要定期投入多少钱才能到达该美好的目标呢？ 采用Excel的PMT财务函数即可快速的算出，在此之前，简单介绍下这个财务函数的成员们： 现值函数PV(PRESENT VALUE) 定期支付函数PMT(PAYMENT) 利率函数RATE 期数函数NPER(NUM OF PERIODS) 终值函数FV(FUTURE VALUE)具体意思就不讲了，中文和英文都写出来了，以上也可以把五个函数看成五个变量，已知其中4个可以求出第5个的值。 比如PMT函数，按照跑车的目标，就是已知年化率为15%，期数（年）为10年，现值为0，终值为550000，求定期支付PMT的大小。故答案是，每月投资将近2000元大洋，由于是投入，所以算出来的结果为负数哦，至于其中的计算原理就不深入追究了，肯定是多次复利叠加的结果，好奇心比较强的你可以试着推理一下。注意一下，因为是投资，所以图中的是否期初支付那里是选择1，即是初期支付。 我刚开始认识PMT的时候，网上大部分的资料都是说怎么计算还房贷的金额，是的，它还可以用来计算每月还贷金额，而这种还房贷的方式为等额本息还款法。计算方式类似，只是要说明一下不同点： 已知条件变更为现值为房贷金额大小，终值为0 还房贷选择月末支付，所以公式期初是否支付选择0 实践一下，假设你的55w跑车的美好愿景破灭了，事实上你是背上了55w的房贷，而且需要你在10年内还完，年化率还真TM高，15%，你当然希望自己在做梦。 依旧用PMT函数算一下结果，注意以上说到的不同点，可以仔细对比下如下图跟上面跑车目标计算的图。结果看起来有点吓人，定投还只需要2000呢，怎么还债就要8、9千了，冷静一下，想想原因，首先计算结果一定是正确的，我用别人网页在线还房贷计算器计算了一遍，结果确实是对的。仔细看下网站计算的按月等额还款详细结果，发现这8873元包括了本期应还本金外，还有本期应还利息需要还，而且利息为本金的3倍多！ 原因就是这样了，房贷的利息给了银行，而定投的利息给了自己。 房贷PMT计算出的结果包含每期本金和利息，除了要还本金还要还利息，数值较大，所以当你把房贷还完时，你总共还的钱肯定是大于55w的，具体当期还款本金多少利息多少可以用PPMT和IPMT来计算的。 而定投利息叠加在本金里面，每月投入较少，最后的目标金额55w由每月的本金和利息组成。 看起来这么不划算，至于为什么要贷款卖房，不多说，简单一句话，选择等额本息还款法，还的总利息越多，你越划算，因为你多占用资金的时间所带来的价值远远超过了你还的利息。提醒，可以通过通货膨胀来想想现在的钱在未来还值那么多吗？ 每月定投金额算出来了，文章接近尾声了，你是否也想过，如果我每月可以用来投资的钱还足够多，不投白不投，比如3000元，同样15%的年化率，投资10年能够得到多少呢？可以采用FV来计算。 计算结果为83w，你也可以算出如果投资12，14，16，18甚至20年会得到多少钱，根据复利的特征可以想象到为一条指数的曲线，万一想不到我用每月投资1973元作为一个例子画出来了，再次说明复利中时间的重要性。 以上是对定投相关计算的总结分享，有什么问题欢迎后台提出，后续会推出小程序工具专门计算理财相关东西，想算的时候可以随时拿出来算，方便，敬请期待吧。 最后借用一句家常话，股市有风险，入市需谨慎。]]></content>
      <categories>
        <category>理财</category>
      </categories>
      <tags>
        <tag>复利</tag>
        <tag>定投</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么小学同学都是差不多的，但到了中年以后却千差万别？]]></title>
    <url>%2F2018%2F09%2F20%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E5%B0%8F%E5%AD%A6%E5%90%8C%E5%AD%A6%E9%83%BD%E6%98%AF%E5%B7%AE%E4%B8%8D%E5%A4%9A%E7%9A%84%EF%BC%8C%E4%BD%86%E5%88%B0%E4%BA%86%E4%B8%AD%E5%B9%B4%E4%BB%A5%E5%90%8E%E5%8D%B4%E5%8D%83%E5%B7%AE%E4%B8%87%E5%88%AB%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[可能是电视剧里面的场景，小学初中甚至高中大家都是在一起玩的很high的哥们，进入大学或者社会以后随着时间的流转，蓦然回首，发现以前跟你差不多的现在事业有成，好生羡慕嫉妒。现实何尝又不是这样呢？人家为什么能够比你成功，看起来比你潇洒，背后必定有它的道理！ 下面站在【复利】的角度来看待这个问题，一起来见证下世界第八大奇迹吧，它绝对值得你重视起来！ 先来讲两个小故事。故事1：如果一位富翁给你两种选择：1：每年给你一百万，给你30年。2：第一年给你1元，第二年给你2元，第三年给你4元，第四年给你8元……依此类推，给30年。 你会选择什么呢？老实告诉你，前面20年，拿一百万的拿比较多，但是在第21年之后，选择第二种的就拿超过选择第一种的。在第30年，选择第二种的可以获得5亿，30年来总共获得将近10亿，而选择第一种的只获得3千万而已！如下图所示。 故事2：舍罕王打算奖赏国际象棋的发明人——宰相西萨•班•达依尔。国王问他想要什么，他对国王说：陛下，请您在这张棋盘的第1个小格里，赏给我1粒麦子，在第2个小格里给2粒，第3小格给4粒，以后每一小格都比前一小格加一倍。请您把这样摆满了棋盘上所有64个格的麦粒，都赏给您的仆人吧！ 这个故事我想大部分人都听过，但我还是想站在量化思维的角度来分析一下，如下图，大家看最后一行，18446744073709600000这个数字是多少呢？1844亿亿，是不是没什么概念？没关系，我们来换算成重量。1公斤麦子约4万粒。把1844亿亿换算成吨的话，约4611亿吨！ 我国2017年全年粮食产量，一共是6.17亿吨。4611亿吨相当于我国744年的粮食总产量， 还真的是整个国家的粮食都不够啊。 什么叫复利？就是我们俗称的利滚利，复利的公式是 最终收益=本金*（1+收益率）^时间。它与单利不同1、单利就是利不生利，即本金固定，到期后一次性结算利息，而本金所产生的利息不再计算利息。2、复利会把上一期的本金和利息作为下一期的本金来计算利息。如下图，复利的神奇之处：在刚开始的时候复利效应是很微小的、不易察觉的，但当发展到一定阶段就会产生非常惊人的效果。关于单利，举个简单的例子你就明白了，农民伯伯家里的田地看做本金，每年的收成就是单利的结果，这一年风调雨顺就收成好，遇到天灾人祸可能肚子都难饱，为什么这叫单利呢？因为每年的田地是一样的呀，并没有增加，假设农民伯伯把收成用来购置更多的田地，下一年在更多的田地上种作，这就叫复利啦。 影响复利的因素有哪些？其实在很多地方都能找到答案！ 第一个，就是本金，本金越多，最终收益越大，但是本金的影响其实没有那么大，而且本金在短期内是很难改变的。 第二个，就是收益率，一年赚3%和一年赚10%，差别是显而易见的，我们在本金不多的情况下，就要努力提高自己的投资能力，提高自己的收益率。 第三个，就是时间了，年复利，和每天复利，后者要高很多，迭代的次数越多，复利威力越大，开始的时候越早，复利越早发挥作用。 依旧用例子来实际说明，小明从20岁开始投资，共投资10年，到31岁的时候就不再投入本金。小强从25岁开始投资，一直投入本金直到60岁。我们来看一下，当他们到60岁的时候各自都有多少钱呢？ 小明到60岁到手的钱为8227438，而小强一直定投到60岁到手的钱为7331841元，究其原因就是投资比小明晚了5年，意味着需要付出更多的投资成本。 下面这个例子同样说明了这个道理，若25岁开始投资，每月定投500，年化率10%，到60岁时本息189 8319元。若从35岁开始到60岁，准备189 8319元，每月需投资1431元；若45岁开始，每月需投4580元。 是不是想起了我前面文章讲的保险买的越晚保费越贵呢？其实道理是一样的，因为投资的越早，复利的爆发力就越早突现出来。 复利的反向影响复利也并不见得一定是好的，就像刚刚讲的，保险买晚了，保费也贵了呀，这就是对自己不利的。 我讲两个方面就明白了。 第一个是负复利，投资的朋友应该知道，巴菲特老爷子的名言，第一条：永远不要亏钱，第二条：永远不要忘记第一条 这又是什么道理呢？如果我们每年都是15%的年化率增长，持续20年可以积累15倍的财富。如果我们只出现一次错误（某一年回撤50%），财富积累就只有6倍了。 所以在投资的时候，宁愿少赚，心态放平稳，忌追涨杀跌，随着时间的积累，去拥抱复利带来的魔力。 另外一个方面，是隐藏在我们身边的时间杀手，通货膨胀。通货膨胀的意思就是流通的货币过多，超过经济运行的需求，导致钱不值钱，钱的购买力下降了，相应地物价就上涨了。 了解一下货币发行量的概念， 货币发行量等于市场价值总量除以流通次数，假如一个国家只有三个人，A种水稻，B种小麦，C养猪，A花2块钱买了B的面，B把从A赚来的2块钱去买了C的猪肉，C又把从B赚来的2块钱去买了A的米，所以市场总价是6块钱，但是流通了三次，所以实际上只需要印2块钱，多印就会引发通货膨胀。 一般而言，层级越高、离圈子中心越近、离增发货币最近的人，他们就越能占到更多的便宜，因为刚增发货币时还没有引起市场物价的上涨。层级越低、越远越晚的人，就越倒霉。在西方国家现行的银行制度下，有的行业就能占到这样的便宜。而老老实实储蓄的和靠养老金生活的人，就成了最大的输家。 所以，对于我们而言，推迟投资的每一天，通货膨胀都会发挥复利的反向作用，你与别人的差距也会越来越大。 复利对生活的影响你可能会想，讲了这么多，复利到底跟我和同学之间的差距有什么关系呢？ 同样是复利的道理，每天努力一点点的人，一年后将比以前的自己优秀38倍，以下数学题相信大家都会做，看出差别了吧？ 同样，复利在我们身体健康上也体现出来了，你的每一次饮食，每一次锻炼，每一个与健康有关的选择，其实都是加在你健康上的复利因子，有正的，也有负的。 根据保监会公布的数据显示，男女6大重疾患病率走势图如下，是不是跟复利的曲线很像？这让我想到，大部分年轻人很少有想到买保险的，觉得自己身体倍棒，因为他还在这个曲线的前面，不知道自己总归是会走到曲线后面的。 怎么善用复利的力量？无论你是打工，做生意还是创业，在同样的时间期限下，其实你一生的财富终值跟你的投资能力有关，跟你的投资收益率有关。穷人和中产为什么不能跨越阶层呢？贫穷的原因很大一部分是因为懒惰，这种懒惰不是身体上的懒惰，而是思维上的懒惰。为什么不能更加高效的学习？炒股为什么不弄清楚公司背后的逻辑而选择做一颗韭菜？为什么不好好健身锻炼，增加身体的正向复利因子，等到生病了才后悔莫及？投资生活也需要讲究收益率的。 由前面的复利影响因素可知，时间也是非常重要的，作用就不在重复了，可以说年轻就是资本，但如果不好好把握韶华，终究只会与别人越来越远！ 明白了这些道理，我开始坚持学习英语，健身锻炼，理财投资，积累更多的行业知识等等，每天进步一点点，享受复利带来的乐趣。 种一棵树，最好的时间是在十年前，其次，就是现在，一起行动起来吧。]]></content>
      <categories>
        <category>理财</category>
      </categories>
      <tags>
        <tag>复利</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[健身食谱与原理——增肌篇]]></title>
    <url>%2F2018%2F09%2F14%2F%E5%81%A5%E8%BA%AB%E9%A3%9F%E8%B0%B1%E4%B8%8E%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E5%A2%9E%E8%82%8C%E7%AF%87%2F</url>
    <content type="text"><![CDATA[上一篇讲了保险相关知识，只是初略的提了一下保险的重要性，以及保险里面一些常见的盲点，更多的还得自己花时间去学习梳理，忘了说了上一篇的文末是有福利的。规避风险的同时，来看看怎么更好的管理自己的身体，这一篇来总结梳理一下健身相关的知识。 先说明一下为什么健身要讲吃的？因为吃的太重要了，三分练，七分吃。有的想增肌的人健身后反而变瘦了，而有的想减肥的人却很难降下体重来，这里面涉及到了一些“会吃”的学问，锻炼的到位，吃得到位，应该更好的控制自己的身体了。 本人健身一段时间了，感觉还不错，但是对于真正会健身的人看来还是增的太慢了，离我的目标还有一段距离，最近适当调整了自己的饮食计划，感觉有一些比较好的改善，加上撸友们给出的一些饮食建议，结合对互联网健身食谱相关知识梳理，最后筛选整理出健身食谱相关知识，希望对需要增肌或者减肥的朋友也有一些借鉴意义。 首先说明一下系统知识。要知道怎么吃，就要知道增肌或者减肥的基本原理，简单来说，卡路里的摄入量&gt;卡路里消耗量的话就是增肥，当卡路里摄入量&lt;卡路里消耗量时就是减肥，而肌肉增长的原理就是，通过力量训练将肌纤维撕裂以后，通过营养的补充，氨基酸将撕裂的肌纤维进行修复。 健身的三大宏量营养素为：蛋白质、碳水化合物、脂肪。一一进行如下分析。 蛋白质，有多种氨基酸构成，为肌肉提供构造单元。人体对蛋白质的敏感度会随著年龄而下降，因而肌蛋白的合成效率会随著年纪而降低。因此蛋白质的摄取量应当随著年纪增长而增加。 脂肪，营养物的最高能量密度。生物里面就学习过，脂肪分为饱和脂肪酸和不饱和脂肪酸，饱和脂肪会提高胆固醇和甘油三酯水平（这个名词知道就好）以及心脏病发病率，主要来源就是我们常说的垃圾食品，比如爆米花、薯片、炸鱼排、汉堡等等；不饱和脂肪则会降低胆固醇和甘油三酯水平以及心脏病发病，主要来源于鱼类和植物类食物，比如坚果、种子、大豆、橄榄油和亚麻籽油等等；建议：1）脂肪的摄取要调节每餐都要低脂肪，不要摄取过多的脂肪；2）食物脂肪更好，比如坚果，含有不饱和脂肪酸；3）随著年纪增长，碳水化合物要减少，脂肪则要增加。 碳水化合物，复杂而又重要的营养素，它是机体的供能燃料，包括多种单糖、寡糖、多糖和淀粉分子。讲碳水化合物之前，先了解一下相关的背景知识。 a. 胰岛素：调节血糖促使葡萄糖合成脂肪或糖原的一种激素。b. 单糖：不能再水解的糖类。有葡萄糖（是能被人 体直接吸收利用的最重要的单糖，主要存在于植物性食物中，如 葡萄、香蕉、柿子等多种水果中，蜂蜜、红薯、玉米等食物和一些动物性食物中也有葡萄糖）、果糖（主要存在于各种水果及蜂蜜中，蜂蜜中含量最高。果糖是甜度最高 的一种糖，在体内被吸收后可转化为葡萄糖）、半乳糖（是乳糖的分解产物，甜味低于葡萄糖和果糖，在体内被吸收后也是先转变为葡萄糖后才被利用的）。c. 糖原：糖原需要先分解为葡萄糖才能被身体吸收，比如肝糖原、肌糖原，储存在肝脏中的肝糖原将会在我们训练过程中持续的释放能量，一般来说，长时间训练的健身者可以多存储20%到50%更多的糖原，糖原的储备决定了你的疲劳点，长期健身的人精力更加好。d. 血糖生成指数：先明白两点1）碳水化合物过量时先被存储为糖原（肝糖原，肌糖原），糖原储备已满则储备为脂肪。低强度的有氧运动才会消耗脂肪，高强度的无氧运动只消耗糖原储备，所以减肥必须进行有氧运动。2）碳水化合物吸收过快会导致身体储存脂肪（吃下的热量，身体的各个组织利用之后，剩下的利用不完的才会转化为脂肪储存起来）。明白这两个道理后，再看这个结论：【血糖生成指数表示碳水化合物的吸收速度，血糖生成指数高的食物，吸收得就越快（少吃这类食物）而血糖生成指数低的食物，吸收的就越慢（建议多吃）】，明白这点非常重要。 下面进入碳水化合物的主题，其功能作用：1）碳水化合物可以防止肌蛋白的分解（因为当身体缺乏足够的碳水化合物时，蛋白质会被代替来提供能量）；2）肌肉依靠快速的碳水燃料作为养料，缓解疲劳感，可以这么理解：蛋白质提供了砖瓦，而碳水化合物是建造房屋的工人；3）摄取碳水化合物后，血糖会上升，从而刺激胰岛素的分泌，而胰岛素可以加速运送养分（氨基酸）至细胞，以发动肌肉的增长和修复。故碳水化合物和蛋白质搭配的增肌效果会比仅摄取蛋白质来得更佳。蛋白质和碳水的摄入量比例应为1:3。但是相比蛋白质和脂肪来说，人体代谢随著年纪增长而降低，所以碳水化合物的取量要跟著减少。 前面讲到血糖生成指数分为血糖指数高的食物和血糖生成指数低的食物，对应到碳水化合物的关系为：血糖生成指数高即简单碳水化合物，血糖生成指数低即复合糖水化合物。分别介绍一下这两种碳水化合物 简单碳水化合物只包含一个或两个糖，这些单一的糖称为单糖。含有两个糖的碳水化合物，如蔗糖(蔗糖)，乳糖(奶制品)和麦芽糖(啤酒和一些蔬菜)——被称为双糖。能直接被转化葡萄糖被人体所吸收，进入血液循环系统，故身体吸收的速度要快。 复合碳水化合物有三个或以上的糖，他们通常被称为淀粉类食物。它相比于简单碳水化合物多了一道程序，它需要先被分解为简单的糖，然后再转化为葡萄糖，才能被人体吸收，故身体的吸收速度慢，不容易挨饿，建议想减肥的朋友多吃这种类型的化合物。 了解了各营养素的基本原理后，来看一下分别都有哪些对应的食材。1、常见的蛋白质食物鸡蛋 （单位重量内约6克蛋白质）鸡胸（单位重量内约20克蛋白质）三文鱼（单位重量内约18克蛋白质）牛排（单位重量内约23克蛋白质）豆腐（单位重量内约16克蛋白质） 2、常见的碳水化合物有糖类（白糖、蔗糖）、谷物（大米、小米、小麦、高粱、玉米、土豆、红薯）、水果（香蕉、西瓜、葡萄）、干果类（坚果）、干豆类（豌豆、蚕豆）、根茎蔬菜类（胡萝卜、番薯）、唯一来自动物的食物（奶制品）。如果按照吸收速度来分，可参考如下快吸收：沙糖、葡萄糖、含糖分饮料、运动饮料、白面包等等中吸收：白米饭、意粉、米粉、米线、马铃薯等等慢吸收：糙米、燕麦、全麦包、蕃薯等等 现在有了如上的知识理解，再来看看有哪些针对健身饮食相关的建议。要牢记饮食规则：【愈接近健身训练的时间, 就要进食愈快吸收的碳水化合物, 愈远离健身训练时间就要进食愈慢吸收的碳水化合物。】 一日多餐，正餐补充米饭、馒头等主食。 在训练前1小时内尽量不要摄入任何形式的单糖，可以在健身前1个小时摄入碳水化合物。因为如果在训练前1小时内摄入了单糖，你的胰腺就会开始释放胰岛素，胰岛素的释放会让ATP停止转化为ADP，而在ATP向ADP转化的过程中，将会释放出一个磷酸分子，磷酸分子的作用是向肌肉提供收缩的能量，然后磷酸分子再次与ADP结合从而生成ATP，胰岛素正好抑制这个过程。所以如果在这个阶段进行训练，你将会失去训练效率。比如：可以在训练前加餐一碗燕麦片，全谷麦片，全麦吐司，甚至甜土豆红薯、或山药等低GI食物，一个小时前摄入；如果你不得不直接在运动前进食，可以选择一小份水果，一个苹果或一个香蕉。 在训练过程中摄入适量的单糖。这是因为胰岛素的分泌是一个相对缓慢的过程，但是在训练中摄入的单糖不能过多，否则渗透压过高导致肌肉脱水，同时，运动过程中及时补充饮料，保证肌肉生长所需要的足够能量，减少由于糖分供应不足所引起的分解。故可以健身中每隔15分钟左右补充水分，运动饮料或者纯净水或者糖水（高GI）。 在训练后要立刻摄入单糖。这将会帮助胰岛素分泌，停止ATP和ADP的循环，并且让你的身体从碳水化合物中获得充足的能量而不是去燃烧蛋白质。同时也需要恢复糖原储备，更主要的是通过补充单糖而释放的胰岛素能够让你的身体在训练后进入同化合成修复状态。训练后注意补充中高GI碳水化合物，加高蛋白、低脂肪。 以上建议只针对于想增肌的朋友，瘦身的话会有一些不同，比如会建议训练完后半个小时再进食等。篇幅有限，先分享一些比较重要的主干知识，后续有新的学习与体悟再进行更新，如有疑问或者认为不妥的地方，欢迎后台提出，大家一起学习进步。]]></content>
      <categories>
        <category>健身</category>
      </categories>
      <tags>
        <tag>健身</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[说说保险]]></title>
    <url>%2F2018%2F09%2F03%2F%E8%AF%B4%E8%AF%B4%E4%BF%9D%E9%99%A9%2F</url>
    <content type="text"><![CDATA[在生活当中，我们会碰到很多人突然之间得了大病，一下子拿不出那么多钱来治病，不得不投向于轻松筹、水滴筹缓解一点经济压力，看到这样的例子，我会感觉到害怕，一是类似于癌症这样的病症往往需要花费大量的财力物力，普通家庭一般都负担不起，二是人人都不知道明天到来的是意外还是惊喜，怕这样的事情发生在自己身上，精神和身体都备受折磨。 害怕之余，结合自己近端时间学习的保险知识，觉得很有必要为自己购置一份合适的保险，目的是为了转移风险，对的，保险的本质就是为了转移风险，包括风险来临时我们能够病有所医、亲有所养、老有所医等，不至于花光自己辛辛苦苦大半辈子积累的积蓄。 还有一个认知非常重要，就是保险越早买越划算，要知道保险公司不是慈善机构，保险是一种商业行为，保险公司是要赚钱的，所以保险公司的精算师会根据年龄的不同计算出每年的保费，一般年龄越大保费就越贵，但我们购买长期型保险是每年的保费其实是一样的，那是因为保险师把后续高的保费平均到了年轻的时候，所以你越年轻买，平均下来的保费就越便宜；另外还有一点，保险都有它的现金价值，买保险后越往后现金价值越高，主要的原因为保费的资产是有复利作用的，前期作用几乎看不出来，越往后就越明显，故也能抵消掉一部分后期高昂的保费，所以你越早买保费作为资产复利的作用就越明显，跟投资理财越早是一样的道理。 当然，保险涉及到的知识很多，如果你对这一块不是很熟，很有可能购买到的产品不适合自己，最后的结果可能为，真正出了事，赔付的保额很低，简直是杯水车薪，或者是前期告知的不是很清楚，理赔的时候被拒等等，所以主动弄清楚保险相关的知识很重要。为什么要主动去学习，有几个原因，1）保险公司业务人员都是要吃饭的，他们往往会站在业务的角度去给你推荐保险，比如一些投资理财型的产品，这种产品保险不够，投资不足，对于真正想保险的不是刚需。2）现在购置保险的渠道非常多，互联网保险越来越多，我们可以自己通过互联网找到一些性价比很高的产品，而且这种产品跟你在业务员那里购买的理赔时间等都是一样的，但是有一点，你要自己分析，根据自身的经济和需求情况，购置真正适合自己的保险，所以自己懂很重要，真正懂了才敢下手，否则购置保险一直停留在口头上。 学习保险相关的途径很多，我推荐一些比较牛叉的公众号可以关注一下，比如深蓝保、关哥说险，但是如果需要系统性的学习保险知识，建议还是报一些保险相关的课程，比如长投学堂，以上纯属个人推荐，因为实际用过觉得比较好。系统学习过再去看一些公众号的文章就会觉得比较亲近，能够更好的梳理知识脉络。 其实，保险有很多初学者需要注意的，比如我们应该首先为家庭经济支柱购买保险；保险可以根据自身经济情况灵活配置，不一定需要一次性配置的非常完整，先在经济允许的情况下配置了再说，总比什么都没有强，后期可以再购买同类型的产品增加保额等。以下我整理了一些学习过程中的思维导图，一方面有助于自己后期的复习，另外也分享出来供大家参考。 如果大家觉得这些知识有用，并且也有需求学习保险知识，可以后台回复“保险知识”，可以提供一份保险的系统学习课程，帮助大家扫盲，只为在保险的路上少走一些坑。]]></content>
      <categories>
        <category>保险</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[初学PX4之环境搭建]]></title>
    <url>%2F2017%2F07%2F30%2F%E5%88%9D%E5%AD%A6PX4%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[消息：pixhawk网站搬迁至px4.io !!! 前言前段时间linux崩溃了，桌面进去后只有背景，折腾好久没搞定，为了节省时间索性重装了系统，同时也借这个机会从头记载一下作为初学者的学习过程。主要是按PX4的官网初学者教程进行，把其中遇到的一些初学者容易遇到的问题罗列出来，由于对于国内这方面的资料相对缺乏，希望能给大家提供一些帮助，也算是自我学习的一个整理。 如果你还不是很了解关于飞行器的这个项目PX4，建议迅速跳到PX4的官网一探究竟。简单来说，PX4是一个软、硬件开源项目（遵守BSD协议），目的在于为学术、爱好和工业团体提供一款低成本高性能的高端的自驾仪。这个项目源于 ETH Zurich (苏黎世联邦理工大学)的计算机视觉与几何实验室的PIXHAWK项目、并得到了自主系统实验室和 自动控制实验室的支持 ，以及一些出色的个人(Contact and Credits)也参与其中，包括 3D Robotics 和 international 3DR distributors的成员。 前期准备为了让大家能与我的学习保持同步，先介绍一下在搭建这个PX4环境前我已经做好的工作： 硬件一套，包括DJI F450机架、Pixhawk 2.4.6 mini飞控、好盈乐天20A电调、1045正反桨、银燕电机2216、天地飞6通道遥控器。详情见淘宝链接里的套餐方案。 软件环境，使用的最新发行版Ubuntu 15.10操作系统。 工具链安装在准备工作做好并对PX4有了一定的了解后，从开发者快速入门教程开始PX4的环境搭建，对于Linux这里直接跳到了工具链的安装。按照教程说的命令去执行就可以了，只要你的网速够好，相信很快就能完成任务。说明一下这里做了哪些事情： 更新软件包列表并安装所有PX4构建目标的依赖。 ubuntu自带的串口调制解调器严重的影响到了机器人串口相关的使用，可以没有任何副作用的卸载掉。 安装模拟工具CLANG 3.5。 添加当前用户到组”dialout“(如果这步没做，会导致很多用户权限问题)。 1~ $ sudo usermod -a -G dialout $USER Tip:如果你是Windows用户，可以点击视频教程，但是不推荐使用Windows进行开发。 代码编译然后就到了编译代码的阶段，那么首先得弄到代码，按照这个里面的步骤去做就好了，经测试ubuntu 14.04编译没有出现问题，建议安装ninja，它编译的速度比make要快。 想必有不懂Git是个啥的童鞋，那就看看这个Git教程-廖雪峰的官方网站/git BOOK吧，保证有帮助。比如我们的项目可以这么做： 123456789# =&gt; 本地创建文件夹，并关联远程仓库~ $ sudo apt-get install git-all~ $ makedir YuningFly~ $ cd YuningFly~/YuningFly $ git init~/YuningFly $ git add *~/YuningFly $ git commit -m "Commit message"~/YuningFly $ git remote add origin git@github.com:username/repository~/YuningFly $ git push -u origin master 关于下载代码这块，通过ssh支持的原生git协议下载速度最快，但是要先生成SSH keys，更多见教程，例如如采用原生git协议下载开源代码可以用 1~ $ git clone git@github.com:PX4/Firmware.git --------------ubuntu15.10 issues-------------- 如果你跟我一样用的是ubuntu 15.10，需要进行arm-none-eabi重新安装，默认是最新版，换成4.8版本，官网上的解决办法见地址，当然你也可以采用我下面的办法。 首先了解见博文，然后去GNU官方下载地址：https://launchpad.net/gcc-arm-embedded/+download下载gcc-arm-none-eabi-4_8-2014q3-20140805-linux.tar.bz2，或者直接使用命令 1wget wget https://launchpad.net/gcc-arm-embedded/5.0/5-2016-q2-update/+download/gcc-arm-none-eabi-5_4-2016q2-20160622-linux.tar.bz2 然后进入下载文件夹，进行如下操作： 1234567891011pushd .# =&gt; 卸载新版的gcc-arm-none-eabi~ $ sudo apt-get remove gcc-arm-none-eabi# =&gt; 安装下载好的gcc-arm-none-eabi~ $ tar xjvf gcc-arm-none-eabi-5_4-2016q2-20160622-linux.tar.bz2~ $ sudo mv gcc-arm-none-eabi-5_4-2016q2 /opt~ $ exportline="export PATH=/opt/gcc-arm-none-eabi-5_4-2016q2/bin:\$PATH"~ $ if grep -Fxq "$exportline" ~/.profile; then echo nothing to do ; else echo $exportline &gt;&gt; ~/.profile; fi# =&gt; 使路径生效~ $ . ~/.profilepopd 安装ccache，加快编译速度。 12345678sudo apt-get install ccachewhich ccache#查看安装路径, /usr/bin/ccachecd /opt/gcc-arm-none-eabi-5_4-2016q2/bin/sudo ln -s /usr/bin/ccache *export PATH=/usr/lib/ccache:$PATH#进行确认which arm-none-eabi-gcc 如果PC是ubuntu 64位系统，arm-none-eabi是直接下载人家编译好的32位的话，还需要一个东东： 1sudo apt-get install lsb-core 测试安装如下，如果出现如下信息，交叉编译环境搭建就没有什么问题了 12345678~/src/Firmware$ arm-none-eabi-g++ -vUsing built-in specs.COLLECT_GCC=arm-none-eabi-g++COLLECT_LTO_WRAPPER=/opt/gcc-arm-none-eabi-4_8-2014q3/bin/../lib/gcc/arm-none-eabi/4.8.4/lto-wrapperTarget: arm-none-eabiConfigured with: /home/build/work/GCC-4-8-build/src/gcc/configure --target=arm-none-eabi --prefix=/home/build/work/GCC-4-8-build/install-native --libexecdir=/home/build/work/GCC-4-8-build/install-native/lib --infodir=/home/build/work/GCC-4-8-build/install-native/share/doc/gcc-arm-none-eabi/info --mandir=/home/build/work/GCC-4-8-build/install-native/share/doc/gcc-arm-none-eabi/man --htmldir=/home/build/work/GCC-4-8-build/install-native/share/doc/gcc-arm-none-eabi/html --pdfdir=/home/build/work/GCC-4-8-build/install-native/share/doc/gcc-arm-none-eabi/pdf --enable-languages=c,c++ --enable-plugins --disable-decimal-float --disable-libffi --disable-libgomp --disable-libmudflap --disable-libquadmath --disable-libssp --disable-libstdcxx-pch --disable-nls --disable-shared --disable-threads --disable-tls --with-gnu-as --with-gnu-ld --with-newlib --with-headers=yes --with-python-dir=share/gcc-arm-none-eabi --with-sysroot=/home/build/work/GCC-4-8-build/install-native/arm-none-eabi --build=i686-linux-gnu --host=i686-linux-gnu --with-gmp=/home/build/work/GCC-4-8-build/build-native/host-libs/usr --with-mpfr=/home/build/work/GCC-4-8-build/build-native/host-libs/usr --with-mpc=/home/build/work/GCC-4-8-build/build-native/host-libs/usr --with-isl=/home/build/work/GCC-4-8-build/build-native/host-libs/usr --with-cloog=/home/build/work/GCC-4-8-build/build-native/host-libs/usr --with-libelf=/home/build/work/GCC-4-8-build/build-native/host-libs/usr --with-host-libstdcxx='-static-libgcc -Wl,-Bstatic,-lstdc++,-Bdynamic -lm' --with-pkgversion='GNU Tools for ARM Embedded Processors' --with-multilib-list=armv6-m,armv7-m,armv7e-m,armv7-rThread model: singlegcc version 4.8.4 20140725 (release) [ARM/embedded-4_8-branch revision 213147] (GNU Tools for ARM Embedded Processors) make成功后如下： 一般情况下，make出现主要问题有： arm-none-eabi路径不对 按如上arm-none-eabi重新安装设置即可。 arm-none-eabi-g++命令存在但报错找不到文件 安装32位的运行库。 1sudo apt-get install libc6:i386 libgcc1:i386 libstdc++5:i386 libstdc++6:i386 lib32z1 lib32ncurses5 没有更新Git子模块 1234~ $ git submodule init~ $ git submodule update --recursive#或者只要一行命令~ $ git submodule update --init --recursive 子模组问题 无法在子模组路径 ‘mavlink/include/mavlink/v2.0’ 中检出 ‘914eafd83851c499302aeb6f702da9069006f8f0’，一般删掉mavlink目录重新update就好了。或者先git submodule sync –recursive同步，再git submodule update –init –recursive更新。 需要重新编译 如果之前编译是可以的，更新后不能编译，试着删除根目录build_*文件夹，然后重新编译。 找不到/usr/bin/arm-none-eabi-objcopy，或者其它的也可以用类似的方法 1sudo ln -s /opt/gcc-arm-none-eabi-4_8-2014q3/bin/arm-none-eabi-objcopy /usr/bin/ 如果连接不上github，可以先试试这个连通站点 12&gt;~ $ ssh -T git@github.com&gt; 注意：如果你想跟进项目，但不知道怎么参与贡献，建议参考APM的文档，更多请参考这里。 使用make px4fmu-v2_default upload即可将固件上传到pixhawk，这个过程可能需要重新插拔USB线，上传完成如下： 这里要做的事情主要是： 克隆PX4软件到本地， make编译， 连接USB到无人机硬件，上传固件 软件在环测试（SITL）在直接到硬件之前，建议将模拟运行作为下一步。这个东西看起来很高端，有点摸不着头脑，以前没接触过，也觉得很深奥。跳到这里，看看赋予它的概念：软件在环仿真运行的主机上的完整系统，并模拟自动驾驶仪。SITL还可以参考Ardupilot的文档。它通过本地网络连接到模拟器。启动运行如下： 下面请将想办法给大家介绍清楚这个东西是什么，怎么用到PX4上，用到它有什么作用： 建议：如果有比较棘手的问题，可以在这里提问，好多不解的问题可以少走很多路。比如： 可以先了解PX4仿真的一些概念。PX4平台支持软件在环和硬件在环仿真。不同的是，使用SITL时，完整的模拟运行在主机（台式机、笔记本电脑），没有自动驾驶仪的硬件连接。这是测试新的算法和控制的最优办法，但它忽略了类似的硬件时间消耗或类似于堆栈大小的限制的事情。硬件在环仿真解决了这个问题，但是它的建立过程比较费时，因为硬件需要启动和刷新固件。软件在环仿真又分两种：标准软件在环仿真和ROS软件在环仿真。官方推荐使用标准软件在环仿真。标准软件在环仿真在单一的应用程序里以线程的形式最小依赖运行每个控制器和估算器。 下面是具体该怎么操作，最新的文档请到这里，建议参考这篇，但是新的QGC已经不需要这些步骤了，可以自动连接。 安装依赖项。 12# =&gt; 原网页为sudo apt-get install ant，经测试应该为如下～ $ sudo apt-get install ant openjdk-7-jdk openjdk-7-jre 启动、编译目标。 1~ $ make posix_sitl_default jmavsim 起飞。 1pxh&gt; commander takeoff 完成之后如图： 仿真时需要用到地面站QGroundControl( for short)，然后进行QGC 的安装，由于它的篇幅较大，可以给它开启新的一节。 地面控制站QGCQGC的官网是http://qgroundcontrol.org，可以从这里下载比较稳定的安装包解压，建议下载daily build的，里面有一些新的功能后面要用到，但是还是得安装Qt，如果不安装Qt，打开QGC会有缺少动态链接库的问题，从这里可以看到后缀名为.run的文件，点击后面的details，选择一个区域比较近的地址进行下载，下载完成后进行如下操作。 123456789101112131415161718192021222324252627282930~ $ chmod 777 qt-opensource-linux-x64-5.7.1.run~ $ ./qt-opensource-linux-x64-5.7.1.run# =&gt; 建议将目标文件夹选为$HOME/Qt($HOME为用户目录，替换为如/home/nephne)# =&gt; 相关依赖项的安装如下：~ $ sudo apt-get install espeak libespeak-dev libudev-dev libsdl1.2-dev# =&gt; Qt配置如下：# =&gt; 更换qt源，默认为qt4~ $ export QT_SELECT=qt5~ $ qtchooser -print-envQT_SELECT="default"QTTOOLDIR="/home/nephne/Qt5.7.1/5.7/gcc_64/bin"QTLIBDIR="/usr/lib/x86_64-linux-gnu"# =&gt; 更改文件/usr/lib/x86_64-linux-gnu/qtchooser/5.conf 第一行为：/home/$USER/Qt/5.5/gcc_64/bin(将$USER替换为用户名字)~ $ sudo vi /usr/lib/x86_64-linux-gnu/qtchooser/5.conf # =&gt; 我的如下：~ $ cat /usr/lib/x86_64-linux-gnu/qtchooser/5.conf /home/nephne/Qt5.7.1/5.7/gcc_64/bin/usr/lib/x86_64-linux-gnu~ $ qmake -vQMake version 3.0Using Qt version 5.7.1 in /home/nephne/Qt5.7.1/5.7/gcc_64/lib# =&gt; 如果出现如上的结果就可以进入解压后的QGC目录运行了~ $ cd $&#123;QGC_dir&#125;# =&gt; 运行如下的脚本文件，这个里边加载了动态库，如果你的Qt安装目录跟我的不一样，那样还得修改脚本~ $ ./qgroundcontrol-start.sh# =&gt; 如何进行源码编译~ $ git clone https://github.com/mavlink/qgroundcontrol.git~ $ git submodule init &amp;&amp; git submodule update# =&gt; 打开Qt Creator，选择qgroundcontrol根目录pro文件,工程设置到qt5.7.1版本进行编译即可 界面如下： 这里再回归到软件在环仿真上面来。当进行到上一节的commander takeoff命令后，打开QGC，点击又上角的Default UDP Link即可连接模拟器中的无人机，这样就可以通过地面在对模拟器中的无人机进行控制和数据分析，建议：QGC可支持操纵杆，如果想要手动输入，需要把系统置于手动飞行模式 (e.g. POSCTL, position control)。注意：需要下载daily build版的QGC才能启动操纵杆。启动操纵杆如下： 操纵杆如下： 界面如下： Gazebo仿真这是另外一种软件仿真，是一个自主机器人3D仿真环境。它能够作为一个完整的机器人仿真套件或脱机用于机器人。其中Plugin是自行编译的，过程如下： 安装过程如下: 1234567891011121314151617181920212223242526272829303132# =&gt; 安装Gazebo 6仿真器(ubuntu 15.10)&lt;http://gazebosim.org/tutorials?tut=install_ubuntu&amp;ver=6.0&amp;cat=install&gt;~ $ wget -O /tmp/gazebo6_install.sh http://osrf-distributions.s3.amazonaws.com/gazebo/gazebo6_install.sh; sudo sh /tmp/gazebo6_install.sh# =&gt; 运行~ $ gazebo# =&gt; 安装protobuf 库~ $ sudo apt-get install libprotobuf-dev libprotoc-dev protobuf-compiler libeigen3-dev# =&gt; 编译Gazebo插件# =&gt; 克隆gazebo plugins repository到~/src/sitl_gazebo~ $ git clone https://github.com/PX4/sitl_gazebo.git# =&gt; 在仓库的顶层建立Build文件夹~ $ mkdir Build # =&gt; 把build目录添加到gazebo plugin path，e.g.添加如下到我的.profile 文件# Set the plugin path so Gazebo finds our model and simexport GAZEBO_PLUGIN_PATH=$&#123;GAZEBO_PLUGIN_PATH&#125;:$HOME/src/sitl_gazebo/Build# Set the model path so Gazebo finds the airframesexport GAZEBO_MODEL_PATH=$&#123;GAZEBO_MODEL_PATH&#125;:$HOME/src/sitl_gazebo/models# Disable online model lookup since this is quite experimental and unstableexport GAZEBO_MODEL_DATABASE_URI=""# =&gt; 还需要添加仓库的主目录# Set path to sitl_gazebo repositoryexport SITL_GAZEBO_PATH=$HOME/src/sitl_gazebo# =&gt; 使生效~ $ source ~/.profile # =&gt; 进入Build目录执行make~ $ cd ~/src/sitl_gazebo/Build~ $ cmake ..# =&gt; 生成sdf文件~ $ make sdf# =&gt; 构建 gazebo plugins~ $ make# =&gt; 现在可以运行gazebo了～$ gazebo 下面可以按照教程进入仿真。 12~ $ cd ~/src/Firmware~ $ make posix_sitl_default gazebo QtCreator IDE建立工程 参考文章：旧版本/新版本 Qt Creator是最友好的变体，因此是官方唯一支持的IDE。除非你是Eclipse 或 Sublime方面的专家，否则不推荐使用！ 安装完qmake后，还要安装qtcreator，ubuntu下如下操作： 1~ $ sudo apt-get install qtcreator 常见功能如下： 打开Qt Creator之前, 应该创建project文件: 12345$ cd ~/src/Firmware$ mkdir ../Firmware-build$ cd ../Firmware-build$ cmake ../Firmware -G "CodeBlocks - Unix Makefiles"#可以发现Firmware-build目录生成了一些文件 Ubuntu用户只要导入主文件夹里的CMakeLists.txt文件就可以了，打开qtcreator，通过File -&gt; Open File or Project -&gt; 选择CMakeLists.txt构建目录选择src/Firmware-build 出现如下现象时点击完成即可 点击项目进入配置，配置页面见下图，详细配置见原文视频 配置完成后，点击左下角的运行，编译输出如下 连接USB到pixhawk，点击应用程序输出栏的绿色按钮重新执行此运行配置即可进行上传，输出如下 如果你比较喜欢使用Sublime Text，请按照linux下sublime text 2使用技巧安装使用，然后进入工程目录，执行命令即可。 123$ cscope -Rbkq$ ctags -R -f .tags$ sublime_text Firmware.sublime-project 编译代码快捷键为：Ctrl + B 总结教程到这里，基本的环境算是搭建好了，接下来应该就是各个模块的学习了，欢迎参考接下来的其它文章。 参考文献 dev.px4.io px4.io pixhawk.org dev.ardupilot.com planner.ardupilot.com copter.ardupilot.com travis-ci.org exbot资源分享]]></content>
      <categories>
        <category>飞控</category>
      </categories>
      <tags>
        <tag>PX4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初学crazyflie2.0之diy硬件]]></title>
    <url>%2F2017%2F07%2F30%2F%E5%88%9D%E5%AD%A6crazyflie2-0%E4%B9%8Bdiy%E7%A1%AC%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[JLinkGDBServer调试添加JLink到STM32F405RG，确保Vsupply接口存在电压。打开服务器端，这是arm-none-eabi-gdb调试的后台，如下。 123456789101112131415161718192021222324252627282930313233343536373839JLinkGDBServer -if SWD -device STM32F405RGSEGGER J-Link GDB Server V5.12g Command Line VersionJLinkARM.dll V5.12g (DLL compiled May 27 2016 17:03:38)-----GDB Server start settings-----GDBInit file: noneGDB Server Listening port: 2331SWO raw output listening port: 2332Terminal I/O port: 2333Accept remote connection: yesGenerate logfile: offVerify download: offInit regs on start: offSilent mode: offSingle run mode: offTarget connection timeout: 0 ms------J-Link related settings------J-Link Host interface: USBJ-Link script: noneJ-Link settings file: none------Target related settings------Target device: STM32F405RGTarget interface: SWDTarget interface speed: 1000kHzTarget endian: littleConnecting to J-Link...J-Link is connected.Firmware: J-Link ARM V8 compiled Nov 28 2014 13:44:46Hardware: V8.00S/N: 20121126Feature(s): RDI,FlashDL,FlashBP,JFlashChecking target voltage...Target voltage: 3.31 VListening on TCP/IP port 2331Connecting to target...Connected to targetWaiting for GDB connection... 开始GDB调试注意如下，在用户目录下面创建.gdbinit文件。To enable execution of this file add add-auto-load-safe-path /home/nephne/src/Bootloader/.gdbinitline to your configuration file “/home/nephne/.gdbinit”. 编写工程目录下面的.gdbinit文件。 1234567891011121314target remote :2331set mem inaccessible-by-default off monitor speed automonitor endian littlemonitor resetmonitor flash device = STM32F405RGmonitor flash breakpoints = 1 monitor flash download = 1 loadmonitor reg sp = (0x08000000)monitor reg pc = (0x08000004)break mainlayout src# 可以使用next 1000运行到断点main处 运行命令如下，即可运行gdb的相关命令，如next，step，continue等等，其中layout src为显示源代码窗口。 1arm-none-eabi-gdb build_crazyflie_bl/crazyflie_bl.elf 下载代码更新bootloader除了使用JLink也可以使用dfu-util工具。 12345678910111213141516171819202122232425262728sudo dfu-util -d 0483:df11 -a 0 -s 0x08000000 -D crazyflie_bl.binGNU gdb (GNU Tools for ARM Embedded Processors) 7.6.0.20140731-cvsCopyright (C) 2013 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law. Type "show copying"and "show warranty" for details.This GDB was configured as "--host=i686-linux-gnu --target=arm-none-eabi".For bug reporting instructions, please see:&lt;http://www.gnu.org/software/gdb/bugs/&gt;...Reading symbols from /home/nephne/src/Bootloader/crazyflie_bl.elf...done.reset_handler () at ../../cm3/vector.c:6767 for (src = &amp;_data_loadaddr, dest = &amp;_data;Select auto target interface speed (2000 kHz)Target endianess set to "little endian"Resetting targetSelecting device: STM32F405RGFlash breakpoints enabledFlash download enabledLoading section .text, size 0x2204 lma 0x8000000Loading section .data, size 0x54 lma 0x8002204Start address 0x8000000, load size 8792Transfer rate: 8585 KB/sec, 4396 bytes/write.Writing register (SP = 0x20020000)Writing register (PC = 0x080018BD)Breakpoint 1 at 0x8000b40: file main_f4.c, line 687.(gdb) 如果想在下载时看到灯闪烁，需要修改bootloader源码，因为买的开发板与原版crazyflie原理图还是有差异的。 123456789101112131415161718192021222324252627282930313233343536 # # Submodule management #diff --git a/hw_config.h b/hw_config.hindex dd271d3..234f7d0 100644--- a/hw_config.h+++ b/hw_config.h@@ -511,8 +511,8 @@ # define OSC_FREQ 8-# define BOARD_PIN_LED_ACTIVITY GPIO0-# define BOARD_PIN_LED_BOOTLOADER GPIO2+# define BOARD_PIN_LED_ACTIVITY GPIO5+# define BOARD_PIN_LED_BOOTLOADER GPIO5diff --git a/main_f4.c b/main_f4.cindex 4b25c99..289e655 100644--- a/main_f4.c+++ b/main_f4.c@@ -636,7 +636,7 @@ flash_func_read_sn(uint32_t address) &#125; void-led_on(unsigned led)+led_off(unsigned led) &#123; switch (led) &#123; case LED_ACTIVITY:@@ -650,7 +650,7 @@ led_on(unsigned led) &#125; void-led_off(unsigned led)+led_on(unsigned led) &#123; switch (led) &#123; case LED_ACTIVITY:@@ -709,6 +709,9 @@ main(void) 更新固件更新固件，官网的方式为： 1make crazyflie_default upload 但我的板子连接不上串口，改写源代码Firmware/Tools/px_uploader.py如下。 12345678910111213141516171819202122232425262728293031@@ -450,10 +450,10 @@ class uploader(object): msg = "Firmware not suitable for this board (board_type=%u board_id=%u)" % ( self.board_type, fw.property('board_id')) print("WARNING: %s" % msg)- if args.force:- print("FORCED WRITE, FLASHING ANYWAY!")- else:- raise IOError(msg)+ #if args.force:+ print("FORCED WRITE, FLASHING ANYWAY!")+ #else:+ # raise IOError(msg) if self.fw_maxsize &lt; fw.property('image_size'): raise RuntimeError("Firmware image is too large for this board") # Spin waiting for a device to show up try:@@ -563,10 +564,12 @@ try: portlist += glob.glob(pattern) else: portlist = patterns - for port in portlist:-- #print("Trying %s" % port)+ + for port in patterns:+ port = "/dev/serial/by-id/pci-Bitcraze_AB_Crazyflie_BL_0-if00"+ print("Trying %s" % port) # create an uploader attached to the port try: 其中/dev/serial/by-id/pci-Bitcraze_AB_Crazyflie_BL_0-if00为串口id，是在 usb_cinit(void) 函数里被设定的，如下，具体见usb_strings的定义，有# define USBMFGSTRING “Bitcraze AB”。 1234567891011usbd_dev = usbd_init(&amp;otgfs_usb_driver, &amp;dev, &amp;config, usb_strings, NUM_USB_STRINGS, usbd_control_buffer, sizeof(usbd_control_buffer));static const char *usb_strings[] = &#123; USBMFGSTRING, /* Maps to Index 1 Index */ USBDEVICESTRING, "0",&#125;;# define USBMFGSTRING "Bitcraze AB"# define USBDEVICESTRING "Crazyflie BL" 最后更新固件成功后为： 12345678910111213141516171819Found board c,0 bootloader rev 5 on /dev/serial/by-id/pci-Bitcraze_AB_Crazyflie_BL_0-if00WARNING: Firmware not suitable for this board (board_type=12 board_id=5)FORCED WRITE, FLASHING ANYWAY!ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff type: ÿÿÿÿidtype: =FFvid: ffffffffpid: ffffffffcoa: //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8=sn: 002a00343432470d33363638chip: 10016413family: STM32F40xrevision: Zflash 1032192Erase : [====================] 100.0%Program: [====================] 100.0%Verify : [====================] 100.0%Rebooting. 启动过程，如果固件加载ok，会启动px4主流程，Bootloader里面见main_f4.c，可用JLink调试是否运行至此。 12/* try to boot immediately */jump_to_app(); 串口调试串口连接为PC10:E_TX1, PC11:E_RX1，连接usb转串口设备如下，当然我的外围设备都失败了。关于引脚定义查找px4 board.h里面的源码： 123/* E_TX1 / E_RX1 */#define GPIO_USART3_RX GPIO_USART3_RX_2#define GPIO_USART3_TX GPIO_USART3_TX_2 串口显示如下：1234567891011121314151617sercon: Registering CDC/ACM serial driversercon: Successfully registered the CDC/ACM serial drivernsh: mount: mount failed: No such file or directorynsh: mkfatfs: mkfatfs failed: No such file or directoryERROR [mtd] failed to initialize EEPROM driverWARN [param] selected parameter default file /fs/microsd/paramsWARN [param] open failed '/fs/microsd/params'WARN [modules__systemlib] failed to open param file: /fs/microsd/paramsWARN [param] Param export failed.nsh: rgbled: command not foundnsh: blinkm: command not found BAT_N_CELLS: curr: 0 -&gt; new: 3WARN [modules__systemlib] failed to open param file: /fs/microsd/paramsWARN [param] Param export failed.NuttShell (NSH)nsh&gt; \0x1b]]></content>
      <categories>
        <category>飞控</category>
      </categories>
      <tags>
        <tag>crazyflie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pixhawk试飞报告]]></title>
    <url>%2F2017%2F06%2F16%2Fpixhawk%E8%AF%95%E9%A3%9E%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[本文将一个新手学习px4入门，装机，PID调节过程，以及试飞注意事项陈述如下： 器件准备硬件一套，包括DJI F450机架、Pixhawk 2.4.6 mini飞控、好盈乐天20A电调、1045正反桨、银燕电机2216、天地飞6通道遥控器。详情见淘宝链接里的套餐方案。 这些是PX4自动驾驶仪的元件要求： 1x Pixhawk 或者 FMU + IO Kit (Pixhawk 和FMU + IO是一样的) 1x u-blox GPS模块 1x RC 接收器 1x 无线数传 多块3300 mAh LiPo电池，至少能提供25A/30A电流。最好是买几个相同的电池为了保持直升飞机更换电池的重量恒定。 装机 这里有多达200页的超详细图文教程，一步一步教您装机，学不会都很难！ 更多查询EXUAV-mini测评报告产品介绍、产品开箱、飞控接线与安装、飞行测试（视频来源：EXUAV）如下 pix4 mini主要装机图文概览（注：图片来源于模友之吧，如有不妥，请提出）： 前排插针 后排插针 蜂鸣器PM 电源电压电流计 PPM 转接板 安全开关 迷你OSD GPS 和罗盘 数传 使用说明b6平衡充 电机转向电机实际连接图：装浆的时候按住浆不动，按照上图所示电机转向旋转电机即可 装机完成 你也可以看如下的视频教程：分为几个视频第一个为安装（分电板焊接，电机香蕉头焊接，整机组装，飞控以及配件的安装）第二个为遥控器设置（混控，失控保护设置）第三个为地面站使用（固件刷写，reset，校准） 关于APM版的pixhawk参考泡泡老师教程，注意电压电流校准，及低电压报警设置，不然会飞不久自动降落。 注意： 上电测试：检查焊点的极性(黑色/红色)。卸载螺旋桨，准备新的电池到室外去。不要压在四轴上，连接电池，随时准备拔掉电池。四个电机将同时响。这个测试的目的是确保在装配没有导致短路或反极性。 连接电机：根据上面电机转向的图片，经过转向测试后连接电机。 电源线路连接：详细请见Powering the Pixhawk 主控板接口说明：详情见pixhawk模块 安装QGCQGroundControl地面站简称QGC，通过官网下载安装，普通用户应该下载稳定版本，如果是开发人员，可以参考这里安装daily build版本。 更新固件&amp;校准按照下面视频里的步骤进行。 这里注意的有： 方位角都设为0, gps的方向与主控方向相同。 系统提示请观看下面的视频了解如何锁定,解除系统。注意音频和视觉信号。 测试手动模式试飞的第一步就是测试手动（直通）模式。就是直接通过遥控器控制飞行器，所有的飞行都必须这一步。 电池连接当系统进入手动状态时，动力只有通过USB将无法驱动伺服系统。你必须连接一个电池，飞行模式才能正常运行。 手动模式确保你已经完成了遥控器的校准。按照如下方式进入手动模式： 开启QGC(可选) 打开遥控器 给px4供电 连接px4 USB(可选) 按下安全开关直到快速闪动 将遥控器的油门杆打到右下角 你能听得px4代表armed的声音警报 移动油门杆可以看到电机转动 飞行模式就飞行练习来说，主要是要熟悉飞控的各种飞行模式及其切换，在这里首先要做的是设置遥控器5通道，以达到能使用遥控器切换多种飞行模式的效果，具体可参考自己购买的遥控器说明。 另外对于各个飞行模式的特点及其需要注意的地方建议查看官网或者中文网wiki，较熟悉后可以大大程度减少炸机的几率。 手机控制(可选)可以自己买一个蓝牙从机模块如hc-06，按照串口的连接方式连接到pixhawk的数传接口TELEM1，注意蓝牙的波特率设为57600，然后下载手机端地面站如飞鱼地面站或playUAV进行蓝牙连接即可。如果只是想查看地面站信息，这样可以省掉一个数传哦。 连接方式如下图： PID调节(可选)调参请装至QGC界面参数窗口！或者找到System Parameters &gt; SYS_AUTOSTART，如果为4011，则找到/src/Firmware/ROMFS/px4fmu_common/init.d里的4011_dji_f450进行更改，当然也可自行添加，例子如下： 1234567891011121314151617181920212223242526272829303132333435363738#!nsh## @name DJI Flame Wheel F450## @type Quadrotor x## @output AUX1 feed-through of RC AUX1 channel# @output AUX2 feed-through of RC AUX2 channel# @output AUX3 feed-through of RC AUX3 channel## @maintainer Lorenz Meier &lt;lorenz@px4.io&gt;#sh /etc/init.d/4001_quad_xif [ $AUTOCNF == yes ]then param set MC_ROLL_P 7.0 param set MC_ROLLRATE_P 0.15 param set MC_ROLLRATE_I 0.05 param set MC_ROLLRATE_D 0.01 param set MC_PITCH_P 7.0 param set MC_PITCHRATE_P 0.15 param set MC_PITCHRATE_I 0.05 param set MC_PITCHRATE_D 0.01 param set MC_YAW_P 2.8 param set MC_YAWRATE_P 0.3 param set MC_YAWRATE_I 0.1 param set MC_YAWRATE_D 0.0 # DJI ESCs do not support calibration and need a higher min param set PWM_MIN 1230fi# Transitional support: ensure suitable PWM min/max param valuesif param compare PWM_MIN 1075then param set PWM_MIN 1230fi 介绍PX4 multirotor_att_control应用程序执行一个外循环的方向控制器，相关参数为： 翻滚角(MC_ROLL_P) 俯仰角(MC_PITCH_P) 航向角(MC_YAW_P) 和一个内部循环，有三个独立的控制角度变化率PID控制器： 翻滚角率(MC_ROLLRATE_P, MC_ROLLRATE_I, MC_ROLLRATE_D) 俯仰角率(MC_PITCHRATE_P, MC_PITCHRATE_I, MC_PITCHRATE_D) 航向角率(MC_YAWRATE_P, MC_YAWRATE_I, MC_YAWRATE_D) 外部循环的输出是机体的目标速率（eg. 如果四轴目标角度为0，而目前左右倾斜30度，那么控制输出将可以是这样的：翻滚速率为60度每秒）。内部速率控制回路改变电机输出，这样四轴能按所需的角速度旋转。 这些参数的大小实际上有一个直观的意义，eg. 如果MC_ROLL_P的值为6.0，四轴将补偿的角度偏差值为0.5弧度(30度)，那么目标角速率将为3 弧度/秒。然后如果内环MC_ROLLRATE_P的值为0.1，最后输出给翻滚角的油门控制量将为3 * 0.1 = 0.3。这意味着它将降低电机一边30%的速度，增加另一边30%速度来诱导角动量回到水平。 这里还有一个MC_YAW_FF参数，它控制用户输入反馈给航向速率控制器的灵敏度。0代表非常慢的控制，只有航向位置错误的时候控制器才会响应，1代表灵敏的控制，但是可能有些过调，由于控制器移动航向迅速，导致很难保持航向为0。 第一步：准备首先，把所有的参数设为初始值： 设置MC_XXX_P为0(ROLL, PITCH, YAW) 设置所有的MC_XXXRATE_P, MC_XXXRATE_I, MC_XXXRATE_D为0，除了MC_ROLLRATE_P 和 MC_PITCHRATE_P。 设置MC_ROLLRATE_P 和 MC_PITCHRATE_P为一个比较小的值，比如. 0.02 设置MC_YAW_FF为0.5 所有的参数应该慢慢的增大，每次增大20%到30%，甚至最后10%，注意：参数过大会导致非常危险的震荡，即使只有理想参数的1.5到2倍。 第二步：稳定横滚和俯仰率P调优参数：MC_ROLLRATE_P, MC_PITCHRATE_P 如果四轴是对称的，那么ROLL和PITCH的值应该相等，否则应该独立的调整。 把四轴拿到手上，然后增大油门到大约50%，这样四轴重量可以视为0。使它在翻滚角或者俯仰角方向倾斜，观察起反应。它应该温和的转动，但是它不会回到水平。如果出现震荡，把RATE_P调小。一旦控制响应缓慢但正确，增加RATE_P直到它开始振荡。然后减小RATE_P直到它只有轻微摆动或不再摆动（大约减少10%）,稍微有点过调。典型的值大约是0.1。 D调优参数：MC_ROLLRATE_D, MC_PITCHRATE_D 假设P参数是一个使电机震荡的状态，RATE_P略小。慢慢的增大RATE_D，从0.01开始，直到震荡停止之前。如果电机出现颠簸，RATE_D太大了，减小它。通过RATE_P和RATE_D可以调优四轴的响应。典型值为0.01到0.02。 在QGC中，可以绘出roll和pitch的变化速率图(ATTITUDE.rollspeed/pitchspeed)。它不能震荡，可以有10%到20%的过调。 I调优 如果横滚速率和俯仰速率没有达到设定值，但有一个偏移量，加上MC_ROLLRATE_I和MC_PITCHRATE_I参数。从MC_ROLLRATE_P值的5-10%开始调。 第三步：稳定横滚和俯仰角度P调优参数：MC_ROLL_P, MC_PITCH_P 设置 MC_ROLL_P 和 MC_PITCH_P到一个比较小的值，比如. 3 把四轴拿到手上，然后增大油门到大约50%，这样四轴重量可以视为0。使它在翻滚角或者俯仰角方向倾斜，观察起反应。它应该缓慢回到水平。如果出现震荡，调整P。只要控制响应缓慢但正确，继续增大P直到出现震荡。最优的响应是10-20%的过调。得到稳定的响应后重新调整RATE_P, RATE_D参数。 在QGC上位机里，你能绘出roll和pitch的图像(ATTITUDE.roll/pitch)及control(ctrl0,ctrl1)。姿态角如果过调不能超过10-20%。 第四步：稳定航向速率P调优参数：MC_YAWRATE_P。 设置MC_YAWRATE_P为一个比较小的值，比如. 0.1 把四轴拿到手上，然后增大油门到大约50%，这样四轴重量可以视为0。然后绕Z轴旋转，观察其响应。电机的声音听起来改变了，系统有阻止旋转的趋势。响应将大大低于横滚和俯仰，这是可以的。如果出现震荡或者颠簸，调小RATE_P。如果很小的移动出现很大的响应（大油门和小油门时），减小RATE_P。典型值为0.2到0.3。 航向速率控制如果非常强烈甚至震荡，会恶化横滚和俯仰的响应。扭转横滚、俯仰和偏航检查总反应。 第五步：稳定航向角P调优参数：MC_YAW_P。 设置MC_YAW_P为一个比较小的值，比如1。 把四轴拿到手上，然后增大油门到大约50%，这样四轴重量可以视为0。然后绕Z轴旋转，观察其响应。它应该慢慢回到起始方向。如果出现震荡，调小P。只要控制响应缓慢但正确，继续增大P，直到响应稳定，但是不震荡。典型值是2到3。 可以在QGC里查看ATTITUDE.yaw。航向角过调不能超过2-5%(比姿态角要小)。 反馈调优参数：MC_YAW_FF。 这个参数不是关键，可以在飞行时调整，在最差情况下是偏航角响应迟缓或太快。调整FF参数得到一个合适的响应。有效范围为0到1。典型值为0.8到0.9。（如果用于航拍，建议将值调小以得到更加圆滑的反应） 可以在QGC里查看ATTITUDE.yaw。航向角过调不能超过2-5%(比姿态角要小)。 飞行注意事项及效果起飞阶段 定高阶段 官方测试视频： 防炸机经验总结 当使用gps进行留待模式loiter飞行时，注意方向档响应慢，随时准备打到自稳自救。 飞行记录分析飞行log分析：http://logs.uaventure.com/view/dgz379gyc72broL4k6TQHLapm数据分析：http://ardupilot.org/dev/docs/using-mavexplorer-for-log-analysis.html简单来说命令就是：MAVExplorer.py *.BIN或者使用FlightPlot：https://github.com/DrTon/FlightPlot 参考文献：用户文档/用户教程/快速学习/多轴飞行器教程/F450安装/PID调试]]></content>
      <categories>
        <category>飞控</category>
      </categories>
      <tags>
        <tag>pixhawk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初学PX4之飞控算法]]></title>
    <url>%2F2017%2F06%2F16%2F%E5%88%9D%E5%AD%A6PX4%E4%B9%8B%E9%A3%9E%E6%8E%A7%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[注意：基于参考原因，本文参杂了APM的算法分析。 本篇文章首先简述了下px4和apm调用姿态相关应用程序出处，然后对APM的DCM姿态解算算法参考的英文文档进行了翻译与概括，并结合源代码予以分析，在此之前，分析了starlino的DCM，并进行了matlab的实现，因为它更加利于理解。后段时间会对px4的四元数姿态解算进行分析。姿态控制部分描述了串级PID在APM里的实现流程，同样后期会完善对px4的分析。最后针对自己平时使用的一些调试技巧进行了总结。 姿态出处分析 下面看下重要的一个脚本/etc/init.d/rc.mc_apps，可以知道姿态估计用的是attitude_estimator_q和position_estimator_inav，用户也可以选择local_position_estimator、ekf2，而姿态控制应用为mc_att_control和mc_pos_control。 1234567891011121314151617181920212223242526272829#!nshif param compare INAV_ENABLED 1then attitude_estimator_q start position_estimator_inav startelse if param compare LPE_ENABLED 1 then attitude_estimator_q start local_position_estimator start else ekf2 start fifiif mc_att_control startthenelse # try the multiplatform version mc_att_control_m startfiif mc_pos_control startthenelse # try the multiplatform version mc_pos_control_m startfi... 而在ardupilot中，姿态解算与控制算法在ArduCopter.cpp的fast_loop任务中以400Hz的频率运行。 12345678910111213141516// Main loop - 400hzvoid Copter::fast_loop()&#123; // IMU DCM Algorithm // -------------------- read_AHRS(); ...&#125;void Copter::read_AHRS(void)&#123; ... ahrs.update();&#125; 了解了上面的源码出处后，下面将分具体应用进行分析。 姿态传感器数据采集首先进行传感器的初始化，主要步骤为：关闭软件低频滤波器、设置传感器量程、关闭硬件低频滤波器、设置采样频率、设置队列深度，具体实现如下： 1234567891011121314151617181920212223242526// software LPF offioctl(fd, ACCELIOCSLOWPASS, 0);// 16g rangeioctl(fd, ACCELIOCSRANGE, 16);switch(devid) &#123; case DRV_ACC_DEVTYPE_MPU6000: case DRV_ACC_DEVTYPE_MPU9250: // hardware LPF off ioctl(fd, ACCELIOCSHWLOWPASS, 256); // khz sampling ioctl(fd, ACCELIOCSSAMPLERATE, 1000); // 10ms queue depth ioctl(fd, SENSORIOCSQUEUEDEPTH, _queue_depth(1000)); break; case DRV_ACC_DEVTYPE_LSM303D: // hardware LPF to ~1/10th sample rate for antialiasing ioctl(fd, ACCELIOCSHWLOWPASS, 194); // ~khz sampling ioctl(fd, ACCELIOCSSAMPLERATE, 1600); ioctl(fd,SENSORIOCSPOLLRATE, 1600); // 10ms queue depth ioctl(fd, SENSORIOCSQUEUEDEPTH, _queue_depth(1600)); break; default: break;&#125; 然后以400HZ频率的循环任务通过SPI通信来采集传感器数据，并将采集到的数据进行纠错处理，如减去静态偏差量。此时，将采集到的这些数据同步写入SD卡，以便于飞行测试后期进行数据分析。这个过程的数据是以结构体的形式存放于全局变量imu中，后面进行姿态解算时直接读取该变量的值即可。同步写入SD卡实现如下： 12345678910111213DataFlash_Class *dataflash = get_dataflash();if (dataflash != NULL) &#123; uint64_t now = AP_HAL::micros64(); struct log_GYRO pkt = &#123; LOG_PACKET_HEADER_INIT((uint8_t)(LOG_GYR1_MSG+instance)), time_us : now, sample_us : sample_us?sample_us:now, GyrX : gyro.x, GyrY : gyro.y, GyrZ : gyro.z &#125;; dataflash-&gt;WriteBlock(&amp;pkt, sizeof(pkt));&#125; 姿态估算DCM_tutorial imu_guide/imu_guide中文翻译/dcm_tutorial/wiki资料查询/该部分算法源码参考将该算法转换为了matlab实现，想了解的可以查看我的github里的DCM工程，能够更好的理解算法，另外，该matlab实现还有一定的bug，希望各位大神的pull request~这部分翻译自dcm_tutorial，并结合源码进行分析，可作为下部分DCM理论介绍的基础哦，所以建议先将这部分看完再往下看～ DCM矩阵： 设机体坐标系为Oxyz，与机体坐标系同x,y,z方向的单位向量为i, j, k。地理坐标系为OXYZ，同理地理坐标系的单位向量为 I, J, K。共同原点为O。如图 I\(^G\) = {1,0,0}\(^T\), J\(^G\)={0,1,0}\(^T\) , K\(^G\) = {0,0,1}\(^T\) i\(^B\) = {1,0,0}\(^T\), j\(^B\)={0,1,0}\(^T\) , k\(^B\) = {0,0,1}\(^T\) 下面将i，j，k向量用地理坐标系表示，首先以i作为一个例子。 i\(^G\) = {i\(_x\)\(^G\) , i\(_y\)\(^G\) , i\(_z\)\(^G\)}\(^T\) 其中i\(_x\)\(^G\)表示的是i向量在地理坐标系X轴上的投影，即 i\(_x\)\(^G\) = |i| cos(X,i) = cos(I,i) 在这个式子中，|i|是i单位向量的范式（长度），cos(I,i)是向量I和向量i夹角的余弦，因此可以这样写： i\(_x\)\(^G\) = cos(I,i) = |I||i| cos(I,i) = I.i 在这个式子中，I.i是向量I和向量i的点积，由于只是计算点积，我们并不关心向量是在哪个坐标系中测量的，只要都是以同一个坐标系表示即可。所以： I.i = I\(^B\).i\(^B\) = I\(^G\).i\(^G\) = cos(I\(^B\).i\(^B\)) = cos(I\(^G\).i\(^G\)) 同样的： i\(_y\)\(^G\) = J.i , i\(_z\)\(^G\)=K.i 所以i向量可以用地理坐标系表示为： i\(^G\)= { I.i, J.i, K.i}\(^T\) 同样的，j，k向量可以表示为： j\(^G\)= { I.j, J.j, K.j}\(^T\) , k\(^G\)= { I.k, J.k, K.k}\(^T\) 将机体坐标i，j，k的地理坐标表示以矩阵的形式表示为： 这就是方向余弦矩阵，它是由机体坐标系和地理坐标系向量所有两两向量组合的夹角的余弦组成，可以算出共有9\(\times\)9种。 下一节的DCM理论里面有另外一种推理DCM的方法，建议交互思考！ 而将地理坐标系在机体坐标系中表示与将机体坐标系在地理坐标系中表示是对称的，所以只需简单交换I, J, K 和 i, j, k即可。I\(^B\)= { I.i, I.j, I.k}\(^T\) , J\(^B\)= { J.i, J.j, J.k}\(^T\) , K\(^B\)= { K.i, K.j, K.k}\(^T\)转化为矩阵形式为： 很容易可以发现： DCM\(^B\) = (DCM\(^G\))\(^T\) or DCM\(^G\) = (DCM\(^B\))\(^T\)，换句话说，这两个矩阵是可以相互转换的。 也可以发现： DCM\(^B\). DCM\(^G\) = (DCM\(^G\))\(^T\) .DCM\(^G\) = DCM\(^B\). (DCM\(^B\))\(^T\) = I\(_3\) 其中I\(_3\)为3\(\times\)3的单位矩阵，换句话说，DCM矩阵是正交矩阵。 证明如下： 证明这个我们需要知道这些特性：i\(^{GT}\). i\(^G\) = | i\(^G\)|| i\(^G\)|cos(0) = 1， i\(^{GT}\). j\(^G\) = 0，因为i和j是正交的。 方向余弦矩阵也称为旋转矩阵，如果知道机体坐标，则可以算出任意向量的地理坐标（反之同理），下面以机体坐标系向量使用DCM算出地理坐标作为例子进行推理：r\(^B\)= { r\(_x\)\(^B\), r\(_y\)\(^B\), r\(_z\)\(^B\)}\(^T\)而r\(^G\) = { r\(_x\)\(^G\) , r\(_y\)\(^G\) , r\(_z\)\(^G\) }\(^T\)现在让我们分析第一个坐标r\(_x\)\(^G\)：r\(_x\)\(^G\) = | r\(^G\)| cos(I\(^G\),r\(^G\))，由于坐标系旋转，向量的大小，夹角都不会变，故有：| r\(^G\)| = | r\(^B\)| , | I\(^G\)| = | I\(^B\)| = 1 ， cos(I\(^G\),r\(^G\)) = cos(I\(^B\),r\(^B\))，所以：r\(_x\)\(^G\) = | r\(^G\)| cos(I\(^G\),r\(^G\)) = | I\(^B\) || r\(^B\)| cos(I\(^B\),r\(^B\)) = I\(^B\). r\(^B\) = I\(^B\). { r\(_x\)\(^B\), r\(_y\)\(^B\), r\(_z\)\(^B\)}\(^T\)由上可知，r\(^B\)= { r\(_x\)\(^B\), r\(_y\)\(^B\), r\(_z\)\(^B\)}\(^T\)，替换得：r\(_x\)\(^G\) = I\(^B\). r\(^B\) = { I.i, I.j, I.k}\(^T\) . { r\(_x\)\(^B\), r\(_y\)\(^B\), r\(_z\)\(^B\)}\(^T\) = r\(_x\)\(^B\) I.i + r\(_y\)\(^B\) I.j + r\(_z\)\(^B\) I.k同样的思路：r\(_y\)\(^G\) = rx\(^B\) J.i + ry\(^B\) J.j + rz\(^B\) J.krz\(^G\) = rx\(^B\) K.i + ry\(^B\) K.j + rz\(^B\) K.k转化为矩阵形式为： 得证。 同样的思路可以证明： 也可以这样证明： DCM\(^B\) r\(^G\) = DCM\(^B\) DCM\(^G\) r\(^B\) = DCM\(^{GT}\) DCM\(^G\) r\(^B\) = I\(_3\) r\(^B\) = r\(^B\) 角速度： 如下图所示，r为任意的旋转向量，t时刻的坐标为r(t)。时间间隔dt后：r = r (t) , r’= r (t+dt) and dr = r’ – r。 dt时间后向量r绕着与单位向量u同向的轴旋转了d\(\theta\)，停到了向量r’的位置。其中u垂直与旋转的机身，因此u正交于r与r’，图中显示了u与u’，它们与r和r‘的叉乘结果方向相同。故有 u = (r x r’) / |r x r’| = (r x r’) / (|r|| r’|sin(dθ)) = (r x r’) / (|r|\(^2\) sin(dθ)) 由于旋转并不改变向量的长度，因此有| r’| = |r|。 向量r的线速度可以表示如下： v = dr / dt = ( r’ – r) / dt 当dθ → 0时，向量r和dr的夹角\(\alpha\)可通过r，r’和dr组成的等腰三角形计算： α = (π – dθ) / 2 当dθ→ 0时，α → π/2。 这告诉我们，当dt → 0时，r垂直于dr，因此r ⊥ v （v和dr的方向是一致的）。 现在定义角速度向量，其中反应了角度的变化率和旋转轴方向。 w = (dθ/dt ) u 下面分析w和v之间的关系：w = (dθ/dt ) u = (dθ/dt ) (r x r’) / (|r|\(^2\) sin(dθ))当dt → 0时，dθ → 0，因此sin(dθ) ≈ dθ。化简得：w = (r x r’) / (|r|\(^2\) dt)现在由于 r’ = r + dr , dr/dt = v , r x r = 0，利用叉乘的加法分配率可得：w = (r x (r + dr)) / (|r|\(^2\) dt) = (r x r + r x dr)) / (|r|\(^2\) dt) = r x (dr/dt) / |r|\(^2\)最后得出：w = r x v / |r|\(^2\)下面反向推理证明v = w x r利用向量的三重积公式：(a x b) x c = (a.c)b – (b.c)a，以及v和r是垂直的，所以v.r = 0w x r = (r x v / |r|\(^2\)­) x r = (r x v) x r / |r|\(^2\)­ = ((r.r) v + (v.r)r) / |r|\(^2\)­ = ( |r|\(^2\)­ v + 0) |r|\(^2\) = v得证。 陀螺仪及角速度向量 如果我们定期获取陀螺仪的值，时间间隔为dt，那么陀螺仪将会告诉我们在这段时间，地球绕陀螺仪各轴旋转的度数。dθ\(_x\) = w\(_x\)dt，dθ\(_y\) = w\(_y\)dt，dθ\(_z\) = w\(_z\)dt其中w\(_x\) = w\(_x\) i = {w\(_x\) , 0 , 0 }\(^T\) , w\(_y\) = w\(_y\) j = { 0 , w\(_y\) , 0 }\(^T\) , w\(_z\) = w\(_z\) k = { 0 , 0, w\(_z\) }\(^T\)每次旋转都会产生线性的位移dr\(_1\) = dt v\(_1\) = dt (w\(_x\) x r) ; dr\(_2\) = dt v\(_2\) = dt (w\(_y\) x r) ; dr\(_3\) = dt v\(_3\) = dt (w\(_z\) x r) .矢量相加：dr = dr\(_1\) + dr\(_2\) + dr\(_3\) = dt (w\(_x\) x r + w\(_y\) x r + w\(_z\) x r) = dt (w\(_x\) + w\(_y\) + w\(_z\)) x r因此线速度可以表示为：v = dr/dt = (w\(_x\) + w\(_y\) + w\(_z\)) x r = w x r这里的条件是dt很小才能这么推理，也就是说，dt越大误差也就越大。 基于6DOF或者9DOF的IMU传感器DCM互补滤波算法 科普：6DOF由三轴陀螺仪和三轴加速度计组成，9DOF由三轴磁力计、三轴陀螺仪和三轴加速度计组成。定义右手地理坐标系：I指向北方，K指向顶部，J指向西方。 IMU组成机体坐标系，IMU包括陀螺仪、加速度计等。 加速度计能感应重力，重力向量指向地心，与顶部向量K\(^B\)方向相反，假如加速度计输出为A = {A\(_x\) , A\(_y\) , A\(_z\) }，则K\(^B\) = –A。 磁力计与加速度计相似，除了磁力计可以感应地理的北方以外，假设正确的磁力计输出为M = {M\(_x\) , M\(_y\) , M\(_z\) }，由于I\(^B\)是指向北方，因此I\(^B\) = M. 现在可以计算出J\(^B\) = K\(^B\) x I\(^B\)。 所以加速度计和磁力计就能单独的给出DCM矩阵： DCM\(^G\) = DCM\(^{BT}\) = [I\(^B\), J\(^B\), K\(^B\)]\(^T\) DCM矩阵能转换机体坐标系中的任意向量到地理坐标系中： r\(^G\) = DCM\(^G\) r\(^B\) 加速度计和磁力计都需要初始化校正和纠错。陀螺仪没有绝对的方向感，比如它不知道北方和顶部在哪里，但加速度计和磁力计知道，因此当我们知道t时刻的方向，矩阵形式表示为DCM(t)，那么我们可以用陀螺仪算出更精确的方向DCM(t+1)，所以这就是从带有噪音的加速度计或者有磁场干扰的磁力计估算出来的姿态。事实是我们可以利用陀螺仪、加速度计和磁力计融合来估算姿态。下面将介绍这种算法：地理坐标系表示的DCM矩阵如下： 该DCM矩阵的各行为I\(^B\), J\(^B\), K\(^B\)向量。我们会将重心放在K\(^B\)（由加速度计测定），I\(^B\)（由磁力计测定）上。 J\(^B\)可以由J\(^B\) = K\(^B\) x I\(^B\)计算出来。 假设机体坐标的顶部向量在t\(_0\)时刻表示为K\(^B\)\(_0\)，陀螺仪的输出为 w = {w\(_x\) , w\(_y\) , w\(_z\) }，一段时间后，该顶部向量表示为K\(^B\)\(_1G\) K\(^B\)\(_1G\) ≈ K\(^B\)\(_0\) + dt v = K\(^B\)\(_0\) + dt (w\(_g\) x K\(^B\)\(_0\)) = K\(^B\)\(_0\) + ( dθ\(_g\) x K\(^B\)\(_0\)) 其中dθ\(_g\) = w\(_g\)dt为三个轴角度的变化向量，这意味这在dt时间内K\(^B\)向量在3个轴改变的角度。w\(_g\)为陀螺仪测得的角速度。 程序如下： 123456789101112131415//---------------//dcmEst//---------------//gyro rate direction is usually specified (in datasheets) as the device's(body's) rotation //about a fixed earth's (global) frame, if we look from the perspective of device then//the global vectors (I,K,J) rotation direction will be the inversefloat w[3]; //gyro rates (angular velocity of a global vector in local coordinates)w[0] = -getGyroOutput(1); //rotation rate about accelerometer's X axis (GY output) in rad/msw[1] = -getGyroOutput(0); //rotation rate about accelerometer's Y axis (GX output) in rad/msw[2] = -getGyroOutput(2); //rotation rate about accelerometer's Z axis (GZ output) in rad/msfor(i=0;i&lt;3;i++)&#123; w[i] *= imu_interval_ms; //scale by elapsed time to get angle in radians //compute weighted average with the accelerometer correction vector w[i] = (w[i] + ACC_WEIGHT*wA[i] + MAG_WEIGHT*wM[i])/(1.0+ACC_WEIGHT+MAG_WEIGHT);&#125; 很显然，还可以通过另外的方式估算K\(^B\)。如加速度估算值K\(^B\)\(_{1A}\)，如下推理： w­\(_a\) = K\(^B\)\(_0\) x v\(_a\) / | K\(^B\)\(_0\)|2­ 这个在上面的角速度部分得到了证实。 其中 v\(_a\) = (K\(^B\)\(_{1A}\)­ – K\(^B\)\(_0\)) / dt，v\(_a\)为K\(^B\)\(_0\)的线速度，且| K\(^B\)\(_0\)|\(^2\)­­ = 1 ，故可以这么计算： dθ\(_a\) ­= dt w\(_a\) = K\(^B\)\(_0\) x (K\(^B\)\(_{1A}­\) – K\(^B\)\(_0\)) = K\(^B\)\(_0\) x K\(^B\)\(_{1A}­\) – K\(^B\)\(_0\) x K\(^B\)\(_0\) = K\(^B\)\(_0\) x K\(^B\)\(_{1A}­\) - 0 = K\(^B\)\(_0\) x K\(^B\)\(_{1A}­\) 程序如下： 123456789101112131415//---------------//Acelerometer//---------------//Accelerometer measures gravity vector G in body coordinate system//Gravity vector is the reverse of K unity vector of global system expressed in local coordinates//K vector coincides with the z coordinate of body's i,j,k vectors expressed in global coordinates (K.i , K.j, K.k) //Acc can estimate global K vector(zenith) measured in body's coordinate systems (the reverse of gravitation vector)Kacc[0] = -getAcclOutput(0); Kacc[1] = -getAcclOutput(1);Kacc[2] = -getAcclOutput(2);vector3d_normalize(Kacc);//calculate correction vector to bring dcmEst's K vector closer to Acc vector (K vector according to accelerometer)float wA[3]; vector3d_cross(dcmEst[2],Kacc,wA); // wA = Kgyro x Kacc , rotation needed to bring Kacc to Kgyro 可以通过融合K\(^B\)\(_{1A}\) 和K\(^B\)\(_{1G}\) 计算新的估算值K\(^B\)1 ，首先通过求dθa和dθg的加权平均来求dθ： dθ = (s\(_a\) dθ\(_a\) + s\(_g\) dθ\(_g\)) / (s\(_a\) + s\(_g\)­) 为什么要求dθ，因为可以同时求得： K\(^B\)\(_1\) ≈ K\(^B\)\(_0\) + ( dθ x K\(^B\)\(_0\)) I\(^B\)\(_1\) ≈ I\(^B\)\(_0\) + ( dθ x I\(^B\)\(_0\)) J\(^B\)\(_1\) ≈ J\(^B\)\(_0\) + ( dθ x J\(^B\)\(_0\)) 由于I\(^B\), J\(^B\), K\(^B\)是相互联系的，所以跟踪相同的dθ。 到目前为止，我们都没有提及磁力计，一个原因是6DOF的IMU是没有磁力计的，这样也可以使用，只是航向会产生飘移，因此我们可以使用一个虚拟的磁力计，代码中会有体现的。磁力计与加速度计相似： dθ\(_m\) ­= dt w\(_m\) = I\(^B\)\(_0\) x (I\(^B\)\(_{1M}­\) – I\(^B\)\(_0\)) 算入加权平均为： dθ = (s\(_a\) dθ\(_a\) + s\(_g\) dθ\(_g\) + s\(_m\) dθ\(_m\)) / (s\(_a\) + s\(_g\) +­ s\(_m\)) 更新DCM矩阵： I\(^B\)\(_1\) ≈ I\(^B\)\(_0\) + ( dθ x I\(^B\)\(_0\)) , K\(^B\)\(_1\) ≈ K\(^B\)\(_0\) + ( dθ x K\(^B\)\(_0\)) 和 J\(^B\)\(_1\) ≈ J\(^B\)\(_0\) + ( dθ x J\(^B\)\(_0\)) 下面通过计算J\(^B\)\(_1\) = K\(^B\)\(_1\) x I\(^B\)\(_1\)，判断估算后的值K\(^B\)\(_1\)是否垂直I\(^B\)\(_1\)。 了确保估算后的值是否还是正交的，如下图，假设向量a，b是几乎垂直的，但不是90°，我们可以找到一个向量b’ 与a垂直，这个b’向量可以通过求 c = a x b，再求 b’ = c x a 得到，可以看出b’是正交于a和c的，因此b’是校正后的向量。 利用向量的三重积公式展开，且a.a = |a| = 1： b’ = c x a = (a x b) x a = –a (a.b) + b(a.a) = b – a (a.b) = b + d，其中d = – a (a.b)是校正量，平行于a，方向取决于a和b的夹角。 上面的情况是a向量固定，b向量得到校正，下面分析对称的情况，a得到校正，b固定： a’ = a – b (b.a) = a – b (a.b) = a + e，其中e = – b (a.b) 再下面考虑这两个向量都有误差，都得到一半的校正得： a’ = a – b (a.b) / 2 b’ = b – a (a.b) / 2 所以得到一个相对简单的公式： Err = (a.b)/2 a’ = a – Err b b’ = b – Err a 现在我们可以更新DCM矩阵的 IB1, JB1向量。 Err = ( I\(^B\)\(_1\) . J\(^B\)\(_1\) ) / 2 I\(^B\)\(_1\)’ = I\(^B\)\(_1\) – Err J\(^B\)\(_1\) J\(^B\)\(_1\)’ = J\(^B\)\(_1\) – Err I\(^B\)\(_1\) I\(^B\)\(_1\)’’ = Normalize[I\(^B\)\(_1\)’] J\(^B\)\(_1\)’’ = Normalize[J\(^B\)\(_1\)’] K\(^B\)\(_1\)’’ = I\(^B\)\(_1\)’’ x J\(^B\)\(_1\)’’ 其中Normalize[a] = a / |a|，单位化。 代码如下： 1234567891011121314151617//bring dcm matrix in order - adjust values to make orthonormal (or at least closer to orthonormal)void dcm_orthonormalize(float dcm[3][3])&#123; //err = X . Y , X = X - err/2 * Y , Y = Y - err/2 * X (DCMDraft2 Eqn.19) float err = vector3d_dot((float*)(dcm[0]),(float*)(dcm[1])); float delta[2][3]; vector3d_scale(-err/2,(float*)(dcm[1]),(float*)(delta[0])); vector3d_scale(-err/2,(float*)(dcm[0]),(float*)(delta[1])); vector3d_add((float*)(dcm[0]),(float*)(delta[0]),(float*)(dcm[0])); vector3d_add((float*)(dcm[1]),(float*)(delta[1]),(float*)(dcm[1])); //Z = X x Y (DCMDraft2 Eqn. 20) , vector3d_cross((float*)(dcm[0]),(float*)(dcm[1]),(float*)(dcm[2])); //re-nomralization vector3d_normalize((float*)(dcm[0])); vector3d_normalize((float*)(dcm[1])); vector3d_normalize((float*)(dcm[2]));&#125; DCM理论 注意：这部分属于APM源码里px4姿态解算部分。资料翻译解读自DMCDraft2.pdf（翻译不妥请谅解，欢迎提意见，另外该理论文档已启动翻译，如果你想参与请点击这里），并结合文档分析了APM的姿态源码部分，目前还有drift_correction函数未进行整理！ 前言 使用矩阵来控制和导航，元素包括陀螺仪，加速度计和gps信息。 总的来说，DCM工作如下： 陀螺仪作为主要的方向信息来源，通过整合一个非线性微分运动方程，表明飞机方向的变化率与旋转速率及它当前的方向之间的关系。 意识到积分过程中的积分误差将渐渐的违反DCM必须满足的正交约束，我们对矩阵的元素进行规则的小调整满足约束。 由于数字误差，陀螺仪漂移，陀螺仪偏移量将逐渐积累在DCM中的元素的误差，我们使用参考向量来检测误差，以及在检测到的误差和和第一步的陀螺仪输入中加一个比例积分负反馈控制器来在建立之前消除误差。gps是用来检测偏航误差，加速度计被用来检测俯仰和滚动。整个过程如下： 代码实现概览： 12345678// Integrate the DCM matrix using gyro inputsmatrix_update(delta_t);// Normalize the DCM matrixnormalize();// Perform drift correctiondrift_correction(delta_t); 方向余弦矩阵介绍 所有这一切都与旋转有关。 有几种方法可以做到，比如旋转矩阵和四元数。这两种方法在实现上具有相似的地方，都是尽量准确的表示旋转。四元数只需要4个值，而旋转矩阵需要9个，在这方面四元数具有优势。而旋转矩阵很适合用来导航和控制。 旋转矩阵用来描述一个坐标系相对于另一个坐标系的方向。在一个系统中的向量可以通过乘以旋转矩阵转变到另一个系统中，如果是相反方向旋转则乘以旋转矩阵的逆矩阵，也是它的转置（交换行和列）。单位向量在控制和导航运算中将非常有用，因为它们的长度为1。因此他们能被用于交积和叉积中来获得各种正弦或余弦角。 随着飞机的飞行，我们可以用位置（重心的移动）和朝向（绕着重心方向的变化）了描述它的运动，类似这种变换我们称为刚体变换。通过指定一个轴的旋转来描述其相对于地球的方向。例如将飞机开始放在一个标准方向，然后将其旋转，它将指向另外一个实际的方向，也就是说任何其他的方向都可以通过标准方向的旋转描述。旋转组是所有可能的旋转的组。它被称为一组，因为在该组中的任何2个旋转可以组成一个组中的另一个旋转，每一个旋转有一个逆旋转。这里有一个单位旋转。旋转组应该得到重视的原因是，你能通过最少的近似来在各个方向控制和导航飞机，包括各种特技。基本的想法是，定义了你的飞机的方向的旋转矩阵，可以通过结合描述旋转运动学的非线性微分方程得到。这个结合可以通过一系列的旋转组合完成，也就是两矩阵相乘，这是两个矩阵依次执行的结果。然而，数值积分引入的数值误差，并不会产生与符号积分相同的结果。精确的陀螺仪信号的符号积分将产生完全正确的旋转矩阵。数值积分，即使我们有精确的陀螺仪信号，也会引入2种数值误差： 积分误差。数值积分采用有限时间步长和在有限采样速率下采样数据。因为是假定在时间步长内旋转速度是恒定的，这将引入了一个与旋转加速度成比例的误差。 量化误差。不管你用什么代表值，数字表示是有限的，所以有一个量化误差，从模数转换开始，以及所有计算没有保留结果所有位时。 旋转矩阵的一个关键特性是它的正交性，这意味着如果2个向量在一个参照系中是垂直的，它们在每一个参照系中都是垂直的。另外，在每一个参照系中向量的长度是一样的。数值误差可能违反此特性。在许多空间系统中,利用方向余弦矩阵把矢量从一个笛卡尔坐标系变换到另一个笛卡尔坐标系。理想的方向余弦矩阵应当是正交的,而实际上,通过计算得到的矩阵由于种种误差(如计算方法误差、舍入误差等)而失去了正交性,造成变换误差,影响系统精度。于是有必要按某种最优方式,恢复其正交性。矩阵正交化的迭代法有多种,但都计算较繁、运算量大。对于需要把计算得到的方向余弦矩阵周期性地正交化的场合(如捷联式惯导系统),大的运算量将给计算机实时计算带来困难。例如，即使行和列都应该代表单位向量，它们的大小应该等于1，但数值误差可能导致它们变得更小或更大。最终他们可以缩小到零，或去无限。行和列应该是垂直于彼此，数值误差可能导致他们“倾斜”到对方，如下图所示： 旋转矩阵有9个元素。实际上，只有3个是独立的。旋转矩阵的正交特性在数学术语方面意味着矩阵的任何一对行或列都是垂直的。并且在每个列（或行）的元素的平方和等于1。所以这九个元素中有六个约束条件。 反对称矩阵定义是：A=-A’（A的转置前加负号），它的第Ⅰ行和第Ⅰ列各数绝对值相等，符号相反。且主对角线上的元素为均为零。一个小的旋转可以用如下的反对称矩阵来描述： 在我们的例子中，运动学与刚体旋转的含义有关。它的结果是一个非线性微分方程，描述了刚体在其向量旋转速度方面的时间演化。方向余弦矩阵都是关于运动学的。 控制和导航可以在笛卡尔坐标系使用DCM完成叉积和点积运算。下面是具体步骤： 要控制飞机的俯仰，你需要知道这架飞机的俯仰姿态，你可以通过把飞机的翻滚轴与地面垂直做点积。 要控制飞机的翻滚，你需要知道这架飞机的倾斜姿态，你可以通过把飞机的俯仰轴与地面垂直做点积。 要航向，你需要知道你这架飞机相对于你想要去的方向的偏航姿态，可以通过飞机的翻滚轴与想要去的方向的向量做叉积得到。如果是去相反的方向，则是点积运算。 判断飞机是否倒过来，可以通过判断飞机偏航轴与垂直的点积符号，如果小于0，则是朝下的。 计算飞机绕垂直轴的旋转速度，将陀螺仪的旋转矢量转换为地理参考坐标系，然后与垂直轴做点积。 下面将进行深入的理论研究。 确定一个合适的坐标系统描述飞机的运动是必要的。对于大多数处理飞机运动的问题，采用了双坐标系。一个坐标系是固定在地球上的，可以被认为是是一个惯性坐标系，是为了飞机运动分析的目的。另一个坐标系是固定在飞机上的，被称为机体坐标系。图2显示了两右手坐标系： 其中 xe、ye、ze 是地球坐标系统,ze 指向地心,xe 指向正东方,ye 指向正北方;xb、yb、zb 为机体坐标系。 飞机的方向经常被描述为三个连续的旋转，其顺序是重要的。旋转角被称为欧拉角。假设机体坐标如下： 进行如下的旋转就可以得到上面图2的结果： 分析：第一步:假设我站在机体坐标中,我需要通过先绕 Xb 轴旋转 \(\Phi\) ，再旋转 Yb 轴旋转 \(\theta\)，最后绕 Zb 轴旋转 \(\psi\)，回到地球坐标系;先求出每次旋转的矩阵。 如果绕机体 X 轴旋转的角度为 \(\Phi\)，那么 这里是怎么得来的呢？先说一下什么是旋转矩阵？如下图所示，我们假设最开始空间的坐标系也就是机体坐标系X\(_A\)，Y\(_A\)，Z\(_A\)就是笛卡尔坐标系，这样我们得到空间A的矩阵V\(_A\)={X\(_A\)，Y\(_A\)，Z\(_A\)}\(^T\)，其实也可以看做是单位阵E。进过旋转后，空间A的三个坐标系变成了图1中红色的三个坐标系X\(_B\)，Y\(_B\)，Z\(_B\)，得到空间B的矩阵V\(_B\)={X\(_B\)，Y\(_B\)，Z\(_B\)}\(^T\)。我们将两个空间联系起来可以得到V\(_B\)=R•V\(_A\)，这里R就是我们所说的旋转矩阵。 由于X\(_A\)={1,0,0}\(^T\)，Y\(_A\)={0,1,0}\(^T\)，Z\(_A\)={0,0,1}\(^T\)，结合下图可以看出，旋转矩阵R就是由X\(_B\)，Y\(_B\)，Z\(_B\) 三个向量组成的。讲到这里，大家应该会发现旋转矩阵R满足第一个条件，因为单位向量无论怎么旋转长度肯定不会变而且向量之间的正交性质也不会变。那么旋转矩阵就是正交阵！不过这还不能说明问题，下面我更进一步利用数学公式进行证明。 进一步讨论之前，我们先说两点数学知识。（1）点乘（dot product）的几何意义：如下图，我们从点乘的公式可以得到α•β相当于β的模乘上α在β上投影的模，所以当|β|=1时，α•β就是指α在β上投影的模。这一点在下面的内容中非常重要，之所以叫余弦矩阵的原因就是这个。（2）旋转矩阵逆的几何意思：这个比较抽象，不过也好理解。旋转矩阵相当于把一个向量（空间）旋转成新的向量（空间），那么逆可以理解为由新的向量（空间）转回原来的向量（空间）。（3）向量是特殊的矩阵，只有一行或一列的矩阵称为向量。向量有叉乘和点乘。矩阵也有，但意义不一样，矩阵还有反对称，逆矩阵等。 所以上面的公式解析如下： 同理，其他方向的旋转计算如下： 如果绕机体 Y 轴旋转的角度为 \(\theta\)，那么 如果绕机体 Z 轴旋转的角度为 \(\psi\)，那么 第二步:由于站在机体坐标上需要按照 X-&gt;Y-&gt;Z 轴的顺序,经过 3 次旋转,才能回到地球坐标系;反过来如果站在地球坐标系,则需要经过 Z-&gt;Y-&gt;X 的三次旋转才能到达机体坐标系。因此我们可以列出从地球坐标系到机体坐标系的DCM矩阵，换句话说此DCM矩阵就是机体坐标在地理坐标系中的表示，其中\(\Phi, \theta, \psi\)为机体在地理坐标系中的姿态角。 $$L(\Phi, \theta, \psi) = L(\psi) L(\theta) L(\Phi);$$ 矩阵的乘法计算得： 方向余弦矩阵：向量的某些类型，如方向，速度，加速度，和转换，（动作）可以转化为旋转参考系中的一个3x3的矩阵。我们感兴趣的是机体参考系和地面参考系。它可以乘以一个向量的方向余弦矩阵旋转： 由上面的分析可知，方向余弦矩阵与欧拉角之间的关系为： 方程1方程2表明了如何将机体坐标系中测得的向量转换的地理坐标系中。方程1是以方向余弦角的形式，而2为欧拉角。 以上整个求解过程是对 matrix3.cpp 代码中 from_euler 函数的解析： 12345678910111213141516171819202122// create a rotation matrix given some euler angles// this is based on http://gentlenav.googlecode.com/files/EulerAngles.pdftemplate &lt;typename T&gt;void Matrix3&lt;T&gt;::from_euler(float roll, float pitch, float yaw)&#123; float cp = cosf(pitch);//pitch 表示俯仰相对于地球坐标系的角度值 float sp = sinf(pitch); float sr = sinf(roll);//roll 表示横滚相对于地球坐标系的角度值 float cr = cosf(roll); float sy = sinf(yaw);//yaw 表示偏航相对于地球坐标的角度值 float cy = cosf(yaw); a.x = cp * cy; a.y = (sr * sp * cy) - (cr * sy); a.z = (cr * sp * cy) + (sr * sy); b.x = cp * sy; b.y = (sr * sp * sy) + (cr * cy); b.z = (cr * sp * sy) - (sr * cy); c.x = -sp; c.y = sr * cp; c.z = cr * cp;&#125; 其中a，b，c为类定义的私有变量—向量。 通过不同的旋转顺序可以得到不同的旋转矩阵，如果从地球坐标系到体坐标系,按照 Z-&gt;X-&gt;Y 轴的顺序旋转可以得到from_euler312函数，这里就没做具体讲解。 问题：反过来也就可以通过方向余弦矩阵来求出旋转角 函数 to_euler 式通过上面的 3 个公式求出对应的角度的 123456789101112131415// calculate euler angles from a rotation matrix// this is based on http://gentlenav.googlecode.com/files/EulerAngles.pdftemplate &lt;typename T&gt;void Matrix3&lt;T&gt;::to_euler(float *roll, float *pitch, float *yaw) const&#123; if (pitch != NULL) &#123; *pitch = -safe_asin(c.x); &#125; if (roll != NULL) &#123; *roll = atan2f(c.y, c.z); &#125; if (yaw != NULL) &#123; *yaw = atan2f(b.x, a.x); &#125;&#125; 地理坐标系中向量的每个分量等于相对应的旋转矩阵的行与机体坐标向量的点积。计算旋转矩阵需要9个乘法和6个加法运算。方程3是方程1的复述，用乘法展开向量和矩阵的元素。所以如果知道机体坐标向量，即可得地理坐标向量的大小： 需要注意的是，矩阵R不一定是对称的。R矩阵的三列对应于机体坐标的三个轴向量到地理坐标的变换。R矩阵的三行则对应于地理坐标三个轴向量到机体坐标的变换。该R矩阵描述了所有机体相对于地球方向的信息。R矩阵也称为方向余弦矩阵，因为每个分量都是机体坐标轴与地理坐标轴夹角的余弦，通过看推理余弦矩阵部分可以看出来。 矩阵的转置，特别在旋转矩阵中，表示为\(R^T\)，通过交换行和列得到。一般来说，一个方形矩阵的逆矩阵如果存在的话，表示为\(R^{−1}\)。矩阵的逆乘以矩阵得到的是单位矩阵。（单位矩阵就是对角线上元素为1,其余为0,单位矩阵乘以任何矩阵得到它本身），对于旋转矩阵来说，逆就等于它的转置。 之所以旋转矩阵逆就等于它的转置考虑到了对称性的情况。旋转矩阵的元素都是机体轴与地理坐标轴之间的余弦值，相反的情况就相当于交换地理坐标和机体坐标的角色，也就是说交换行与列，这跟转置是一样的。实际上这又和正交条件达成一致： 正交矩阵每一列都是单位矩阵，并且两两正交。最简单的正交矩阵就是单位阵。 正交矩阵的逆（inverse）等于正交矩阵的转置（transpose）。同时可以推论出正交矩阵的行列式的值肯定为正负1的。 正交矩阵满足很多矩阵性质，比如可以相似于对角矩阵等等。 如下： 这个方程用来证明矩阵的逆的矩阵的转置。 旋转矩阵的一个非常有用的特性是，我们可以组成旋转。 这里特别需要小心运算顺序，因为它的效果是完全不一样的。 另外这里还有一些有用的特性，如： 下面介绍一下点乘和叉乘。 这里有两个DCM计算里边用到的向量运算——点乘和叉乘。点乘是表量运算，A向量作为行向量，B向量作为列向量。 可以证明向量的点乘等于两个向量的长度乘以它们角度的余弦值。 所以向量的点乘是对称的。A \(\cdot\) B = B \(\cdot\) A 而两个向量的叉乘是一个向量。它的元素是这样计算的： 从物理意义上来分析： 所以叉乘是反对称的，A \(\times\) B = - B \(\times\) A 方向余弦矩阵的更新 下面到了DCM算法的核心部分——由陀螺仪计算方向余弦矩阵。 核心概念：非线性微分方程——方向余弦的变化速率与陀螺仪之间的关系。我们的目标是计算方向余弦而不是任何违反方程非线性的近似解。目前，我们假设陀螺仪信号没有错误。稍后我们将解决陀螺仪漂移问题。不像机械陀螺，我们不能通过简单地积分陀螺仪信号得到角度。一个有名的运动学公式，关于旋转向量的变化率和它的旋转之间的关系： 下面解释一下这个公式，如下图所示，r为任意的旋转向量，t时刻的坐标为r(t)。时间间隔dt后：r = r (t) , r’= r (t+dt) and dr = r’ – r。 dt时间后向量r绕着与单位向量u同向的轴旋转了d\(\theta\)，停到了向量r’的位置。其中u垂直与旋转的机身，因此u正交于r与r’，图中显示了u与u’，它们与r和r‘的叉乘结果方向相同。故有 u = (r x r’) / |r x r’| = (r x r’) / (|r|| r’|sin(dθ)) = (r x r’) / (|r|2 sin(dθ)) 由于旋转并不改变向量的长度，因此有| r’| = |r|。 向量r的线速度可以表示如下： v = dr / dt = ( r’ – r) / dt v = w x r 故可以得出上面的公式。 有一个需要注意的地方： 微分方程是非线性的。旋转向量输入是与我们要进行积分的变量进行叉乘。因此，任何线性的方法都只是一种近似。 两个向量都应该在同一个坐标系中测量。 因为叉乘是不对称的，所以我们需要保存结果，然后改变它的方向。 如果知道了初始状态和旋转向量的时间，我们可以通过方程11的数值积分来跟踪旋转向量。 将方程13用于R矩阵的行或列中，可看作成旋转向量。 这里遇到的第一个问题是，我们要跟踪的向量和旋转向量不是在同一坐标系做测量的。理想情况下，我们都是在地理坐标轴中跟踪机体坐标轴，但是陀螺仪是在机体坐标中测量的。一个简单的方法是通过对称性解决，地理坐标在机体坐标中旋转和机体坐标在地理坐标中旋转是相反的，所以只要改变陀螺仪的符号就好了，更加方便的方法是，交换叉乘的顺序就好了。 这里的向量代表的是方程1中R矩阵的行。下面的问题是怎么实施方程14，回归到方程14的微分方程形式： 由这里可知方向余弦矩阵R的行都是通过\(r_{earth}(t) \times d\theta(t)\)积分得到的。 所以根据陀螺仪的角度值,来计算当前机体的姿态 DCM矩阵，其使用的方法是：机体坐标的每个轴的向量与 g(陀螺仪改变的角度向量)求叉积，这里求的是角度改变后,姿态在各个方向上的变化量，所以最后使用了矩阵的加法。源码matrix3.cpp中的函数体现如下： 123456789101112131415161718// apply an additional rotation from a body frame gyro vector// to a rotation matrix.template &lt;typename T&gt;void Matrix3&lt;T&gt;::rotate(const Vector3&lt;T&gt; &amp;g)&#123; Matrix3&lt;T&gt; temp_matrix; temp_matrix.a.x = a.y * g.z - a.z * g.y; temp_matrix.a.y = a.z * g.x - a.x * g.z; temp_matrix.a.z = a.x * g.y - a.y * g.x; temp_matrix.b.x = b.y * g.z - b.z * g.y; temp_matrix.b.y = b.z * g.x - b.x * g.z; temp_matrix.b.z = b.x * g.y - b.y * g.x; temp_matrix.c.x = c.y * g.z - c.z * g.y; temp_matrix.c.y = c.z * g.x - c.x * g.z; temp_matrix.c.z = c.x * g.y - c.y * g.x; (*this) += temp_matrix;&#125; 还有一件事需要做，陀螺仪漂移将在后面进行。我们需要通过比例积分补偿反馈控制器来添加旋转速率校准到陀螺仪测量的数据上，以此产生最优的角速率估计。 基本上，我们的GPS和加速度计的参考向量被用来计算旋转误差，并通过反馈控制器输入计算，然后更新原有计算。 我们可以把方程15转化为矩阵的形式，这里推导有点复杂，可以了解下矢量阵或者summer的文章，如下： 方程17就是从陀螺仪信号更新方向余弦矩阵，其对角线上的1就为方程15的第一个条目，其余的为第二个条目，这种方法是用矩阵的乘法实现的，它包含27个乘法和18个加法。正好适合dsPIC30F4011，因为它支持矩阵乘法运算，如果芯片不支持，也可以用方程15的积分形式实现。故在apm里采用的是积分形式累加的。矩阵更新的源码体现如下： 1234567891011121314151617181920212223242526272829303132333435// update the DCM matrix using only the gyrosvoidAP_AHRS_DCM::matrix_update(float _G_Dt)&#123; // note that we do not include the P terms in _omega. This is // because the spin_rate is calculated from _omega.length(), // and including the P terms would give positive feedback into // the _P_gain() calculation, which can lead to a very large P // value _omega.zero(); // average across first two healthy gyros. This reduces noise on // systems with more than one gyro. We don't use the 3rd gyro // unless another is unhealthy as 3rd gyro on PH2 has a lot more // noise uint8_t healthy_count = 0; Vector3f delta_angle; for (uint8_t i=0; i&lt;_ins.get_gyro_count(); i++) &#123; if (_ins.get_gyro_health(i) &amp;&amp; healthy_count &lt; 2) &#123; Vector3f dangle; if (_ins.get_delta_angle(i, dangle)) &#123; healthy_count++; delta_angle += dangle; &#125; &#125; &#125; if (healthy_count &gt; 1) &#123; delta_angle /= healthy_count; //获取角度变化量 &#125; if (_G_Dt &gt; 0) &#123; _omega = delta_angle / _G_Dt; _omega += _omega_I; _dcm_matrix.rotate((_omega + _omega_P + _omega_yaw_P) * _G_Dt); //将角度变化量与旋转向量进行叉乘，然后累加 &#125;&#125; 再归一化重整 由于上述的公式是在dt非常小的情况下才误差比较小，这种数字误差将驱使方程4的正交条件逐渐不满足，导致坐标系的两个轴不再能描述刚体。值得幸运的是，数字误差累加的很慢，我们完全可以提前采取办法解决它。我们将这种解决办法称为归一化，我们设计了几种方法，模拟实现都可行，最后选择了一种最优的方法。 首先计算矩阵列向量X、Y的点乘，理论上应该等于0，所以它的结果可以看出向量偏了多少。 将这个误差平分到X、Y向量： 可以将方程19代人方程18中，验证正交性误差大大减少了。记住R矩阵的行与列的范数为1，将误差平分给两个轴比只分个一个产生较低的残余误差。 下一步就是调整Z列向量正交于X和Y。这个很简单，只要进行叉乘就可以了： 最后一步为，确保R矩阵的各列向量的模为1，一种方法可以通过平方根来求，但是这里有一种更加简单的办法，考虑到这个模不会与1有太大差别，这里可以使用泰勒展开。 方程21做的事情就是调整各列向量的模为1。展开为3减去向量模的平方，乘以1/2，再乘以这个向量。所以计算更加简单。 源码实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/************************************************* - Direction Cosine Matrix IMU: Theory - William Premerlani and Paul Bizard * - Numerical errors will gradually reduce the orthogonality conditions expressed by equation 5 - to approximations rather than identities. In effect, the axes in the two frames of reference no - longer describe a rigid body. Fortunately, numerical error accumulates very slowly, so it is a - simple matter to stay ahead of it. - We call the process of enforcing the orthogonality conditions ÒrenormalizationÓ. */voidAP_AHRS_DCM::normalize(void)&#123; float error; Vector3f t0, t1, t2; error = _dcm_matrix.a * _dcm_matrix.b; // eq.18 t0 = _dcm_matrix.a - (_dcm_matrix.b * (0.5f * error)); // eq.19 t1 = _dcm_matrix.b - (_dcm_matrix.a * (0.5f * error)); // eq.19 t2 = t0 % t1; // c= a x b // eq.20 if (!renorm(t0, _dcm_matrix.a) || !renorm(t1, _dcm_matrix.b) || !renorm(t2, _dcm_matrix.c)) &#123; // Our solution is blowing up and we will force back // to last euler angles _last_failure_ms = AP_HAL::millis(); AP_AHRS_DCM::reset(true); &#125;&#125;// renormalise one vector component of the DCM matrix// this will return false if renormalization failsboolAP_AHRS_DCM::renorm(Vector3f const &amp;a, Vector3f &amp;result)&#123; float renorm_val; // numerical errors will slowly build up over time in DCM, // causing inaccuracies. We can keep ahead of those errors // using the renormalization technique from the DCM IMU paper // (see equations 18 to 21). // For APM we don't bother with the taylor expansion // optimisation from the paper as on our 2560 CPU the cost of // the sqrt() is 44 microseconds, and the small time saving of // the taylor expansion is not worth the potential of // additional error buildup. // Note that we can get significant renormalisation values // when we have a larger delta_t due to a glitch eleswhere in // APM, such as a I2c timeout or a set of EEPROM writes. While // we would like to avoid these if possible, if it does happen // we don't want to compound the error by making DCM less // accurate. renorm_val = 1.0f / a.length(); //这里并没有使用泰勒展开，考虑的节省的时间不多 // keep the average for reporting _renorm_val_sum += renorm_val; _renorm_val_count++; if (!(renorm_val &lt; 2.0f &amp;&amp; renorm_val &gt; 0.5f)) &#123; // this is larger than it should get - log it as a warning if (!(renorm_val &lt; 1.0e6f &amp;&amp; renorm_val &gt; 1.0e-6f)) &#123; // we are getting values which are way out of // range, we will reset the matrix and hope we // can recover our attitude using drift // correction before we hit the ground! //Serial.printf("ERROR: DCM renormalisation error. renorm_val=%f\n", // renorm_val); return false; &#125; &#125; result = a * renorm_val; return true;&#125; EKF设计与实现资料搜集 pixhawk ekf Matlab仿真EKF Learning the Extended Kalman Filter An application of the extended Kalman filter to the attitude control of a quadrotor UAV Linear and Nonlinear Estimation Using Extended Kalman Filter/pdf Performance analysis of a Kalman Filter based attitude estimator for a Quad Rotor UAV/pdf Stabilization and Altitude Control of an Indoor Low-Cost Quadrotor: Design and Experimental Results/pdf APM的EKF源码流分析：ArduCopter.cpp里fast_loop函数里的姿态更新部分如下： 123456789void AP_AHRS_NavEKF::update(void)&#123; update_DCM(); update_EKF1(); update_EKF2();#if CONFIG_HAL_BOARD == HAL_BOARD_SITL update_SITL();#endif&#125; 这里看出姿态估算使用了DCM和EKF算法，而EKF由分为两种，第一种为默认推荐的稳定版代码飞行的，第二种为git上master的，是另外一种形式的升级版EKF，这种EKF可以通过一个移动的平台起飞。下面以master版本分析，具体解释如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061void AP_AHRS_NavEKF::update_EKF2(void) //master版（即开发版）实验表明，最后是由这个函数生成的姿态角&#123; if (!ekf2_started) &#123; // wait 1 second for DCM to output a valid tilt error estimate if (start_time_ms == 0) &#123; start_time_ms = AP_HAL::millis(); &#125; if (AP_HAL::millis() - start_time_ms &gt; startup_delay_ms) &#123; ekf2_started = EKF2.InitialiseFilter(); //使用了DCM的_error_rp = 0.8f * _error_rp + 0.2f * best_error;，来源drift_correction，所以EKF依赖于DCM &#125; &#125; if (ekf2_started) &#123; EKF2.UpdateFilter(); if (active_EKF_type() == EKF_TYPE2) &#123; Vector3f eulers; EKF2.getRotationBodyToNED(_dcm_matrix); ////这里的矩阵重新赋值了DCM矩阵，即姿态 EKF2.getEulerAngles(-1,eulers); roll = eulers.x; //生成roll pitch = eulers.y; yaw = eulers.z; update_cd_values(); //生成roll_sensor update_trig(); //生成_cos_roll // keep _gyro_bias for get_gyro_drift() EKF2.getGyroBias(-1,_gyro_bias); _gyro_bias = -_gyro_bias; // calculate corrected gryo estimate for get_gyro() _gyro_estimate.zero(); uint8_t healthy_count = 0; for (uint8_t i=0; i&lt;_ins.get_gyro_count(); i++) &#123; if (_ins.get_gyro_health(i) &amp;&amp; healthy_count &lt; 2) &#123; _gyro_estimate += _ins.get_gyro(i); healthy_count++; &#125; &#125; if (healthy_count &gt; 1) &#123; _gyro_estimate /= healthy_count; &#125; _gyro_estimate += _gyro_bias; float abias; EKF2.getAccelZBias(-1,abias); // This EKF uses the primary IMU // Eventually we will run a separate instance of the EKF for each IMU and do the selection and blending of EKF outputs upstream // update _accel_ef_ekf for (uint8_t i=0; i&lt;_ins.get_accel_count(); i++) &#123; Vector3f accel = _ins.get_accel(i); if (i==_ins.get_primary_accel()) &#123; accel.z -= abias; &#125; if (_ins.get_accel_health(i)) &#123; _accel_ef_ekf[i] = _dcm_matrix * accel; &#125; &#125; _accel_ef_ekf_blended = _accel_ef_ekf[_ins.get_primary_accel()]; &#125; &#125;&#125; 概要：在这个函数里有一个active_EKF_type()函数，通过分析可知它的值为EKF_TYPE2，故使用的是EKF2算法。具体分析如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121AP_AHRS_NavEKF::EKF_TYPE AP_AHRS_NavEKF::active_EKF_type(void) const&#123; EKF_TYPE ret = EKF_TYPE_NONE;/* enum EKF_TYPE &#123;EKF_TYPE_NONE=0, EKF_TYPE1=1, EKF_TYPE2=2#if CONFIG_HAL_BOARD == HAL_BOARD_SITL ,EKF_TYPE_SITL=10#endif &#125;;*/ switch (ekf_type()) &#123; case 0: return EKF_TYPE_NONE; case 1: &#123; // do we have an EKF yet? if (!ekf1_started) &#123; return EKF_TYPE_NONE; &#125; if (always_use_EKF()) &#123;/* bool always_use_EKF() const &#123; return _ekf_flags &amp; FLAG_ALWAYS_USE_EKF; //下面分析这两个数据,结果为0 &#125;// constructorAP_AHRS_NavEKF::AP_AHRS_NavEKF(AP_InertialSensor &amp;ins, AP_Baro &amp;baro, AP_GPS &amp;gps, RangeFinder &amp;rng, NavEKF &amp;_EKF1, NavEKF2 &amp;_EKF2, Flags flags) : AP_AHRS_DCM(ins, baro, gps), EKF1(_EKF1), EKF2(_EKF2), _ekf_flags(flags)&#123; _dcm_matrix.identity();&#125;enum Flags &#123; FLAG_NONE = 0, FLAG_ALWAYS_USE_EKF = 0x1, //FLAG_ALWAYS_USE_EKF = 0x1 &#125;; // Constructor AP_AHRS_NavEKF(AP_InertialSensor &amp;ins, AP_Baro &amp;baro, AP_GPS &amp;gps, RangeFinder &amp;rng, NavEKF &amp;_EKF1, NavEKF2 &amp;_EKF2, Flags flags = FLAG_NONE); //所以_ekf_flags = FLAG_NONE = 0*/ uint8_t ekf_faults; EKF1.getFilterFaults(ekf_faults); if (ekf_faults == 0) &#123; ret = EKF_TYPE1; &#125; &#125; else if (EKF1.healthy()) &#123; ret = EKF_TYPE1; &#125; break; &#125; case 2: &#123; //由下面的函数分析可知，应该会跳到这里 // do we have an EKF2 yet? if (!ekf2_started) &#123; return EKF_TYPE_NONE; &#125; if (always_use_EKF()) &#123; uint8_t ekf2_faults; EKF2.getFilterFaults(-1,ekf2_faults); if (ekf2_faults == 0) &#123; ret = EKF_TYPE2; &#125; &#125; else if (EKF2.healthy()) &#123; ret = EKF_TYPE2; //最终的返回结果 &#125; break; &#125;#if CONFIG_HAL_BOARD == HAL_BOARD_SITL case EKF_TYPE_SITL: ret = EKF_TYPE_SITL; break;#endif &#125; /* fixed wing and rover when in fly_forward mode will fall back to DCM if the EKF doesn't have GPS. This is the safest option as DCM is very robust */ if (ret != EKF_TYPE_NONE &amp;&amp; (_vehicle_class == AHRS_VEHICLE_FIXED_WING || _vehicle_class == AHRS_VEHICLE_GROUND) &amp;&amp; _flags.fly_forward) &#123; nav_filter_status filt_state; if (ret == EKF_TYPE1) &#123; EKF1.getFilterStatus(filt_state);#if CONFIG_HAL_BOARD == HAL_BOARD_SITL &#125; else if (ret == EKF_TYPE_SITL) &#123; get_filter_status(filt_state);#endif &#125; else &#123; EKF2.getFilterStatus(-1,filt_state); &#125; if (hal.util-&gt;get_soft_armed() &amp;&amp; !filt_state.flags.using_gps &amp;&amp; _gps.status() &gt;= AP_GPS::GPS_OK_FIX_3D) &#123; // if the EKF is not fusing GPS and we have a 3D lock, then // plane and rover would prefer to use the GPS position from // DCM. This is a safety net while some issues with the EKF // get sorted out return EKF_TYPE_NONE; &#125; if (hal.util-&gt;get_soft_armed() &amp;&amp; filt_state.flags.const_pos_mode) &#123; return EKF_TYPE_NONE; &#125; if (!filt_state.flags.attitude || !filt_state.flags.horiz_vel || !filt_state.flags.vert_vel || !filt_state.flags.horiz_pos_abs || !filt_state.flags.vert_pos) &#123; return EKF_TYPE_NONE; &#125; &#125; return ret;&#125; 其中又涉及到了ekf_type函数，可知返回值为2： 12345678910111213141516171819202122232425//canonicalise _ekf_type, forcing it to be 0, 1 or 2uint8_t AP_AHRS_NavEKF::ekf_type(void) const&#123; uint8_t type = _ekf_type; //由下面的分析，默认_ekf_type的值为2 if (always_use_EKF() &amp;&amp; type == 0) &#123; //如果总是使用EKF且默认type为0时，那么type就强制为1 type = 1; &#125;// bool always_use_EKF() const &#123;// return _ekf_flags &amp; FLAG_ALWAYS_USE_EKF; //位运算，结果为0// &#125; // check for invalid type#if CONFIG_HAL_BOARD == HAL_BOARD_SITL if (type &gt; 2 &amp;&amp; type != EKF_TYPE_SITL) &#123; //检查type是否有效，只有为SIL的时候才能大于2 type = 1; &#125;#else if (type &gt; 2) &#123; type = 1; &#125;#endif return type;&#125; _ekf_type的默认取值分析。 12345678#if AP_AHRS_NAVEKF_AVAILABLE //_ekf_type的默认取值为2 // @Param: EKF_TYPE // @DisplayName: Use NavEKF Kalman filter for attitude and position estimation // @Description: This controls whether the NavEKF Kalman filter is used for attitude and position estimation and whether fallback to the DCM algorithm is allowed. Note that on copters "disabled" is not available, and will be the same as "enabled - no fallback" // @Values: 0:Disabled,1:Enabled,2:Enable EKF2 // @User: Advanced AP_GROUPINFO("EKF_TYPE", 14, AP_AHRS, _ekf_type, 2),#endif 在DCM算法里，与ekf算法一样，最后都生成了roll, roll_sensor， _cos_roll。 123456789101112131415161718192021222324252627// calculate the euler angles and DCM matrix which will be used for high level// navigation control. Apply trim such that a positive trim value results in a// positive vehicle rotation about that axis (ie a negative offset)voidAP_AHRS_DCM::euler_angles(void)&#123; _body_dcm_matrix = _dcm_matrix; _body_dcm_matrix.rotateXYinv(_trim); _body_dcm_matrix.to_euler(&amp;roll, &amp;pitch, &amp;yaw); update_cd_values();&#125;/* update the centi-degree values */void AP_AHRS::update_cd_values(void)&#123; roll_sensor = degrees(roll) * 100; pitch_sensor = degrees(pitch) * 100; yaw_sensor = degrees(yaw) * 100; if (yaw_sensor &lt; 0) yaw_sensor += 36000;&#125;// update trig values including _cos_roll, cos_pitchupdate_trig(); EKF1与EKF2的切换：这里假设你自己在开发版代码中想使用EKF1怎么办？直接进行参数配置或者在地面站修改EKF相关的参数即可，具体如下修改即可 源码修改，全局搜索到如下地方，更改成下面的样子。 123AP_GROUPINFO_FLAGS("ENABLE", 0, NavEKF2, _enable, 0, AP_PARAM_FLAG_ENABLE),AP_GROUPINFO_FLAGS("ENABLE", 34, NavEKF, _enable, 1, AP_PARAM_FLAG_ENABLE),AP_GROUPINFO("EKF_TYPE", 14, AP_AHRS, _ekf_type, 1), 地面站也是要修改三个地方。 可以总结出各个参数都在各自的cpp文件中有默认值如AP_MotorsMulticopter.cpp中的AP_GROUPINFO(“CURR_MAX”, 12, AP_MotorsMulticopter, _batt_current_max, AP_MOTORS_CURR_MAX_DEFAULT),设置解锁时电机的转速。 姿态控制 预习材料：PID参数调节/串级PID/串级PID1 下面将先进行APM源码自稳模式的PID数据流分析：在AC_AttitudeControl.cpp里 123456789101112131415161718192021void AC_AttitudeControl::attitude_controller_run_quat(const Quaternion&amp; att_target_quat, const Vector3f&amp; att_target_ang_vel_rads)&#123; // Update euler attitude target and angular velocity target att_target_quat.to_euler(_att_target_euler_rad.x,_att_target_euler_rad.y,_att_target_euler_rad.z); //将四元数的目标姿态角装换为欧拉角 _att_target_ang_vel_rads = att_target_ang_vel_rads; // Retrieve quaternion vehicle attitude // TODO add _ahrs.get_quaternion() Quaternion att_vehicle_quat; att_vehicle_quat.from_rotation_matrix(_ahrs.get_rotation_body_to_ned()); //获得机体姿态角 // Compute attitude error (att_vehicle_quat.inverse()*att_target_quat).to_axis_angle(_att_error_rot_vec_rad); //计算角度误差 // Compute the angular velocity target from the attitude error update_ang_vel_target_from_att_error(); //内环P控制，更新_ang_vel_target_rads外环控制值 // Add the angular velocity feedforward, rotated into vehicle frame Matrix3f Trv; get_rotation_reference_to_vehicle(Trv); _ang_vel_target_rads += Trv * _att_target_ang_vel_rads; //更新_ang_vel_target_rads外环控制值&#125; 其中get_rotation_body_to_ned函数的原型为： 123456789101112const Matrix3f &amp;AP_AHRS_NavEKF::get_rotation_body_to_ned(void) const&#123; if (!active_EKF_type()) &#123; //如果没有使用EKF,则使用DCM算法生成的矩阵 return AP_AHRS_DCM::get_rotation_body_to_ned(); &#125; return _dcm_matrix; //否则使用EKF2生成的矩阵&#125;// return rotation matrix representing rotaton from body to earth axesonst Matrix3f &amp;get_rotation_body_to_ned(void) const &#123; return _body_dcm_matrix;&#125; 另为，内环P控制，输出值_ang_vel_target_rads为外环PID目标控制值。 1234567891011121314151617181920212223242526272829void AC_AttitudeControl::update_ang_vel_target_from_att_error()&#123; // Compute the roll angular velocity demand from the roll angle error if (_att_ctrl_use_accel_limit &amp;&amp; _accel_roll_max &gt; 0.0f) &#123; _ang_vel_target_rads.x = sqrt_controller(_att_error_rot_vec_rad.x, _p_angle_roll.kP(), constrain_float(get_accel_roll_max_radss()/2.0f, AC_ATTITUDE_ACCEL_RP_CONTROLLER_MIN_RADSS, AC_ATTITUDE_ACCEL_RP_CONTROLLER_MAX_RADSS)); &#125;else&#123; _ang_vel_target_rads.x = _p_angle_roll.kP() * _att_error_rot_vec_rad.x; &#125; // Compute the pitch angular velocity demand from the roll angle error if (_att_ctrl_use_accel_limit &amp;&amp; _accel_pitch_max &gt; 0.0f) &#123; _ang_vel_target_rads.y = sqrt_controller(_att_error_rot_vec_rad.y, _p_angle_pitch.kP(), constrain_float(get_accel_pitch_max_radss()/2.0f, AC_ATTITUDE_ACCEL_RP_CONTROLLER_MIN_RADSS, AC_ATTITUDE_ACCEL_RP_CONTROLLER_MAX_RADSS)); &#125;else&#123; _ang_vel_target_rads.y = _p_angle_pitch.kP() * _att_error_rot_vec_rad.y; &#125; // Compute the yaw angular velocity demand from the roll angle error if (_att_ctrl_use_accel_limit &amp;&amp; _accel_yaw_max &gt; 0.0f) &#123; _ang_vel_target_rads.z = sqrt_controller(_att_error_rot_vec_rad.z, _p_angle_yaw.kP(), constrain_float(get_accel_yaw_max_radss()/2.0f, AC_ATTITUDE_ACCEL_Y_CONTROLLER_MIN_RADSS, AC_ATTITUDE_ACCEL_Y_CONTROLLER_MAX_RADSS)); &#125;else&#123; _ang_vel_target_rads.z = _p_angle_yaw.kP() * _att_error_rot_vec_rad.z; &#125; // Add feedforward term that attempts to ensure that the copter yaws about the reference // Z axis, rather than the vehicle body Z axis. // NOTE: This is a small-angle approximation. _ang_vel_target_rads.x += _att_error_rot_vec_rad.y * _ahrs.get_gyro().z; _ang_vel_target_rads.y += -_att_error_rot_vec_rad.x * _ahrs.get_gyro().z;&#125; 外环PID控制并设置电机值。 123456void AC_AttitudeControl::rate_controller_run()&#123; _motors.set_roll(rate_bf_to_motor_roll(_ang_vel_target_rads.x)); _motors.set_pitch(rate_bf_to_motor_pitch(_ang_vel_target_rads.y)); _motors.set_yaw(rate_bf_to_motor_yaw(_ang_vel_target_rads.z));&#125; 这个函数位于ArduCopter.cpp里的fast_loop函数里，它是放于内环控制之前的。如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344// Main loop - 400hzvoid Copter::fast_loop()&#123; // IMU DCM Algorithm // -------------------- read_AHRS(); // run low level rate controllers that only require IMU data attitude_control.rate_controller_run(); //外环并赋值给电机 #if FRAME_CONFIG == HELI_FRAME update_heli_control_dynamics();#endif //HELI_FRAME // send outputs to the motors library motors_output(); // Inertial Nav // -------------------- read_inertia(); // check if ekf has reset target heading check_ekf_yaw_reset(); // run the attitude controllers update_flight_mode(); //如果仅考虑自稳模式，内环控制在这个里边 // update home from EKF if necessary update_home_from_EKF(); // check if we've landed or crashed update_land_and_crash_detectors();#if MOUNT == ENABLED // camera mount's fast update camera_mount.update_fast();#endif // log sensor health if (should_log(MASK_LOG_ANY)) &#123; Log_Sensor_Health(); &#125;&#125; 看看rate_controller_run函数其中的rate_bf_to_motor_roll函数，这里进行了外环控制。 12345678910111213141516171819202122float AC_AttitudeControl::rate_bf_to_motor_roll(float rate_target_rads)&#123; float current_rate_rads = _ahrs.get_gyro().x; float rate_error_rads = rate_target_rads - current_rate_rads; // For legacy reasons, we convert to centi-degrees before inputting to the PID _pid_rate_roll.set_input_filter_d(degrees(rate_error_rads)*100.0f); _pid_rate_roll.set_desired_rate(degrees(rate_target_rads)*100.0f); float integrator = _pid_rate_roll.get_integrator(); // Ensure that integrator can only be reduced if the output is saturated if (!_motors.limit.roll_pitch || ((integrator &gt; 0 &amp;&amp; rate_error_rads &lt; 0) || (integrator &lt; 0 &amp;&amp; rate_error_rads &gt; 0))) &#123; integrator = _pid_rate_roll.get_i(); &#125; // Compute output float output = _pid_rate_roll.get_p() + integrator + _pid_rate_roll.get_d(); // Constrain output return constrain_float(output, -AC_ATTITUDE_RATE_RP_CONTROLLER_OUT_MAX, AC_ATTITUDE_RATE_RP_CONTROLLER_OUT_MAX);&#125; 串口、GCS及LOG调试由于我们在姿态算法测试的过程当中需要及时查看相关数据的变化情况或者波形图，在APM里主要有几种方法可以实现我们的目的。第一种为串口：这种方式不仅在姿态算法测试而且在系统调试的过程当中都很起作用，假如你的Pixhawk突然启动出错，这个时候你就可以通过串口查看板子上电后rcS（输出信息都使用echo）的启动过程。另一方面，在APM的代码里，有独立的库文件可以进行编译学习，目的是可以让你单独快速的学习这个模块，如下，而这个里边的输出信息直接打印到了串口。 123456789101112131415161718192021222324void setup()&#123; hal.console-&gt;println("OpticalFlow library test ver 1.6"); hal.scheduler-&gt;delay(1000); // flowSensor initialization optflow.init(); if (!optflow.healthy()) &#123; hal.console-&gt;print("Failed to initialise PX4Flow "); &#125; hal.scheduler-&gt;delay(1000);&#125;void loop()&#123; hal.console-&gt;println("this only tests compilation succeeds"); hal.scheduler-&gt;delay(5000);&#125;AP_HAL_MAIN 串口的连接方式如下： 第二种方式为GCS：即通过飞控与地面站建立通信，在地面站上显示图形界面来显示波形。下面结合源码简单分析一下GCS：从Arducopter.cpp可以看出，与地面站通信的主要线程为： 1234SCHED_TASK(gcs_check_input, 400, 180),SCHED_TASK(gcs_send_heartbeat, 1, 110),SCHED_TASK(gcs_send_deferred, 50, 550),SCHED_TASK(gcs_data_stream_send, 50, 550), 但是有一个地方需要注意，在void Copter::init_ardupilot()函数中，有一个设置： 1234// Register the mavlink service callback. This will run// anytime there are more than 5ms remaining in a call to// hal.scheduler-&gt;delay.hal.scheduler-&gt;register_delay_callback(mavlink_delay_cb_static, 5); 而这个函数为mavlink_delay_cb_static，追踪进去copter.mavlink_delay_cb();，再进去就是： 12345678910111213141516171819202122232425262728293031323334/* * a delay() callback that processes MAVLink packets. We set this as the * callback in long running library initialisation routines to allow * MAVLink to process packets while waiting for the initialisation to * complete */void Copter::mavlink_delay_cb()&#123; static uint32_t last_1hz, last_50hz, last_5s; if (!gcs[0].initialised || in_mavlink_delay) return; in_mavlink_delay = true; uint32_t tnow = millis(); if (tnow - last_1hz &gt; 1000) &#123; last_1hz = tnow; gcs_send_heartbeat(); gcs_send_message(MSG_EXTENDED_STATUS1); &#125; if (tnow - last_50hz &gt; 20) &#123; last_50hz = tnow; gcs_check_input(); gcs_data_stream_send(); gcs_send_deferred(); notify.update(); &#125; if (tnow - last_5s &gt; 5000) &#123; last_5s = tnow; gcs_send_text(MAV_SEVERITY_INFO, "Initialising APM"); &#125; check_usb_mux(); in_mavlink_delay = false;&#125; 可知在这里也进行了数据的发送，那岂不是与之前的线程冲突了？仔细查看hal.scheduler-&gt;register_delay_callback这个函数: 123456void PX4Scheduler::register_delay_callback(AP_HAL::Proc proc, uint16_t min_time_ms) &#123; _delay_cb = proc; _min_delay_cb_ms = min_time_ms;&#125; 而_delay_cb，_min_delay_cb_ms在delay函数里得到了调用： 1234567891011121314151617181920212223void PX4Scheduler::delay(uint16_t ms)&#123; if (in_timerprocess()) &#123; ::printf("ERROR: delay() from timer process\n"); return; &#125; perf_begin(_perf_delay); uint64_t start = AP_HAL::micros64(); while ((AP_HAL::micros64() - start)/1000 &lt; ms &amp;&amp; !_px4_thread_should_exit) &#123; delay_microseconds_semaphore(1000); if (_min_delay_cb_ms &lt;= ms) &#123; if (_delay_cb) &#123; _delay_cb(); &#125; &#125; &#125; perf_end(_perf_delay); if (_px4_thread_should_exit) &#123; exit(1); &#125;&#125; 因此可以知道这里的意思就是，如果系统有延时过长（_min_delay_cb_ms &lt;= ms）的情况，则会给gcs发送数据，这样以防止与gcs通信中断。 主要发送消息流函数gcs_data_stream_send 1234567891011/* * send data streams in the given rate range on both links */void Copter::gcs_data_stream_send(void)&#123; for (uint8_t i=0; i&lt;num_gcs; i++) &#123; if (gcs[i].initialised) &#123; gcs[i].data_stream_send(); &#125; &#125;&#125; 如果我们继续往里边看，可以看到这里分类进行输出。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104voidGCS_MAVLINK::data_stream_send(void)&#123; if (waypoint_receiving) &#123; // don't interfere with mission transfer return; &#125; if (!copter.in_mavlink_delay &amp;&amp; !copter.motors.armed()) &#123; handle_log_send(copter.DataFlash); &#125; copter.gcs_out_of_time = false; if (_queued_parameter != NULL) &#123; if (streamRates[STREAM_PARAMS].get() &lt;= 0) &#123; streamRates[STREAM_PARAMS].set(10); &#125; if (stream_trigger(STREAM_PARAMS)) &#123; send_message(MSG_NEXT_PARAM); &#125; // don't send anything else at the same time as parameters return; &#125; if (copter.gcs_out_of_time) return; if (copter.in_mavlink_delay) &#123; // don't send any other stream types while in the delay callback return; &#125; if (stream_trigger(STREAM_RAW_SENSORS)) &#123; send_message(MSG_RAW_IMU1); send_message(MSG_RAW_IMU2); send_message(MSG_RAW_IMU3); &#125; if (copter.gcs_out_of_time) return; if (stream_trigger(STREAM_EXTENDED_STATUS)) &#123; send_message(MSG_EXTENDED_STATUS1); send_message(MSG_EXTENDED_STATUS2); send_message(MSG_CURRENT_WAYPOINT); send_message(MSG_GPS_RAW); send_message(MSG_NAV_CONTROLLER_OUTPUT); send_message(MSG_LIMITS_STATUS); &#125; if (copter.gcs_out_of_time) return; if (stream_trigger(STREAM_POSITION)) &#123; send_message(MSG_LOCATION); send_message(MSG_LOCAL_POSITION); &#125; if (copter.gcs_out_of_time) return; if (stream_trigger(STREAM_RAW_CONTROLLER)) &#123; send_message(MSG_SERVO_OUT); &#125; if (copter.gcs_out_of_time) return; if (stream_trigger(STREAM_RC_CHANNELS)) &#123; send_message(MSG_RADIO_OUT); send_message(MSG_RADIO_IN); &#125; if (copter.gcs_out_of_time) return; if (stream_trigger(STREAM_EXTRA1)) &#123; send_message(MSG_ATTITUDE); send_message(MSG_SIMSTATE); send_message(MSG_PID_TUNING); &#125; if (copter.gcs_out_of_time) return; if (stream_trigger(STREAM_EXTRA2)) &#123; send_message(MSG_VFR_HUD); &#125; if (copter.gcs_out_of_time) return; if (stream_trigger(STREAM_EXTRA3)) &#123; send_message(MSG_AHRS); send_message(MSG_HWSTATUS); send_message(MSG_SYSTEM_TIME); send_message(MSG_RANGEFINDER);#if AP_TERRAIN_AVAILABLE &amp;&amp; AC_TERRAIN send_message(MSG_TERRAIN);#endif send_message(MSG_BATTERY2); send_message(MSG_MOUNT_STATUS); send_message(MSG_OPTICAL_FLOW); send_message(MSG_GIMBAL_REPORT); send_message(MSG_MAG_CAL_REPORT); send_message(MSG_MAG_CAL_PROGRESS); send_message(MSG_EKF_STATUS_REPORT); send_message(MSG_VIBRATION); send_message(MSG_RPM); &#125;&#125; 这么多消息，它的管理方式为队列。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// send a message using mavlink, handling message queueingvoid GCS_MAVLINK::send_message(enum ap_message id)&#123; uint8_t i, nextid; // see if we can send the deferred messages, if any while (num_deferred_messages != 0) &#123; if (!try_send_message(deferred_messages[next_deferred_message])) &#123; break; &#125; next_deferred_message++; if (next_deferred_message == MSG_RETRY_DEFERRED) &#123; next_deferred_message = 0; &#125; num_deferred_messages--; &#125; if (id == MSG_RETRY_DEFERRED) &#123; return; &#125; // this message id might already be deferred for (i=0, nextid = next_deferred_message; i &lt; num_deferred_messages; i++) &#123; if (deferred_messages[nextid] == id) &#123; // its already deferred, discard return; &#125; nextid++; if (nextid == MSG_RETRY_DEFERRED) &#123; nextid = 0; &#125; &#125; if (num_deferred_messages != 0 || !try_send_message(id)) &#123; // can't send it now, so defer it if (num_deferred_messages == MSG_RETRY_DEFERRED) &#123; // the defer buffer is full, discard return; &#125; nextid = next_deferred_message + num_deferred_messages; if (nextid &gt;= MSG_RETRY_DEFERRED) &#123; nextid -= MSG_RETRY_DEFERRED; &#125; deferred_messages[nextid] = id; num_deferred_messages++; &#125;&#125; 注意这里边有个所谓的get_secondary_attitude函数，它是另外一种算法的姿态信息，不是DCM就是EKF： 1234567891011121314151617// return secondary attitude solution if available, as eulers in radiansbool AP_AHRS_NavEKF::get_secondary_attitude(Vector3f &amp;eulers)&#123; switch (active_EKF_type()) &#123; case EKF_TYPE_NONE: // EKF is secondary EKF1.getEulerAngles(eulers); //这个是EKF1算法生成的姿态信息 return ekf1_started; case EKF_TYPE1: case EKF_TYPE2: default: // DCM is secondary eulers = _dcm_attitude; //这是DCM算法生成的姿态信息，应该是返回这里 return true; &#125;&#125; 消息由_mav_finalize_message_chan_send定制，最后由comm_send_buffer发出～如果飞控出现问题如，gcs_send_text(MAV_SEVERITY_CRITICAL,”PreArm: Waiting for Nav Checks”);，是这个函数发出来的。 在apmplanner里查看波形如下： 第三种当然是通过SD卡咯，一般来说，当我们实际飞行完成后，可以将SD里面的飞行数据进行分析，对于APM的固件，数据打包成bin格式的文件存储于SD卡中，可以使用apmplanner(如上图中的OpenLog)读取，也可以通过MAVExplorer。实际操作很简单，不进行分析。APM的源码体现为： 123456789101112131415161718192021222324252627// fifty_hz_logging_loop// should be run at 50hzvoid Copter::fifty_hz_logging_loop()&#123;#if HIL_MODE != HIL_MODE_DISABLED // HIL for a copter needs very fast update of the servo values gcs_send_message(MSG_RADIO_OUT);#endif#if HIL_MODE == HIL_MODE_DISABLED if (should_log(MASK_LOG_ATTITUDE_FAST)) &#123; Log_Write_Attitude(); Log_Write_Rate(); if (should_log(MASK_LOG_PID)) &#123; DataFlash.Log_Write_PID(LOG_PIDR_MSG, g.pid_rate_roll.get_pid_info() ); DataFlash.Log_Write_PID(LOG_PIDP_MSG, g.pid_rate_pitch.get_pid_info() ); DataFlash.Log_Write_PID(LOG_PIDY_MSG, g.pid_rate_yaw.get_pid_info() ); DataFlash.Log_Write_PID(LOG_PIDA_MSG, g.pid_accel_z.get_pid_info() ); &#125; &#125; // log IMU data if we're not already logging at the higher rate if (should_log(MASK_LOG_IMU) &amp;&amp; !(should_log(MASK_LOG_IMU_FAST) || should_log(MASK_LOG_IMU_RAW))) &#123; DataFlash.Log_Write_IMU(ins); &#125;#endif&#125; 参考文献陀螺仪加速度计MPU6050]]></content>
      <categories>
        <category>飞控</category>
      </categories>
      <tags>
        <tag>PX4</tag>
        <tag>飞控算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C Plus学习笔记]]></title>
    <url>%2F2017%2F06%2F16%2FC-Plus%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[资源：http://www.cplusplus.com 阅读笔记 C语言是面向过程的语言，支持模块化、结构化的方法。C++融合了OOP、通用编程和传统的过程性方法，这表明C++强调的是实用价值，而不是意识形态方法，这也是该语言获得成功的原因之一。 才发现CC为标准UNIX C++编译器，而cc为标准UNIX C编译器。g++为GNU C++编译器，而GNU C++编译器的MS-DOS版本名为gpp。comeau编译器最为严格、标准。都是先生成.o文件，在生成.out文件。 在C中，main函数括号为空表示对是否接受参数保持沉默，而在C++中为空与跟void一样。C++中main函数默认返回0。 C++预处理器对添加的头文件去掉了.h格式，当然也兼容以前的C格式。 如果省略using编译指令，必须这样编码std::cout，如果单独使用这个函数，可以这样：using std::cout，using指令可以根据应用的范围放在合适的位置。 标记与空白的概念。 C++允许使用连续赋值。 cout是可扩展的，允许自行开发新的数据类型。 C++允许在函数的任何地方声明新变量。 在C中，有返回值的函数称为函数，没有返回值的函数称为过程。C++中，这两种变体都是函数。 类是用户定义的数据类型规范。面向对象编程(OPP)的本质是设计并扩展自己的数据类型。内置的C++内型分为基本类型和复合类型。 在C++中，以两个下划线或下划线和大写字母大头的名称被保留给实现使用，以一个下划线开头的名称被保留实现，用作全局标识符，但他们都是有效的。 short至少16位；int至少和short一样长；long至少32位，且至少与int一样长。 sizeof对类型名使用时，必须加上括号。 C++使用前一(两)位来标识数字常量的基数。如果第一位是1～9，则基数为10；如果第一位为0，第二位为1～7，则基数为8；如果前两位为0x或0X，则基数为16。 数据后缀标识存储的类型，如2344L，默认情况下为int型，除非太大，int装不下。 转义序列和通用字符(以\u和\U打头)。 char在默认情况下既不是有符号，也不是没符号。在符号很重要的情况下，一定要特别声明。 存在一种wchar_t的宽字符类型。 C++中存在bool类型，任何非零值都被转换为true，任何零被转换为false。 关键字const叫做限定符。 E表示法适合于非常大和非常小的浮点数。如：+3.45E+6指的是3.45与1000000相乘的结果，E后为负数代表除以10的乘方。 cout.setf(ios_base::fixed, ios_base::floatfield);，这样可以显示浮点数多余的零。 操作符重载：int除法、float除法和double除法。 赋值计算在类型转换时，较大的数转换为较小的数时，原来的值可能超过目标类型的取值范围，这种情况结果将是不可确定的。将浮点型转换为整形时，C++采取截取(丢弃小数部分)，而不是四舍五入。 true被转换为1，false被转换为0，这些转换称为整形提升(int 类型计算速度更快)。 传统C语言总是将float提升为double，即使两个操作数都是float。 强制类型转换的格式为：(typeName)value/typeName(value)，第一种来自C语言，第二种来自C++语言。 用引号括起的字符串隐式的包括了结尾的空字符。如“S”表示两个字符，而‘S’单表示一个字符，更糟糕的是，“S”表示的是一个内存的地址。 strlen函数返回的是存储在数组中字符串的长度，而不是数组本身的长度。另外strlen不会计算空字符。 为了能够输入多个单词，可以使用cin.getline()函数和cin.get()函数，getline丢弃了换行符，存储时用空字符替换，而get保留在了输入序列中，所以在使用这种方法时，需要不带任何参数的cin.get()调用读取下一个字符，也可以连续调用，如cin.get(name,ArSize).get()。 string在C++中是作为类出现。string类具有自动调整大小的功能。输入字符串的方法为getline(cin,str)。 12345for (int i = 0; i &lt; SIZE; i++)&#123; cout &lt;&lt; i + 1 &lt;&lt; ": "; getline(cin, list[i]);&#125; C++允许在结构声明中省略关键字struct，结构体成员中也能进行赋值操作。 结构中的位字段：字段的类型应该为整形或枚举型，接下来是冒号，冒号后面是一个数字，它指定了使用的位数。通常用在低级编程中。 匿名共用体：将共用体用于结构体中，它们的地址相同，所以不需要中间标识符。 枚举、枚举量：默认情况，第一个枚举量为0。另外枚举变量只定义了赋值运算，没有定义算术运算。可自动转换为int型。如果只打算使用常量，而不创建枚举类型的变量，则可以省略枚举类型的名称。可以创建多个值相同的枚举量。可以将在取值范围内的任意整数赋给枚举量。 面向对象编程和传统的过程性编程的区别在于，OOP强调的是在运行阶段(而不是编译阶段)进行决策。动态联编/静态联编。 指针声明必须指定指针指向的数据类型。创建指针时，只会分配存储地址的内存，如int一般是一个4个字节的值,64位系统为8。创建指针时返回值为0表示空置指针。 如果内存泄漏严重，则程序将由于不断寻找更多内存而终止。 警告：delete对空指针使用是安全的。不能释放同一个内存块两次。 对于数组的创建与删除：int* psome = new int[10]/delete [] psome。指针加减一表示向前后移动一个元素。C++将数组名解释为数组第一个元素的地址。 数组与指针的一些区别：数组名是常量，而指针值是可以修改的。sizeof取数组为数组的长度，这种情况不会把数组名解释为地址。 指针运算：两个指针的差将得到一个整数。 “flower”传递的是字符串第一个字符的地址。 如果给cout提供一个地址，如果指针的类型为char ，则cout将显示字符串，如果要显示字符串的地址，应该使用int 。 如果结构标识符是结构名，则使用句点操作符；如果标识符是指向结构的指针，则使用箭头操作符。 注意：ps-&gt;volume与(*ps).volume等价。 管理数据内存的方式：自动存储、静态存储、动态存储。 内存泄漏：如果没有调用delete，包含指针的内存由于作用域规则和对象生命周期的原因而被释放，在自由存储空间上动态分配的变量或结构也将继续存在，但由于无法继续访问，因为指向这些内存的指针无效，这将导致内存泄漏。 C++常在for和括号之间加上一个空格，而省略函数名与括号之间的空格。 在设计循环时，请记住下面几条知道原则： 确定循环终止的条件 在首次测试之前初始化条件 在条件再次测试之前更新条件 cout.setf(ios::boolalpha)函数调用设置了一个标记，该标记命令cout显示true和false，而不是1和0。 顺序点是程序执行过程中的一个点，进入下一步之前确保对所有的副作用都进行评估。赋值操作符、递增操作符和递减操作符执行的所有修改是在顺序点完成。应避免这样的语句：y = (4 + x++) + (6 + x++); 后缀递增版本首先需要复制一个版本，再将其加1，然后将复制的拷贝返回，因此前缀版本的效率比后缀版本高。 C++规定，逗号表达式的值是第二部分的值。如cats = (17,24)为24。 C-风格字符串是通过结尾的空值字符定义的，而不是由其所在数组的长度定义的。这意味着两个字符串即使被存储在长度不同的数组中，也可能是相同的。 for循环里可以重新定义变量，这个变量可能只能在这个循环体里有效，但是循环体里定义的变量只能在循环体里使用。 C-风格字符串大小比较需要使用strcmp()函数，而C++风格可直接进行比较。 cin将忽略空格和换行，如需读取，请使用cin.get(ch)，其返回的是cin对象，在需要bool值的地方可以自动转换。相当于C规则的getchar(ch) ctrl + D/Z相当于EOF，可以使用cin.eof()/cin.fail()返回的boo值进行检测，输入错误和EOF都将导致cin返回false，可以用cin.clear()进行清除然后重新输入。 从存储空间的角度来讲，指针数组比char数组的数组更为经济。 C++规定，||等逻辑操作符是一个顺序点。另外，冒号和逗号操作符也是顺序点。 if(17 &lt; age &lt; 35)的含义为if((17 &lt; age) &lt; 35)，所以一直为真。 &amp;&amp;的优先级高于||。 C++的switch语句中，default标签是可选的，如果被省略，又没有匹配的标签，则程序将跳到switch语句后面的语句执行。 文本文件：对于输入，将执行相反的转换。即整数将被转换为数字字符序列，浮点数转换为数字字符和其他字符组成的字符序列，字符数据不需要做任何转换。 iostream 提供了一个预先定义好的名为cout的ostream对象，而我们必须声明自己的ofstream对象。如： 123456789ofstream outFile;outFile.open("fish.txt");ofstream fout;cin &gt;&gt; filename;fout.open(filename);double wt = 125.9;outFile &lt;&lt; wt; 总之，使用文件输出的主要步骤如下： 包含头文件fstream。 创建一个ofstream对象。 将该ofstream对象同一个文件关联起来。 就像使用cout那样使用ofstream对象。 inFile.good()在输入没有发生错误的时候返回true。表达式inFile&gt;&gt;value的结果为inFile，而在需要一个bool值的情况下，inFile的结果为inFile.good()，即true或false。 在C++原型中，不指定参数列表时应使用省略号: 1void say_bye(...); 通常，仅当与接受可变参数的C函数(如printf())交互时才需要这样做。 函数原型的检查称为静态类型检查。 cin &gt;&gt; total &gt;&gt; choices，如果输入4 2，那么total为4，choice为2。 在C++中，当且仅当用于函数头或函数原型中，int *arr 和int arr[]的含义才相同。 循环输入数组，显示数组 123456789101112131415161718192021222324int fill_array(double ar[], int limit)&#123; using namespace std; double temp; int i; for (i = 0; i &lt; limit; i++) &#123; cout &lt;&lt; "Enter value #" &lt;&lt; (i + 1) &lt;&lt; ": "; cin &gt;&gt; temp; if (!cin) &#123; cin.clear(); while (cin.get() != '\n') continue; cout &lt;&lt; "Bad input : input process terminated.\n"; break; &#125; else if (temp &lt; 0) break; ar[i] = temp; &#125; return i;&#125;void show_array(const double ar[], int limit); 关于const的两种情况： 12345const float g_earth = 9.80;const float * pe = &amp;g_earth; //VALIDconst float g_moon = 1.63;float * pm = &amp;g_moon; //INVALID 只能将非const数据的地址赋给非const指针，如不能将const数组名作为参数传递给非常量形参的函数。所以加上const，能够处理const和非const实参。 二维数组函数定义： 12345678int sum(int ar2[][4], int size)&#123; int total = 0; for (int r = 0; r &lt; size; r++) for(int c = 0; c &lt; 4; c++) total += ar2[r][c]; return total;&#125; 当结构较小时，按值传递最合理。较大时使用按址传递。 递归案例：ruler.cpp 函数指针基础知识 函数名即为函数地址。 函数指针声明。 &lt;img src=&quot;/images/funstr.png&quot;&gt; 例如 void estimate(int lines, double (*pf) (int)); 使用指针来调用函数，见例子。 123456double pam(int);double (*pf) (int);pf = pam;double x = pam(4);double y = (*pf)(4);double z = pf(4); 内联函数不能递归。与C语言的宏类似。只需在定义和声明前加上inline即可。 必须在声明引用时将其初始化。注意：在C++中，使用const，当形参的类型不对或不是左值时，将会自动创建临时变量，这样将不能修改作为参数传递的变量。 引用可以用来交换数据。 void swapr(int &amp;a, int &amp;b); 结构引用：const sysop &amp; use(sysop &amp; sysopref);，请见例程/类对象，应避免返回函数终止时不再存在的内存单元引用。通过传递引用而不是整个数据对象，可以提供程序的运行速度。 注意在返回值加上const，意味着不能使用返回的引用直接修改它指向的引用。参数类型为ostream &amp;的函数可以接受ostream对象或声明的ofstream对象作为参数，见文件类。设置类如下 指导原则： 默认参数指的是当函数调用中省略了实参时，自动使用的一个值。方法只是将值赋给原型中的参数。如 1char * left(const char * str, int n = 1); 对于带参数列表的函数，必须从右向左添加默认值。实参按从左到右的顺序依次被赋给相应的形参，而不能跳过任何参数。&lt;例子&gt; 函数重载的关键是函数的参数列表—也称为函数特征标。注意，类型引用和类型本身视为同一个特征标。匹配函数时，并不区分const和非const变量。对于函数重载，C++内部进行了名称修饰，也称为C++语言链接。&lt;例子&gt; C++函数模板允许以任意类型的方式来定义函数。例如，建立一个交换模板。这样使生成的函数定义更简单、可靠。&lt;例子&gt; 123456789template &lt;class Any&gt;void Swap(Any &amp;a, Any &amp;b)&#123; Any temp; temp = a; a = b; b = temp;&#125;# =&gt; 或使用typename代替class 另外，模板也能进行重载。如void Swap(Any [], Any [], int)，并非所有的模板参数都必须为模板参数类型。&lt;例子&gt; 显示具体化的原型和定义应以template&lt;&gt;打头，并通过名称来指出类型，这样可以只交换结构体中的一部分成员。不要使用Swap()模板来生成函数定义，而应使用独立的、专门的函数显式的为job类型生成函数定义，如template &lt;&gt; void Swap&lt;job&gt;(job&amp;, job&amp;);，其中Swap&lt;job&gt;中的&lt;job&gt;是可选的。&lt;例子&gt; 编译器使用模板为特地类型生成函数定义时，得到的是模板实例，有隐式实例化和显式实例化。显式实例化如template void Swap(int, int);，它与显式具体化不同，template后面没有&lt;&gt;。而隐式实例化指的是一般的模板调用。警告：试图在同一编程单元中使用同一类型的显式实例和显式具体化将出错。 隐式实例化、显式实例化和显式具体化统称为具体化，它们都使用具体类型的函数调用，而不是通用描述。 在重载解析中，哪一种执行的转换最少，将被优先得到执行。如果出现多个匹配或没有，都将出现错误。&lt;例子&gt; 头文件常包含的内容： 函数原型 使用#define或const定义的符号常量 结构声明 类声明 模板声明 内联函数 多个库的链接由于编译器名称修饰问题可能无法正确的连接。 变量的一些特性：存储持续性、作用域和链接性。寄存器变量也是auto变量，只是它是用寄存器而不是堆栈来处理变量。链接分为：外链接、内链接和无链接。包含字符串输入的static例子 ::为作用域解析操作符。 mutable可以指出，即使结构或类为const，其某个成员也可以被修改。 在C++看来，全局const定义就像使用了static说明符一样。如果链接为外部的，extern const int states = 50; 布局new操作符、常规new操作符。布局操作符如：p1 = new (placement) int;，或pd2 = new (buffer + N*sizeof(double)) double[N];。布局操作符不需delete。&lt;例子&gt; 声明区域 作用域 名称空间：namespace，其链接性是外部的，可以将名称空间声明进行嵌套。 1234567namespace myth&#123; using Jill::fetch; using namespace elements; using std::cout; using std::cin;&#125; 使用using编译指令和using声明。 可以给名称空间创建别名：namespace mvft = my_very_favorite_things {…}; 简化：namespace MEF = myth::elements::fire; using MEF::flame; 可以使用未命名的名称空间来代替C++文件静态变量。 OOP特性：抽象、封装和数据隐藏、多态、继承、代码的可重用性。在C++中，用户定义类型指的是实现抽象接口的类设计。 类规范由两部分组成：类声明、类方法定义。类声明提供了类的蓝图，而方法定义则提供了细节。在类中，成员函数可以就地定义，也可以声明原型。由于隐藏数据是OOP主要目标之一，因此数据项通常放在私有部分，将数据封装到私有部分可以保护数据的完整性，这被称为数据隐藏，私有部分也可以包含私有成员函数，组成类接口的成员函数放在公有部分。不必在类声明中使用关键字private，因为这是类对象的默认访问控制。结构的默认访问类型是public，因此结构限制为没有私有部分的类。 类成员函数特征：定义成员函数时，使用作用域解析操作符(::)来标识函数所属的类。类方法可以访问类的private组件。 在UNIX系统中，可以分别对cout和cerr进行重定向，命令行操作符&gt;用于对cout进行重定向，操作符2&gt;对cerr进行重定向。 定义位于类声明中的函数都被自动称为内联函数。当然在类声明之外，只需加上inline即可。 对象、数据和成员函数&lt;例子&gt; OOP程序员常依照客户/服务器模型来讨论程序设计。 类不能像初始化结构一样初始化类，因为数据部分的访问状态是私有的，必须使用类构造函数，构造函数没有声明类型，位于类声明的公有部分。构造函数在完成其工作之前，对象并不存在。注意：构造函数的参数表示的不是类成员，而是赋给类成员的值，因此参数名不能与类成员相同，一般在数据成员中使用m_前缀。 C++提供了两种使用构造函数来初始化对象的方式。第一种为显式调用：Stock food = Stock(“World Cabbage”, 250, 1.25)，第二种为隐式调用：Stock garment(“Furry Masson”, 50, 2.5)。注意：无法使用对象来像调用成员函数一样调用构造函数，因为在构造函数构造出对象之前，对象是不存在的。 定义默认构造函数的方式有两种，一种是给已有构造函数的所有参数提供默认值：Stock (const char * co = “Error”, int n = 0, double pr = 0.0);，当类中含义指针类型时，必须显式的定义默认构造函数。另一种是通过重载来定义另外一个构造函数——一个没有参数的构造函数：Stock();。构造函数还能实现重载，构造函数没有声明类型。记住：接收一个参数的构造函数允许使用赋值句法来将对象初始化为一个值，也可以看作为强制类型转换，可以使用explicit 关闭隐式转换，但仍然可以进行显式转换：myCat = Stonewt(19.6);，当然19.6也可以是int型，会自动转换为double型。&lt;例子&gt; 如何将类类型转换为其它内置类型？使用特殊的C++操作符函数——转换函数。如：Stonewt::operator int() const;，其返回类型可以是被声明为目标类型的类成员函数：Star::Star double();。&lt;例子&gt; 注意一下几点： 转换函数必须是类方法。 转换函数不能指定返回类型，但也能返回所需的值。 转换函数不能有参数。 如果不想被隐式的转换，可以换成int Stonewt::Stone_to_Int();，然后作为方法调用即可。 与构造函数不同的是，析构函数没有参数。如果采用构造函数创建一个临时对象，则会临时调用析构函数。&lt;复合例子&gt; 类是用户定义的类型，对象是类的实例。 const成员函数：void Stock::show()const，不会修改对象的值，这里的const表示const Stock *this，this指向调用的对象。 所有的类方法都将this指针设置为调用它的对象的地址。 例如 12345678const Stock &amp; Stock::topval(const Stock &amp; s)const&#123; if (s.total_val &gt; total_val) return s; else return *this;&#125;//这里的返回值必须为const 对象数组初始化像普通的数组一样。要创建对象数组，则这个类必须有默认的构造函数，但只能有一个默认构造函数，用来设定特定的值，因为如下花括号中的构造函数只是创建临时对象。 123456const int STKS = 10;Stock stocks[STKS] = &#123; Stock("NanoSmart", 12.5, 20), Stock(), Stock("Monolithic Obelisks", 130, 3.25),&#125; 类作用域：可以在不同类中使用相同的类成员名而不会引起冲突。 类只是描述了对象的形式，并没有真正创建对象，因此，在被对象创建之前，并没有用于存储值的空间。可以在类声明中声明枚举为整形常量，并且不需要提供枚举名。也可以采用关键字static，如static const int LEN = 30，但这个不能存储double常量;，如果不是const，则应在定义方法时进行初始化，并且应该加上类限定符。 类很适合描述ADT，使用栈作为类是一个很好的例子。 操作符函数的格式：operator op (argument-list)。其中op为将要重载的操作符。如district2 = sid + sara，操作数是类对象，可以替换为district2 = sid.operator + (sara)。重载操作符也是重载函数，所以可以多次重载同一个操作符。&lt;例子&gt; 操作符重载限制：重载后的操作符必须至少有一个操作数是用户定义的类型。不能违反操作符原来的句法。不能修改操作符优先级。不能定义新的操作符。 友元有三种：友元函数、友元类和友元成员函数。 有一类特殊的非成员函数可以访问类的私有成员，它们被称为友元函数。非成员函数可以解决的问题：A = operator(2.75, B);，因为这个时候的第一个操作数即调用者不为自身对象，只能使用非成员函数。另外还有一种方法是，将2.75强制转换为对象。注意：虽然友元函数是在类声明中声明的，但它不是成员函数，因此不能使用成员操作符调用。它不是成员函数，但与成员函数访问权限相同。不要在定义中使用关键字friend，除非定义也是原型。类声明可以控制哪些函数可以访问私有数据，类方法和友元只是表达类接口的两种不同机制。 打印出Time类trip，重载操作符&lt;&lt; 1234void operator &lt;&lt;(ostream &amp; os, const Time &amp; t)&#123; os &lt;&lt; t.hours &lt;&lt; " hours. " &lt;&lt; t.minutes &lt;&lt; " minutes";&#125; 即可使用cout &lt;&lt; trip 如果要实现拼接，如cout &lt;&lt; “Trip Time: “ &lt;&lt; trip &lt;&lt; “ (Tuesday)\n”; 可返回os的引用，如下 12345ostream &amp; operator &lt;&lt;(ostream &amp; os, const Time &amp; t)&#123; os &lt;&lt; t.hours &lt;&lt; " hours. " &lt;&lt; t.minutes &lt;&lt; " minutes"; return os;&#125; 由于类继承属性让ostream引用能够指向ostream对象和ofsream对象，所以还可以将其写入文件中。&lt;例子&gt; 加法操作符需要两个操作数。对于成员函数版本来说，一个操作数通过this指针隐式的传递，另一个操作数作为函数参数显式传递；对于友元函数来说，两个操作数都作为参数来传递。 如果方法通过计算得到一个新的类对象，则应考虑是否可以使用类构造函数来完成这种工作，这样新的对象规则都是一样的，不会出错。 定义VECTOR命名空间，使Vector类可用。using VECTOR::Vector;&lt;醉鬼走路例子&gt; 当构造与析构的次数不一样时，考虑自动定义的隐式成员函数，如复制构造函数：假设sailor和sports都为StringBad对象，则StringBad sailor = sports;等效于StringBad sailor = StringBad(sports);，而其原型为StringBad(const StringBad &amp;);，这里可以采用一个显式的复制构造函数来解决一个问题。&lt;例子&gt; 隐式成员函数包括：默认构造函数、复制构造函数、赋值操作符、默认析构函数和地址操作符。 复制构造函数：新建一个对象并将其初始化为同类现有对象时，复制构造函数都将会调用。即每当程序生成对象副本时，编译器都将使用复制构造函数。如：函数按值传递对象时，因此因该按引用传递对象，这样可以节省调用构造函数的时间以及存储新对象的空间。默认的复制构造函数逐个复制非静态成员，这里是按值进行复制的。所以例子析构中释放了字符串的地址，而这个地址是由对象复制过来的，再次析构释放时就出现了错误。所以这里应该采用深度复制，而不仅仅复制字符串的地址。 赋值操作符：将一个已有的对象赋给另一个对象时，将使用重载的赋值操作符，来实现成员的逐个复制。解决的办法也是进行深复制。&lt;例子&gt;需要注意几点： 由于目标对象可能引用了以前分配的对象，所以应使用delete []释放。 应该避免将对象赋给自己。 返回一个指向调用对象的引用。 new对应于delete，delete []与new []初始化的指针和空指针都兼容。如：str = new char[1]比str = new char要好。如果有多个构造函数，则必须以相同的方式使用new，要么都带中括号，要么都不带，因为只有一个析构函数。 静态类成员函数特征：函数声明中必须包含关键字static(定义处除外)，不能通过对象调用静态成员函数，可以通过类名和作用域解析符调用它，静态成员函数只能访问静态数据成员。&lt;String类例子&gt; 返回对象将调用复制构造函数，而返回引用不会。返回对象将调用复制构造函数和析构函数，有时候会浪费内存和时间。如：返回类型必须是ostream &amp;，不能使用ostream，因为ostream没有公用的复制构造函数。如果被返回的对象是被调用函数中的局部变量，则应按对象方式返回，通过调用构造函数生成，这样的例子如重载加减运算符。 将加法重载操作符的返回值设为const，这样force1 + force2 = net;这样的语句将称为非法语句。 使用指向对象的指针。如果对象是由new创建的，仅当显式使用delete删除对象时，析构函数才会被调用。也就是说，类指针可以指向已有类，也可以指向新建类。&lt;例子&gt; 使用布局new操作符为对象分配内存时，防止出现内存重叠，可以这样：pc1 = new (buffer) JustTesting; pc3 = new (buffer + sizeof(JustTesting)) JustTesting;，释放内存应该这样：delete [] buffer;，并显式的调用析构函数pc3-&gt;~JustTesting();pc1-&gt;~JustTesting();。&lt;例子&gt; 在类中声明的结构、类或枚举被称为是嵌套在类中，其作用域为整个类。如果是在公有部分声明，也可以在类为通过作用域解析符调用。 引用和const一样，只能在对象创建时进行初始化。对于简单数据成员，使用成员初始化列表和在函数体中进行赋值并没有什么区别，不过效率更高。成员初始化列表只能用于构造函数。数据成员列表被初始化的顺序与它们在类声明中的顺序相同，与初始化列表的排列顺序无关。这使得初始化内置类型就像初始化类对象一样。 为了防止对象未定义深度复制构造函数而造成程序崩溃，可以在私有部分定义空的复制构造函数和重载空的赋值操作符。 1234567class Queue&#123;private: Queue(const Queue &amp; q) : qsize(0) &#123;&#125; Queue &amp; operator =(const Queue &amp; q) &#123; return *this; &#125;//...&#125;; 队列的实现。&lt;例子&gt; 原始类称为基类，继承类称为派生类。 公有派生：派生类对象存储了基类的数据成员。派生类对象可以使用基类的方法。派生类需要自己的构造函数。派生类可以根据需要添加额外的数据成员和成员函数。 构造函数必须给新成员（如果有的话）和继承的成员提供数据。由于派生类不能直接访问基类的私有成员，所以，派生类构造函数必须使用基类构造函数。创建派生类对象时，程序首先创建基类对象，使用成员初始化列表。 除非要使用默认构造函数，否则应显式调用正确的基类构造函数。 如果没有使用动态内存分配，在派生类构造函数里使用基类的隐式复制构造函数是可以的。 释放对象的顺序与创建对象的顺序相反，即首先执行派生类的析构函数，然后自动调用基类的析构函数。&lt;例子&gt; 基类与派生类的关系： 派生类对象可以使用基类的方法，条件是方法不是私有的。 基类指针可以在不进行显示类型转换的情况下指向派生类对象。 基类引用可以在不进行显示类型转换的情况下引用派生类对象。 C++有三种继承关系：公有继承、保护继承和私有继承。 公有继承是最常用的方式，它建立一种is-a关系，即派生类对象也是一个基类对象，可以对基类对象执行任何操作，也可以对派生类对象执行。注意：is-a关系通常是不可逆的，也就是说，水果不是香蕉。公有继承不能建立has-a、is-like-a、is-implemented-as-a、uses-a关系。 多态公有继承：在派生类中重新定义基类方法。使用虚方法virtual，该关键字只出现在方法原型中。对于虚函数，程序将根据对象类型来确定使用哪个版本。对于两个对象中行为相同的方法，只在基类中声明。如果没有使用关键字virtual，程序将根据引用类型或指针类型选择方法；如果使用了virtual，程序将根据引用或指针指向的对象的类型来选择方法。方法在基类中声明为虚拟的后，它在派生类中将自动成为虚方法，一般也都在派生类中指出。为基类声明一个虚拟析构函数也是一种惯例，可以确保正确的析构函数被调用。一般先调用派生类的析构函数，再调用基类的析构函数。 &lt;img src=&quot;/images/jxg.png&quot;&gt; &lt;img src=&quot;/images/xxg.png&quot;&gt; 友元不能是虚函数，只有成员才能是虚函数，但可以让友元函数使用虚拟成员函数。 在派生类成员函数定义时，如果调用虚方法，必须加上类限定符，否则会自己调用自己，产生递归。&lt;例子&gt;可以使用数组来表示多种类型的对象，这就是多态性。 访问控制protected：关键字protected与private相似，在类外只能用公有类成员来访问protected部分中的类成员。protected与private的区别只有在基类派生的类中才能表现出来。派生类的成员可以直接访问基类的保护成员，但不能访问基类的私有成员。 12345678910111213141516171819class TheOnlyInstance&#123;public: static TheOnlyInstance * GetTheOnlyInstance();protected: TheOnlyInstance() &#123;&#125;&#125;TheOnlyInstance* TheOnlyInstance::GetTheOnlyInstance()&#123; static TheOnlyInstance objTheOnlyInstance; return &amp;objTheOnlyInstance;&#125;int main()&#123; TheOnlyInstance noCanDo; //not allowed TheOnlyInstance * pTheOnlyInstance = TheOnlyInstance::GetTheOnlyInstance(); //以后调用，将返回同一个静态地址&#125; 使用私有继承，基类的公有成员和保护成员都将成为派生类的私有成员。这意味着基类方法将不会成为派生类公有接口的一部分，但可以在派生类的成员函数中使用它们。这种不完全继承是has-a关系的一部分，其特性与包含相同。包含版本提供了两个被显式命名的对象成员，而私有继承提供了两个无名称的子对象成员，这是两种方法的主要区别。成员初始化列表使用std::string(str)，而不是name(str)。这是包含和私有继承之间的第二个主要区别。使用作用域解析操作符可以访问基类方法，但如果要使用基类对象本身，可以使用强制类型转换： 1234const string &amp; Student::Name() const&#123; return (const string &amp;) *this;&#125; 用类名显示地限定函数名不适合于友元函数，这是因为友元不属于类。不过可以显式的转换为基类来调用正确的函数。另一方面，如果不使用类型转换，由于使用的多重继承，编译器将无法确定转换成哪个基类。&lt;例子&gt; 12345ostream &amp; operator(ostream &amp; os, const Student &amp; stu)&#123; os &lt;&lt; "Scores for " &lt;&lt; (const string &amp;) stu &lt;&lt; ":\n"; ...&#125; 私有继承所提供的特性比包含多，但会引发许多问题。私有继承可以重新定义虚函数，但也只能在类中使用。 保护继承是私有继承的变体。基类的公有成员和保护成员都将成为派生类的保护成员，与私有不同，第三代的派生类能使用保护成员。 &lt;img src=&quot;/images/dif.png&quot;&gt; 如果使用指向对象的引用或指针来调用虚方法，程序将使用为对象类型定义的方法，而不使用为引用或指针类型定义的方法。这称为动态联编或晚期联编。在C++中，动态联编与指针和引用调用的方法相关，从某中程度上说，这是由继承控制的。编译器对非虚函数采用静态编联。也就是说，当我们通过一个具有普通类型（非引用非指针）的表达式调用虚函数时，在编译时就会将调用的版本确定下来。派生类的虚函数的返回类型形参类型必须与基类函数匹配，否则会隐藏同名的基类方法。只有一个例外，当类的虚函数的返回类型是类本身的指针或引用时，这称为返回类型协变。如果基类声明被重载了，则应在派生类中重新定义所有的基类版本，否则其他的版本都将被隐藏。将派生类引用或指针转换为基类引用或指针被称为向上强制转换，这使公有继承不需要进行显式类型转换，这种转换是可以传递的。仅将那些预期将被重新定义的方法声明为虚拟的。构造函数不能是虚函数，析构函数应当是虚函数。 编译器处理虚函数的方法：给每个对象添加一个隐藏成员，隐藏成员中保存了一个指向函数地址数组的指针，这种数组称为虚函数表。 抽象基类：当类声明中包含纯虚函数时，则不能创建该类的对象。要真正的成为ABC，则至少应包含一个纯虚函数。原型中的=0使虚函数成为纯虚函数。C++允许纯虚函数有定义，也可以不定义。纯虚方法是定义派生类的通用接口。抽象基类的派生类称为具体类，具体类可以创建对象。&lt;例子&gt; 如果基类派生类都使用动态内存分配，则必须为派生类定义显式析构函数、复制构造函数和赋值操作符，也就是说，必须使用相应的基类方法处理基类元素。 1234567891011121314151617class hasDMA : public baseDMA&#123;private: char * style;public:...&#125;;hasDMA &amp; hasDMA::operator =(const hasDMA &amp; hs)&#123; if (this == &amp;hs) return *this; baseDMA::operator =(hs); style = new char[std::strlen(hs.style) + 1]; std::strcpy(style, hs.style); return *this;&#125; 派生类对象的友元函数可以通过基类的友元函数访问基类的成员，由于友元不是成员函数，友元函数不能继承，不能使用作用预解析符，所以可以相应类强制类型转换选择正确的函数。&lt;例子&gt; 1234567std::ostream &amp; operator &lt;&lt;(std::ostream &amp; os, const hasDMA &amp; hs)&#123; os &lt;&lt; (const baseDMA &amp;)hs; //也可以：os &lt;&lt; dynamic_cast&lt;const baseDMA &amp;&gt; (hs) os &lt;&lt; "Style: " &lt;&lt; hs.style &lt;&lt; std::endl; return os;&#125; 通常，包含、私有继承和保护继承用于实现has-a关系，即新的类将包含另一个类的对象。 包含对象成员的类：使用公有继承时，类可以继承接口，可能还有实现。获得接口是is-a关系的组成部分，而使用组合，类可以获得实现，但不能获得接口。不继承接口是has-a关系的组成部分。 对比私有继承： 对于has-a关系来说，类对象不能自动获得被包含对象的接口是一件好事。例如，string类将+操作符重载为将两个字符串连接起来；但从概念上说，将两个Student对象串接起来是没有意义的。 被包含对象的接口不是公有的，但可以在类方法中使用它。&lt;例子&gt; 1234567double Student::Average() const&#123; if (scores.size() &gt; 0) return scores.sum() / scores.size(); else return 0;&#125; 私有辅助方法： 123456789101112131415161718#=&gt; 位于privateostream &amp; Student::arr_out(ostream &amp; os) const&#123; int i; int lim = scores.size(); if (lim &gt; 0) &#123; for (i = 0; i &lt; lim; i++) &#123; os &lt;&lt; scores[i] &lt;&lt; " "; if (i % 5 != 0) os &lt;&lt; endl; &#125; &#125; else os &lt;&lt; " empty array "; return os;&#125; 使用using重新定义访问权限： 方法一是定义一个使用该基类方法的派生类方法。 1234double Student::sum() const&#123; return std::valarray&lt;double&gt;::sum();&#125; 另一种方法是，将函数调用包装在另一个函数调用中，即使用一个using声明(将像名称空间那样)来指出派生类可以使用的特定的基类成员，即使使用的是私有派生。注意：using 声明只使用成员名——没有圆括号、函数特征标和返回类型。using声明只适合继承，而不适用于包含。 12345678class Student : private std::string, private std::valarray&lt;double&gt;&#123;...public: using std::valarray&lt;double&gt;::min; using std::valarray&lt;double&gt;::max;...&#125; 虚基类：虚基类使得从多个类（它们的基类相同）派生出的对象只继承一个基类对象。例如：通过在类声明中使用关键字virtual, 可以使Worker被用作Singer和Waiter的虚基类 12class Singer : virtual public Worker &#123; ... &#125;;class Waiter : public virtual Worker &#123; ... &#125;; 可以将SingingWaiter类定义为 1class SingingWaiter : pulic Singer, public Waiter &#123; ... &#125;; 这样，SingingWaiter对象将只包含 友元类： 当一个类B成为了另外一个类A的“朋友”时，那么类A的私有和保护的数据成员就可以被类B访问。我们就把类B叫做类A的友元。 友元类可以通过自己的方法来访问把它当做朋友的那个类的所有成员。但是我们应该注意的是，我们把类B设置成了类A的友元类，但是这并不会是类A成为类B的友元。说白了就是：甲愿意把甲的秘密告诉乙，但是乙不见得愿意把乙自己的秘密告诉甲。 声明友元类的方法其实很简单，只要我们在类A的成员列表中写下语句：friend class B;这样一来，类B就被声明成了类A的友元。注意，类B虽然是类A的友元，但是两者之间不存在继承关系。这也就是说，友元类和原来那个类之间并没有什么继承关系，也不存在包含或者是被包含的关系。]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArduPilot之代码概述]]></title>
    <url>%2F2017%2F06%2F16%2FArduPilot%E4%B9%8B%E4%BB%A3%E7%A0%81%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[代码调用关系可使用doxygen工具，cmake中使用doxygen，总体的代码结果图如下：具体可参考APM飞控浅析 ArduPilot编程库这些库是和Copter, Plane and Rover共享的，具体的库及功能可见原文。 核心库 AP_AHRS —— 使用DCM或扩展卡尔曼滤波姿态估计 AP_Common —— 所有草图和库所需要的核心包括 AP_math —— 各种数学函数尤其对向量操作有用 AC_PID —— PID控制器库 AP_InertialNav —— 惯性导航库，用于融合加速度计、gps和气压计的数据输入 AC_AttitudeControl —— 姿态控制库 AP_WPNav —— 航点导航库 AP_Motors —— 多轴和传统的直升机电机混合 RC_Channel —— 这个库将更多的转换为PWM输入/输出，将来自APM_RC的数据转换为内部单位，如角度 AP_HAL, AP_HAL_AVR, AP_HAL_PX4 —— 这库实现“硬件抽象层”，这向高级别代码提供了一个相同的接口，以便它可更容易地移植到不同的板 传感器库 AP_InertialSensor —— 读取陀螺和加速度计数据，执行校准和以标准单位（度/秒，米/秒），向主代码和其它库提供数据 AP_RangeFinder —— 声纳和红外距离传感器接口库 AP_Baro —— 气压计接口库 AP_GPS —— gps接口库 AP_Compass —— 3轴罗盘接口库 AP_OpticalFlow —— 光学流量传感器接口库 其他库 AP_Mount, AP_Camera, AP_Relay —— 摄像头安装控件库，相机的快门控制库 AP_Mission —— 从EEPROM存储/检索任务的命令 AP_Buffer —— 与惯性导航使用的简单FIFO缓冲区 姿态控制代码结构如图所示更新周期：400hz on Pixhawk, 100hz on APM2.x 顶层的flight-mode.cpp的“update_flight_mode()” 函数被调用。此函数检查车辆的飞行模式(如，“control_mode” 变量)，然后调用相应的\_run()函数(如，自稳模式的“stabilize_run”， 返回地面模式的“rtl_run” 等等)。\_run()函数能在相应的以control_\.cpp命名的文件里找到(如，control_stabilize.cpp, control_rtl.cpp等等)。 \_run函数是负责将用户的输入(如g.rc_1.control_in, g.rc_2.control_in等等)转换为倾斜角度，旋转速度，爬升率等适合这种飞行模式的值。举个例子，AltHold将用户的滚动和俯仰输入转换成倾斜角（单位：度），偏航输入被转换成旋转速度（度每秒），油门输入被转换为一个爬升率（以厘米/秒）。 \_run函数最后一件必须做的事，将这些期望的角度，速率等传给姿态控制和/或位置控制库(都在 AC_AttitudeControl文件夹)。 AC_AttitudeControl库提供5种可能的方式来控制车辆的姿态，最常见的3种描述如下： angle_ef_roll_pitch_rate_ef_yaw()：它接受一个地理坐标的俯仰角和翻滚角以及偏航率。举个例子，提供给这个函数的值为，俯仰角-1500、翻滚角-1000及偏航率500意味者使机器向左翻滚10度，向前俯仰15度以及向右旋转5度/秒。 angle_ef_roll_pitch_yaw()：它接受一个地理坐标的俯仰角和翻滚角以及偏航角。像上面一样，除了提供500的偏航角意味着向东北方向选择5度。 rate_bf_roll_pitch_yaw()：它接受地理坐标的俯仰速率和翻滚速率以及偏航速率。举个例子，roll = -1000, pitch = -1500, yaw = 500意味着向左边以10度/秒的速率翻转，向前以15度/秒的速率俯仰和绕z轴以5度/秒的速率旋转。 这些函数被调用之后是AC_AttitudeControl::rate_controller_run()函数被调用。这将来自上面列出方法的输出转换成翻滚，俯仰和偏航输入，然后通过set_roll, set_pitch, set_yaw and set_throttle发给AP_Motors库。 AC_PosControl库允许车辆的三维位置控制。通常情况下仅使用简单的Z轴（即高度控制）方法，因为更复杂的三维位置的飞行模式（即游荡）利用AC_WPNav库。在任何情况下，该库的一些常用的方法包括： set_alt_target_from_climb_rate()：这接受厘米/ 秒的爬升率和更新的绝对目标高度 set_pos_target()：此接受3D位置矢量，这是一个距离家里厘米的偏移。 如果AC_PosControl任何方法被调用，然后飞行模式代码也必须调用AC_PosControl::update_z_controller()方法。这将运行z轴位置控制PID回路和发送低电平油门级到AP_Motors库。如果有任何的XY轴的方法被调用，然后AC_PosControl :: update_xy_controller()必须被调用。 AP_Motors库拥有“电机混合”的代码。这个代码是负责把从AC_AttitudeControl和AC_PosControl库接收的滚转，俯仰，偏航和油门值转换成绝对马达的输出（即，PWM值）。因此，上级库将利用这些功能： set_roll(), set_pitch(), set_yaw()：接受-4500〜4500范围内的滚动，俯仰和偏航值。这些不是期望的角度，甚至速率而只是一个值。例如，set_roll(-4500)意味着尽可能快的左转。 set_throttle()：接受0〜1000的范围内绝对油门值， 0 =电机关闭，1000 =全油门。 对于不同的机型有不同的类(quad, Y6, traditional helicopter)，而且每一个类有“output_armed”函数，它是负责执行这些滚动，俯仰，偏航和油门值转换成PWM输出。此转换通常包括实施一个“稳定的补丁”，当输入请求是该机型的物理极限外它处理优先控制中的一个轴(如，对于四轴最大油门和最大侧倾是不可能的，因为一些电机必须小于另外一些电机才能导致角度倾斜)。在“output_armed”函数的底部，有到hal.rcout-&gt;write()函数的调用，其传递所需的PWM值到AP_HAL层。 AP_HAL库(硬件抽象层)为所有的板子提供一致的接口。尤其是hal.rc_out_write()函数将使从AP_Motors类收到指定的PWM出现相应的板的PWM引脚上。 添加新的参数参数可以是主代码的一部分，也可以是库的一部分。 将一个参数添加到主代码 在Parameters.h里添加新参数，注意数字是否超过该区域；不可将参数插入中间，会打乱已有的次序；有“deprecated” or “remove” 备注的参数不要使用； 声明变量，去掉“k_param_”前缀； 将变量声明添加到 Parameters.cpp的var_info表，@Param ~ @User 注释将作为地面站里的参数说明； 添加变量默认值到 config.h，现在可以在主代码里进行访问 g.my_new_parameter即可； 将参数添加到库 参数也可以添加到库，以AP_Compass库作为例子进行说明。 添加变量到Compass.h的类中，并在类定义之前定义初始值。 添加变量到Compass.cpp的var_info表中，包括@Param ~ @Increment 注释，注意数字部分比上一个大一。 123456// @Param: MY_NEW_P // @DisplayName: My New Library Parameter // @Description: The new library parameter description goes here // @Range: -32768 32767 // @User: Advanced AP_GROUPINFO("MY_NEW_P", 9, Compass, _my_new_lib_parameter, MY_NEW_PARAM_DEFAULT), 类内部可以使用_my_new_lib_parameter变量，由于是保护变量，类外使用需加上compass._my_new_lib_parameter。 如果这个类是新定义的，类名应该添加到 Parameters.cpp的var_info中 123// @Group: COMPASS_ // @Path: ../libraries/AP_Compass/Compass.cpp GOBJECT(compass, "COMPASS_", Compass), 添加一个新的飞行模式当自己想用新的机架时，或者创建新的飞行模式时，可以添加一个新的飞行模式，步骤可见原文。 在defines.h为新的飞行模式宏定义，并将NUM_MODES加1。 12345678910111213141516171819// Auto Pilot modes// ----------------#define STABILIZE 0 // hold level position#define ACRO 1 // rate control#define ALT_HOLD 2 // AUTO control#define AUTO 3 // AUTO control#define GUIDED 4 // AUTO control#define LOITER 5 // Hold a single location#define RTL 6 // AUTO control#define CIRCLE 7 // AUTO control#define LAND 9 // AUTO control#define OF_LOITER 10 // Hold a single location using optical flow sensor#define DRIFT 11 // DRIFT mode (Note: 12 is no longer used)#define SPORT 13 // earth frame rate control#define FLIP 14 // flip the vehicle on the roll axis#define AUTOTUNE 15 // autotune the vehicle's roll and pitch gains#define POSHOLD 16 // position hold with manual override#define NEWFLIGHTMODE 17 // new flight mode description#define NUM_MODES 18 创建control_草图，类似于control_stabilize.cpp，新文件必须含有_init() 函数和 _run() 函数。 1234567891011121314151617181920212223242526272829303132333435363738394041/// -*- tab-width: 4; Mode: C++; c-basic-offset: 4; indent-tabs-mode: nil -*-/* - control_newflightmode.cpp - init and run calls for new flight mode */// newflightmode_init - initialise flight modestatic bool newflightmode_init(bool ignore_checks)&#123; // do any required initialisation of the flight mode here // this code will be called whenever the operator switches into this mode // return true initialisation is successful, false if it fails // if false is returned here the vehicle will remain in the previous flight mode return true;&#125;// newflightmode_run - runs the main controller// will be called at 100hz or morestatic void newflightmode_run()&#123; // if not armed or throttle at zero, set throttle to zero and exit immediately if(!motors.armed() || g.rc_3.control_in &lt;= 0) &#123; attitude_control.relax_bf_rate_controller(); attitude_control.set_yaw_target_to_current_heading(); attitude_control.set_throttle_out(0, false); return; &#125; // convert pilot input into desired vehicle angles or rotation rates // g.rc_1.control_in : pilots roll input in the range -4500 ~ 4500 // g.rc_2.control_in : pilot pitch input in the range -4500 ~ 4500 // g.rc_3.control_in : pilot's throttle input in the range 0 ~ 1000 // g.rc_4.control_in : pilot's yaw input in the range -4500 ~ 4500 // call one of attitude controller's attitude control functions like // attitude_control.angle_ef_roll_pitch_rate_yaw(roll angle, pitch angle, yaw rate); // call position controller's z-axis controller or simply pass through throttle // attitude_control.set_throttle_out(desired throttle, true);&#125; 在 Copter.h中声明_init() 和 _run()函数。 在flight_mode.cpp的set_mode()函数中添加一个case来调用上面的初始化函数。 12345678910111213switch(mode) &#123; case ACRO: #if FRAME_CONFIG == HELI_FRAME success = heli_acro_init(ignore_checks); #else success = acro_init(ignore_checks); #endif break; case NEWFLIGHTMODE: success = newflightmode_init(ignore_checks); break; &#125; 在flight_mode.cpp的update_flight_mode()函数中添加一个case来调用上面的_run函数。 123456789101112131415static void update_flight_mode()&#123; switch (control_mode) &#123; case ACRO: #if FRAME_CONFIG == HELI_FRAME heli_acro_run(); #else acro_run(); #endif break; case NEWFLIGHTMODE: success = newflightmode_run(); break; &#125;&#125; 在 flight_mode.cpp的print_flight_mode()函数里添加一个case来打印出飞行模式。 12345678910tatic voidprint_flight_mode(AP_HAL::BetterStream *port, uint8_t mode)&#123; switch (mode) &#123; case STABILIZE: port-&gt;print_P(PSTR("STABILIZE")); break; case NEWFLIGHTMODE: port-&gt;print_P(PSTR("NEWFLIGHTMODE")); break; 在Parameters.cpp中添加新的飞行模式到FLTMODE1 ~ FLTMODE6参数的@values列表中。 12345678910111213// @Param: FLTMODE1 // @DisplayName: Flight Mode 1 // @Description: Flight mode when Channel 5 pwm is 1230, &lt;= 1360 // @Values: 0:Stabilize,1:Acro,2:AltHold,3:Auto,4:Guided,5:Loiter,6:RTL,7:Circle,8:Position,9:Land,10:OF_Loiter,11:ToyA,12:ToyM,13:Sport,17:NewFlightMode // @User: Standard GSCALAR(flight_mode1, "FLTMODE1", FLIGHT_MODE_1), // @Param: FLTMODE2 // @DisplayName: Flight Mode 2 // @Description: Flight mode when Channel 5 pwm is &gt;1230, &lt;= 1360 // @Values: 0:Stabilize,1:Acro,2:AltHold,3:Auto,4:Guided,5:Loiter,6:RTL,7:Circle,8:Position,9:Land,10:OF_Loiter,11:ToyA,12:ToyM,13:Sport,17:NewFlightMode // @User: Standard GSCALAR(flight_mode2, "FLTMODE2", FLIGHT_MODE_2), 如果您希望在新的飞行模式出现在任务规划的HUD和飞行模式设置，可以在Mission Planner’s Issue List提出一个请求。 调度代码间歇运行 使用调度程序：添加新函数到ArduCopter.cpp里的scheduler_tasks数组。 123456789101112131415161718static const AP_Scheduler::Task scheduler_tasks[] PROGMEM = &#123; &#123; update_GPS, 2, 900 &#125;, &#123; update_nav_mode, 1, 400 &#125;, &#123; medium_loop, 2, 700 &#125;, &#123; update_altitude, 10, 1000 &#125;, &#123; fifty_hz_loop, 2, 950 &#125;, &#123; run_nav_updates, 10, 800 &#125;, &#123; slow_loop, 10, 500 &#125;, &#123; gcs_check_input, 2, 700 &#125;, &#123; gcs_send_heartbeat, 100, 700 &#125;, &#123; gcs_data_stream_send, 2, 1500 &#125;, &#123; gcs_send_deferred, 2, 1200 &#125;, &#123; compass_accumulate, 2, 700 &#125;, &#123; barometer_accumulate, 2, 900 &#125;, &#123; super_slow_loop, 100, 1100 &#125;, &#123; my_new_function, 10, 200 &#125;, &#123; perf_update, 1000, 500 &#125;&#125;; 第一栏为函数名称，第二栏为一个以2.5ms为单位的数字，如1代表400hz，8代表50hz，第三栏为函数期待消耗多少毫秒。 运行代码为一个已有循环的一部分：添加到固有函数，调度频率比较高： fast_loop : runs at 100hz on APM2, 400hz on Pixhawk fifty_hz_loop : runs at 50hz ten_hz_logging_loop: runs at 10hz three_hz_loop: runs at 3.3hz &gt;one_hz_loop : runs at 1hz 假设要添加新代码，使它以10hz的频率调度运行，那么可以将代码加入ten_hz_logging_loop()函数中。 1234567891011121314151617181920// ten_hz_logging_loop// should be run at 10hzstatic void ten_hz_logging_loop()&#123; if (g.log_bitmask &amp; MASK_LOG_ATTITUDE_MED) &#123; Log_Write_Attitude(); &#125; if (g.log_bitmask &amp; MASK_LOG_RCIN) &#123; DataFlash.Log_Write_RCIN(); &#125; if (g.log_bitmask &amp; MASK_LOG_RCOUT) &#123; DataFlash.Log_Write_RCOUT(); &#125; if ((g.log_bitmask &amp; MASK_LOG_NTUN) &amp;&amp; mode_requires_GPS(control_mode)) &#123; Log_Write_Nav_Tuning(); &#125; // your new function call here my_new_function();&#125; 添加一个新的MAVLink消息地面站之间传递数据和命令使用的是MAVLink协议，参考已有的MAVLink messages。 makefie分析对于make语法不是很熟悉的可以参考make manual/ 详解Makefile 函数的语法与使用/跟我一起写makefile。 【make中命令行前面加上减号】就是，忽略当前此行命令执行时候所遇到的错误。而如果不忽略，make在执行命令的时候，如果遇到error，会退出执行的，加上减号的目的，是即便此行命令执行中出错，比如删除一个不存在的文件等，那么也不要管，继续执行make。【make中命令行前面加上at符号@】就是，在make执行时候，输出的信息中，不要显示此行命令。而正常情况下，make执行过程中，都是会显示其所执行的任何的命令的。如果你不想要显示某行的命令，那么就在其前面加上@符号即可。【FOO ?= bar】只有当FOO变量未定义是，才可以赋值。【=/: =/::=】=为可递归等于，另外两种则不可以。【+ =/！ = 】附加在已有的变量上，后者可以执行命令并将结果赋给左边变量。更多参考：http://blog.csdn.net/crylearner/article/details/17271195 确定MK_DIR进入ArduCopter里的Makefile文件可知，它直接调用了../mk/apk.mk文件。在apk.mk文件里，第一行代码是返回系统的类型。 123456789101112# =&gt; The uname command with no parameters should tell you the operating system name. I'd use that, then make conditionals based on the return value.# =&gt; ExampleUNAME := $(shell uname)ifeq ($(UNAME), Linux)# do something Linux-yendififeq ($(UNAME), Solaris)# do something Solaris-yendif 根据系统的类型确定不同的工作目录MK_DIR，findstring的用法如下： 123456$(findstring find,in)# =&gt; Searches in for an occurrence of find. If it occurs, the value is find; otherwise, the value is empty. You can use this function in a conditional to test for the presence of a specific substring in a given string. Thus, the two examples,$(findstring a,a b c)$(findstring a,b c)# =&gt; produce the values ‘a’ and ‘’ (the empty string), respectively. 其中的cygpath用于转换Unix和Windows的格式路径，选项信息如下： 12-m, --mixed like --windows, but with regular slashes (C:/WINNT)-w, --windows print Windows form of NAMEs (C:\WINNT) 根据gnu make定义，gnu make 会自动将所有读取的makefile路径都会加入到MAKEFILE_LIST变量中，而且是按照读取的先后顺序添加。例如： 123456789101112131415#If a makefile named Makefile has this content:name1 := $(lastword $(MAKEFILE_LIST))include inc.mkname2 := $(lastword $(MAKEFILE_LIST))all: @echo name1 = $(name1) @echo name2 = $(name2)#then you would expect to see this output:#name1 = Makefile#name2 = inc.mk 格式：$(patsubst ,,)名称：模式字符串替换函数——patsubst功能：查找中的单词（单词以“空格”、“Tab”或“回车”“换行”分隔）是否符合模式，如果匹配的话，则以替换。这里，可以包括通配符“%”，表示任意长度的字串。如果中也包含“%”，那么，中的这个“%”将是中的那个“%”所代表的字串。（可以用“\”来转义，以“\%”来表示真实含义的“%”字符）返回：函数返回被替换过后的字符串。示例：$(patsubst %.c,%.o,x.c.c bar.c)把字串“x.c.c bar.c”符合模式[%.c]的单词替换成[%.o]，返回结果是“x.c.o bar.o”而dir是提取路径 12$(dir src/foo.c hacks)#produces the result ‘src/ ./’. 所以$(patsubst %/,%,$(dir $(lastword $(MAKEFILE_LIST))))返回了当前的mk路径，到这里也就得出了 MK_DIR 信息。 环境变量添加环境变量environ.mk，进入分析变量。GIT_VERSION := $(shell git rev-parse HEAD | cut -c1-8)为提取commit号的前八个字符作为版本号。SRCROOT := $(realpath $(dir $(firstword $(MAKEFILE_LIST))))通过判断是否有libraries来获取当前make的真实路径，不存在则返回为空。查找SKETCHBOOK的位置： wildcard通配符，如：列出该目录下所有的C文件为$(wildcard *.c)。 此位置为该项目的根目录。 如果是在win平台，转换为win格式的路径。 提示：关于make的一些控制函数如error和warning。根据源文件路径判断SKETCH名称：SKETCH:=$(lastword $(subst /, ,$(SRCROOT)))，其中subst是将源文件路径中所有的/替换为空格。建立BUILDROOT目录：根据编译目标$(MAKECMDGOALS)建立相关目录，如果编译目标不匹配，建立临时目录。根据编译参数确定HAL_BOARD类型。 添加configure.mk如果编译参数是configure，则添加。 help目标选项直接显示help的相关信息。 添加公共编译组件 target.mk：编译目标，默认default为help。foreach语法及使用：USED_BOARDS := $(foreach board,$(BOARDS), $(findstring $(board), $(MAKECMDGOALS)))。使用foreach/eval/define/call更加快速的定义了目标。.PHONY伪目标etags。添加modules.mk（进行模块更新检查; cd $(dirname “$0”)为进入执行命令的目录；shell里-d为目录，-f为文件，更多；set -x是交互形式执行脚本，告诉你脚本做了些什么；）/mavgen.mk。 sketch_sources.mk：确定SRCSUFFIXES文件后缀；判断编译目录MAKE_INC是否为空；addprefix为添加前缀；SKETCHSRCS为编译目录的cpp文件；SKETCHCPP为编译目录的SKETCH.cpp文件；SKETCHOBJS为build目录里的cpp文件然后替换为.o文件；LIBRARIES的值赋给LIBTOKENS，匹配板子加入AP_HAL_PX4的库；更新包含sketchbook的各种库及文件，其中notdir为去掉目录仅留名字；使用’FORCE’和’.PHONY : clean’效果相同。使用’.PHONY’更加明确高效，但不是所有的’make’都支持；这样许多makefile中使用’FORCE’；生成build目录并建立make.flags文件；建立公共规则头文件，$@表示规则目标名字，dir为提取文件目录。 编译选项判断如果不为clean，则继续。 单板配置根据HAL_BOARD选择配置。 配置PX4如果上一步为PX4，则进行配置。 添加find_tools.mk：寻找编译工具，使用FIND_TOOL =$(firstword $(wildcard $(addsuffix /$(1),$(TOOLPATH))))快速查找；使用CCACHE如果安装了的话；查找awk。 添加px4_targets.mk：确定PX4FIRMWARE_DIRECTORY/NUTTX_ROOT/NUTTX_SRC/PX4NUTTX_DIRECTORY/UAVCAN_DIRECTORY等路径；获取NUTTX_GIT_VERSION及PX4_GIT_VERSION版本；添加EXTRAFLAGS；更新PX4_V2_CONFIG_FILE配置文件；定义SKETCHFLAGS/WARNFLAGS/OPTFLAGS，其中-D表示为define，-I为添加库；确定PYTHONPATH路径；定义PX4_MAKE及PX4_MAKE_ARCHIVES,有几个知识点，The ‘-n’, ‘-t’, and ‘-q’ options do not affect recipe lines that begin with ‘+’ characters or contain the strings ‘$(MAKE)’ or ‘${MAKE}’, it does not apply if the MAKE variable is referenced through expansion of another variable. In the latter case you must use the ‘+’ token to get these special effects.，这里包含了编译PX4原生代码的$(PX4_ROOT)/Makefile.make， $(MAKE) -C表示进入指定文件夹执行；添加HASHADDER_FLAGS；生成module_mk；最后建立px4的相关目标，如px4-v2，注意：px4-v2的依赖条件中包含了$(SKETCHCPP)，从这里调用该工程下的源文件；.NOTPARALLEL新语法：Makefile中，如果出现目标“.NOPARALLEL”，则所有命令按照串行方式执行，即使存在make的命令行参数“-j”。但在递归调用的字make进程中，命令可以并行执行。此目标不应该有依赖文件，所有出现的依赖文件将被忽略。 上一步中涉及到了config_px4fmu-v2_APM.mk；在这里又调用了px4_common.mk，这是一个很重要的东西；如定义了ROMFS_ROOT，定义了BUILTIN_COMMANDS，其中strip为去除空格； px4原生代码编译想要了解更详细的px4原生代码编译，还的看看$(PX4_ROOT)/Makefile.make，这个makefile是由cmake产生的；大概的框架可以查看根目录下makefiles文件夹里的README.txt文件。 程序入口主函数我们看源代码的时候，特别喜欢从main函数开始，顺着思路开始往下理。下面我就以ArduCopter工程里的px4-v2编译目标为例子，一步一步剖析main函数。总的来说，这里的main函数就是ArduCopter.cpp里的AP_HAL_MAIN_CALLBACKS(&amp;copter);，它实际上是一个宏定义，传进来的参数为类对象的引用，通过在AP_HAL_Main.h里的定义可知原型为： 1234567#define AP_HAL_MAIN_CALLBACKS(CALLBACKS) extern "C" &#123; \ int AP_MAIN(int argc, char* const argv[]); \ int AP_MAIN(int argc, char* const argv[]) &#123; \ hal.run(argc, argv, CALLBACKS); \ return 0; \ &#125; \ &#125; 而这里的AP_MAIN也是一个宏，如下： 123#if CONFIG_HAL_BOARD == HAL_BOARD_PX4 || CONFIG_HAL_BOARD == HAL_BOARD_VRBRAIN#define AP_MAIN __EXPORT ArduPilot_main#endif 所以它实际上是这样的： 1234567#define AP_HAL_MAIN_CALLBACKS(CALLBACKS) extern "C" &#123; \ int __EXPORT ArduPilot_main(int argc, char* const argv[]); \ int __EXPORT ArduPilot_main(int argc, char* const argv[]) &#123; \ hal.run(argc, argv, CALLBACKS); \ return 0; \ &#125; \ &#125; 将这个宏替换到ArduCopter.cpp里的AP_HAL_MAIN_CALLBACKS(&amp;copter);它就变成了： 12345int __EXPORT ArduPilot_main(int argc, char* const argv[]);int __EXPORT ArduPilot_main(int argc, char* const argv[]) &#123; hal.run(argc, argv, &amp;copter); return 0; &#125; 因此实际上这个工程的main函数就是ArduCopter.cpp里的ArduPilot_main函数。在这个main函数所在的CPP文件创建了不同的线程以供调用。那么这里可能又牵扯到了一个问题，ArduPilot_main函数又是怎么调用的呢？如果像以前我们经常使用的单片机裸机系统，入口函数就是程序中函数名为main的函数，但是这个工程里边名字不叫main，而是ArduPilot_main，所以这个也不像裸机系统那样去运行ArduPilot_main那么简单。区别在于这是跑的Nuttx操作系统，这是一个类Unix的操作系统，它的初始化过程是由脚本去完成的。注意一个重要的词——脚本，如果你对Nuttx的启动过程不是很熟悉，可以查看我先前写的一些文章。而在这里需要注意两个脚本，一个是ardupilot/mk/PX4/ROMFS/init.d里的rcS，另一个是rc.APM，这个脚本在rcS里得到了调用，也就是说，rcS就是为Nuttx的启动文件。那么到底调用ArduPilot_main的地方在哪里呢？查看rc.APM的最低端： 1234567echo Starting ArduPilot $deviceA $deviceC $deviceDif ArduPilot -d $deviceA -d2 $deviceC -d3 $deviceD startthen echo ArduPilot started OKelse sh /etc/init.d/rc.errorfi 其中ArduPilot是一个内嵌的应用程序，由编译生成的builtin_commands.c可知，这个应用程序的入口地址就是ArduPilot_main。其实也只有这个ArduPilot_main应用是APM编写的，其余的应用基本上都是px4底层自带的。 12&#123;"ArduPilot", SCHED_PRIORITY_DEFAULT, 4096, ArduPilot_main&#125;,&#123;"px4flow", SCHED_PRIORITY_DEFAULT, CONFIG_PTHREAD_STACK_DEFAULT, px4flow_main&#125;, 这样的命令有很多，在rcS里就开始调用的比如rgbled就是的。至于这些内置的命令是怎么生成的，就要了解PX4原生的编译过程了，由上一节的介绍，查看px4_targes.mk。 1PX4_MAKE = $(v)+ GIT_SUBMODULES_ARE_EVIL=1 ARDUPILOT_BUILD=1 $(MAKE) -C $(SKETCHBOOK) -f $(PX4_ROOT)/Makefile.make EXTRADEFINES="$(SKETCHFLAGS) $(WARNFLAGS) $(OPTFLAGS) "'$(EXTRAFLAGS)' APM_MODULE_DIR=$(SKETCHBOOK) SKETCHBOOK=$(SKETCHBOOK) CCACHE=$(CCACHE) PX4_ROOT=$(PX4_ROOT) NUTTX_SRC=$(NUTTX_SRC) MAXOPTIMIZATION="-Os" UAVCAN_DIR=$(UAVCAN_DIR) 其中-f $(PX4_ROOT)/Makefile.make显示了makefile使用了PX4项目根目录的Makefile.make文件，拜读这里即可查出真相，真相在根目录下makefiles文件夹里的firmware.mk里。其实px4的代码使用的是Cmake，所以通过查看根目录下的CMakeLists.txt可知，真正产生builtin_commands.c的是px4_impl_nuttx.cmake里的px4_nuttx_generate_builtin_commands函数。同理，nuttx操作系统的ROMFS是由px4_nuttx_add_romfs函数产生的。 接着继续分析main函数里的一些特征及其所做的事情。由上面分析可知，main函数及为： 1234int __EXPORT ArduPilot_main(int argc, char* const argv[]) &#123; hal.run(argc, argv, &amp;copter); return 0; &#125; 其中hal定义为const AP_HAL::HAL&amp; hal = AP_HAL::get_HAL();，而： 12345678910const AP_HAL::HAL&amp; AP_HAL::get_HAL() &#123; static const HAL_PX4 hal_px4; return hal_px4;&#125;class HAL_PX4 : public AP_HAL::HAL &#123;public: HAL_PX4(); void run(int argc, char* const argv[], Callbacks* callbacks) const override;&#125;; 故hal.run函数即为HAL_PX4里面的run方法，这个main函数主要运行的是这个方法。这个方法能在HAL_PX4_Class.cpp中找到。在这个方法中有： 123456daemon_task = px4_task_spawn_cmd(SKETCHNAME, SCHED_FIFO, APM_MAIN_PRIORITY, APM_MAIN_THREAD_STACK_SIZE, main_loop, NULL); 所以这里又调用了main_loop函数，在main_loop函数中，主要分析两点： 1234g_callbacks-&gt;setup();while (!_px4_thread_should_exit) &#123;g_callbacks-&gt;loop();&#125; setup()函数在板子启动的时候被调用一次，它实际的调用来自每块板子的HAL，所有main函数是在HAL里的，其后就是loop()函数的调用，sketch的主要工作体现在loop()函数里，注意这两个函数只是冰山一角。这段话摘自理解example sketch代码。setup、loop函数可以在ArduCopter.cpp中分别找到，其中setup函数里有scheduler.init(&amp;scheduler_tasks[0], ARRAY_SIZE(scheduler_tasks));，这样在这个应用函数里又启动了调度任务: 1234567891011121314const AP_Scheduler::Task Copter::scheduler_tasks[] = &#123; SCHED_TASK(rc_loop, 100, 130), SCHED_TASK(throttle_loop, 50, 75), SCHED_TASK(update_GPS, 50, 200),#if OPTFLOW == ENABLED SCHED_TASK(update_optical_flow, 200, 160),#endif SCHED_TASK(update_batt_compass, 10, 120), SCHED_TASK(read_aux_switches, 10, 50), SCHED_TASK(arm_motors_check, 10, 50), SCHED_TASK(auto_disarm_check, 10, 50), SCHED_TASK(auto_trim, 10, 75), SCHED_TASK(update_altitude, 10, 140), SCHED_TASK(run_nav_updates, 50, 100), 所以apm的源码就是在px4的原生代码上以一个应用的接口加入了自己的调度任务，总的来说就是在px4上加了自己的应用。而在loop函数里开展了主要的循环fast_loop函数，如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344// Main loop - 400hzvoid Copter::fast_loop()&#123; // IMU DCM Algorithm // -------------------- read_AHRS(); // run low level rate controllers that only require IMU data attitude_control.rate_controller_run(); #if FRAME_CONFIG == HELI_FRAME update_heli_control_dynamics();#endif //HELI_FRAME // send outputs to the motors library motors_output(); // Inertial Nav // -------------------- read_inertia(); // check if ekf has reset target heading check_ekf_yaw_reset(); // run the attitude controllers update_flight_mode(); // update home from EKF if necessary update_home_from_EKF(); // check if we've landed or crashed update_land_and_crash_detectors();#if MOUNT == ENABLED // camera mount's fast update camera_mount.update_fast();#endif // log sensor health if (should_log(MASK_LOG_ANY)) &#123; Log_Sensor_Health(); &#125;&#125; 在这里边进行姿态解算，PID控制等等，那么分析到这里我想完过飞行器的同学就大致清楚了。在这个工程里有一个重要的类叫Copter，大部分函数都是该类的方法，如void Copter::arm_motors_check()，以后用的一些全局变量基本上都属于这个类里面的。 下面看一下一些简单的应用，以电机解锁为例子，玩过飞行器的同胞就知道，油门拉杆按右下角几秒就可以解锁，一般都是这样设置的，看看代码都是怎么实现的：首先解锁的函数为arm_motors_check，调用次数为10hz。代码很简单，从中可以看出，2s后如果检查通过就可以解锁，当飞行器不属于手动控制模式时，拉杆打左下角2s即可上锁。 例程学习对于ardupilot代码的学习，由于工程比较庞大，建议先对库里边的例程进行熟悉，以达到熟悉整个工程的目的。下面将AP_HAL_PX4的例程作为一个讲解的示范。 首先编译工程，进入例程目录ardupilot/libraries/AP_HAL_PX4/examples/simple，然后进行编译下载make px4-v2-upload即可。 连接USB，打开串口界面，使用命令行参考这里，可以看到有输出”hello world”，然后是“*”循环输出。如下图 查看源代码如下，很容易理解。AP_HAL_MAIN()为宏替换，替换完成后即可知道是main函数，启动该main函数的应用程序为ArduPilot，此应用在rc.APM脚本将要完成时启动，如下。 1234567891011void setup() &#123; hal.console-&gt;println("hello world");&#125;void loop()&#123; hal.scheduler-&gt;delay(1000); hal.console-&gt;println("*");&#125;AP_HAL_MAIN(); 12345678#脚本部分echo Starting ArduPilot $deviceA $deviceC $deviceDif ArduPilot -d $deviceA -d2 $deviceC -d3 $deviceD startthen echo ArduPilot started OKelse sh /etc/init.d/rc.errorfi 多次调试发现，hal.console-&gt;println或者hal.console-&gt;printf及cliSerial-&gt;printf函数为usb串口输出，即hal.console为控制台输出，而单独的printf函数为串口5输出。由Copter::setup()函数的cliSerial = hal.console;可知，cliSerial为hal.console的别名。 编译library例程的时候出现如下类似问题： 12&gt; make[3]: *** No rule to make target '/home/nephne/src/ardupilot/libraries/AP_Compass/Compass.h', needed by '/home/nephne/src/ardupilot/libraries/AP_AHRS/examples/AHRS_Test/AHRS_Test.cpp.o'. Stop.&gt; 解决办法为删除AHRS_Test.cpp.d文件重新编译。 参看文章：官网/串级pid]]></content>
      <categories>
        <category>飞控</category>
      </categories>
      <tags>
        <tag>ArduPilot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇顶科技求职感悟]]></title>
    <url>%2F2017%2F06%2F16%2F%E6%B1%87%E9%A1%B6%E7%A7%91%E6%8A%80%E6%B1%82%E8%81%8C%E6%84%9F%E6%82%9F%2F</url>
    <content type="text"><![CDATA[大家好，非常高兴能够在这里跟大家分享我的求职经历，希望能够对大家有所启发和帮助。 说到汇顶科技肯定很多人要问了，这是个什么公司？怎么从来没听过。借此我想为我们公司做个小广告，欢迎志同道合的小伙伴们。 公司简介指纹识别哪家强，中国深圳找汇顶——汇顶科技成立于2002年，作为全球领先的人机交互技术与解决方案提供商，目前已在包括手机、平板电脑和可穿戴产品在内的智能移动终端人机交互技术领域构筑了领先优势。陆续推出拥有自主知识产权的单层多点触控技术、基于电容检测的近场通信技术、具有蓝宝石面板的指纹识别技术及触控与指纹识别一体化的 IFSTM技术。目前，产品和解决方案广泛应用在华为、中兴、联想、OPPO、VIVO、魅族、三星显示、JDI、诺基亚、东芝、松下等国际国内知名终端 品牌，服务全球数亿人群。2016年应届毕业生薪酬待遇：本科月薪8000元，年薪14万起；硕士月薪10000元，年薪17万起；博士月薪18000元，年薪30万起。 汇顶大事件2014年11月魅族MX 4 Pro发布，魅族MX4 Pro是全球首款采用前置蓝宝石按压式解锁方案的安卓手机，该技术完全来自一家深圳的本土IC企业——深圳市汇顶科技股份有限公司。2015年10月27日，乐视在北京正式发布新一代智能手机乐1S，此次乐视采用的全球首款镜面玻璃指纹识别解决方案由汇顶科技提供。由于乐视在大陆的人气直逼小米，这也是继小米、华为之后，汇顶再获陆系一线品牌手机订单。美国纽约当地时间2015年11月10日，全球人机交互解决方案领导者汇顶科技凭借出色的设计和领先的技术斩获国际消费电子（CES）两项嵌入式技术类别大奖，它们分别是IFS（Invisible Fingerprint Sensor）和基于触摸屏的近场通信技术。求职准备是一个长期的过程，在确认自己是就业、考研还出国深造开始就要准备，凡事预则立，不预则废。在确认自己是就业的同时，最好能弄清楚自己的研究方向，一个自己感兴趣的方向，并坚定自己的目标，而不要在找工作的时候纠结是要找什么样的工作，男怕入错行是有道理的。我研究的方向是嵌入式软件开发。 下面我想从大学项目积累、基础理论知识和面试经历这三个方面谈谈我的求职过程。 1）大学项目积累我大一下学期加入的嵌入式实验室，担任学习部负责人，项目经验是我的一大优势。在刚进入大学的时候，就有过这样的迷茫，是加入学生会还是创新实验室？于是在图书馆呆了一段时间，在这期间，了解到了物联网、云计算的前沿高科技，学院参观实验室活动中一次偶然的机会加入了自己喜欢的嵌入式实验室，从那开始坚定自己的嵌入式目标，探索物联网里的未知世界。在实验室创新团队的这些日子，让我体会到了什么是踏踏实实做人，认认真真做事。实验室学习过程从基础知识开始，如焊接电路板，基本仪器仪表的使用，到常见嵌入式电路原理图、两层电路印刷板的制作，到常见单片机嵌入式软件编程，如51、PIC、STM32、Kineties 60等，再到独立DIY一些创新型电子产品，然后加入团队项目中，为团队贡献自己的一份力量，最后能够成为飞思卡尔智能车项目负责人，带领大家一起学习进步。我做过很多的项目，写在简历上就能看得出，每个月我都有事情要去做，几乎没有闲下来，找到工作后我还在研究无人机，这也使我能充实的度完这个大学。相比于为了找工作，我更喜欢这些富有挑战性的项目，我可以快乐的沉浸其中。对于项目我的看法是，单纯找工作而言，项目并不在多，而在精，在于你对这个项目有没有研究的心态，在面试的过程中你能把你做过的项目生动地给面试官上一堂课，让面试官认可你，觉得你比别人确实不一样就可以了，如果你有较多的项目经验，而且都基础很扎实，那么你就会更受欢迎了。 2）基础理论知识找工作的大概流程是这样的，网申—宣讲会—笔试—面试，面试又分为各种形式，每个公司都有自己的不同之处，详情请上看准网搜该公司的面经，在这个过程中，基础理论知识在笔试和大部分公司的一面中占有非常重要的作用，直接影响你对面试官的第一印象，所以基础理论知识非常重要！原因很简单，就像中国古往今来的考试一样，笔试成绩好，就说明学得比较扎实，对公司而言可以花更少的时间金钱去培训你。一般来说一面大多是基础面，会对笔试过程中出现的问题再次进行询问，所以面试前最好能把题再做一遍，一面中还会有白纸编程，对你编程能力的一个实际考察，毕竟这样看起来更加真实。那么怎么去准备这个基础知识呢？如果你还处于大一、大二的阶段，建议你认真听好每一堂课，跟着老师走或者走到老师前面是没错的，大三的你就要开始去巩固扩展自己的基础知识了，大概有这么一些，C/C++语言：可以看《C与指针》、《C专家编程》、《Linux C编程》、《C++ Primer》及《程序员面试金典》等，这些书都讲得很基础，但很全面，毕竟大公司笔试题都是很全面的。这类型的题在笔试时普遍喜欢出陷阱题或比较偏的题，建议多去刷题，如牛客网，这样你的笔试面试会如鱼得水。数据结构：主要考察链表、栈、队列、树、字符串、查找、排序算法。一般在一面时通过这些基本算法间接的考察你的编码能力咯，这些算法还得弄熟了，建议还是多刷题实践。可以看《编程之美》、《剑指offer》等。如果是去互联网相关的企业的话，还得深入了解操作系统、计算机网络、数据库，可以去看下该公司往年的笔试面试题，找出该公司考察的重点。 3）面试经历我清楚地我们实验室指导老师郑斌老师说过的一句话，如果你没有面试过50家企业，就不要说自己找不到好工作。头一两次的面试可能会遇到挫折，这是在所难免的，一定要保持一个良好的心态，你可能会表达地不够流利、全面，礼貌礼仪不到位，但通过不断的总结自己，发现自己的缺点不足并及时改正，正所谓缺啥补啥，越挫越勇，通过别人通过面试可以发现更好的自己，只要坚定自己的目标，总能找到合适的好的工作。今年的工作从8月份开始就出现了内推，那时的我还在做项目，没有好好把握这个机会，有的公司没有内推，比如联发科，内推成功可以免笔试直接进入面试环节，9月份的时候，就陆陆续续的有公司过来校招了，这些消息的得来可以查看海投网、宣讲会网及学校发布的一些消息，地点可以选择长理、湖大、中南或者其它省份的城市，一般比较大的公司都在湖大中南那边，或者有的都不到湖南来招，比如大疆，这个时候如果是自己特别喜欢的公司就可以去试一下了。9月份我面试过的公司有云顶（无人机新型公司）、深圳瑞昱半导体、深信服，云顶是一家新成立的公司，面试主要问项目，因为我做过四轴飞行器，大部分都是问的这个方面的，瑞昱面试重基础，会对简历上面的东西问的比较深入，我写了C和linux，所以问的东西偏向这人方面，这里要注意的是，简历上写的东西要是自己非常熟悉的，千万别给自己挖坑，他们会有一千种办法让你很难堪的，深信服笔试刷了好多人，一面面基础知识，面的有点广，涉及计算机网络、操作系统，他会根据你的回答在你的面试环节本上打勾，想去深信服的要做好这方面的准备。 10月份的公司都到10号左右去了，趁着国庆这段时间我又好好的把基础知识复习巩固加强了一遍，因为我之前花太多时间在项目了，这确实是一个很好的补充能量的时机，毕竟通过几次面试也发现了自己具体哪些方面需要加强。10月份的公司我都比较顺利的，面试过的公司有广州海格、友讯达（后得通知被录用但我已签约）、汇顶、联发科（笔试通过但当时正面试汇顶错过它的面试）。这些公司都招嵌入式开发，宣讲会都在湖大中南，但10月份嵌入式里汇顶和联发科是比较财大气粗的了。汇顶笔试考到了数电模电、单片机汇编，主要汇顶不允许霸面，所以想进汇顶笔试必须得过，汇顶的面试分为3面：初试、复试、主管面、最后HR面签约（走到这一步就定了，除非自己不想去），一天之内就可以签约。初试是一个面试官，我的笔试成绩偏高，问我了上一天笔试的编程题，如一题里同时用到了结构体内存对齐与联合体，对环链表的判断，这里用到了快、慢指针。然后问了我简历上提到的三个项目，这里花了大部分的面试时间，主要是我讲，其实如果能在面试过程中引导面试官那是最好的了。顺利通过初试，到复试的人已经没几个了，这次面试是两个面试官，所以又重新做了一遍自我介绍，注意自我介绍时要把握好时间，突出重点，一般讲自己的技能特长，另外一个面试官一上来就要我白纸编程，这个还比较简单，如怎么快速遍历的找链表的中间指针，字符串的拷贝，排序算法，然后问了C语言的一些东西，如为什么要内存对齐，在一个项目中方案的选择，如单片机的晶振频率，汇顶以往的面试都有智力题，这次也不例外，我的是牛吃草的问题，这些问题网上都能搜到，最后因为岗位需要，对我的交流沟通能力进行了情景考察，如团队成员任务出现分歧该怎么办，这个时候面试官可能会故意刁难你，只要有自己的想法就好。初试复试都有面1个小时左右，面完后在外面大概等了15分钟，通知进去主管面，主要问的是性格、家庭方面的一些问题，另外又给我出了一道智力题，是一个房间里四盏灯对应开关的问题，还要我用英语跟她作对话，怎么举办一次实验室招新等，最后问了我为什么没去大疆，我说明了原因并表示大疆是我的职业目标。最后就是签约了，汇顶都是明码标价的，HR说明了薪酬情况，完成后就可以准备自己的毕业旅行了。后得知我们部门在长沙就招了4个人，真是感觉有惊无险。通过这些面试，我的一个很深的体会就是不要打没有准备的仗，去了就要对自己有信心，尽努力做好各方面的准备，只要目标坚定，勤恳付出，没有做不到的事。 总结以上是我对这次求职过程的记载，总而言之，基础理论知识很重要，项目是个加分项，面试有技巧，多多去总结，要表现更加出色的自己。最后希望大家好好准备，大展宏图，更创辉煌！]]></content>
      <categories>
        <category>感悟</category>
      </categories>
      <tags>
        <tag>汇顶科技</tag>
        <tag>求职</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Moveit在ROS Kinetic上的搭建与调试]]></title>
    <url>%2F2017%2F06%2F16%2FMoveit%E5%9C%A8ROS-Kinetic%E4%B8%8A%E7%9A%84%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[环境搭建参考官网，注意这里需要采用Ubuntu15.10或者16.04。具体命令简写如下： 123456789sudo sh -c 'echo "deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main" &gt; /etc/apt/sources.list.d/ros-latest.list'sudo apt-key adv --keyserver hkp://ha.pool.sks-keyservers.net:80 --recv-key 421C365BD9FF1F717815A3895523BAEEB01FA116sudo apt-get updatesudo apt-get install ros-kinetic-desktop-fullsudo rosdep initrosdep updateecho "source /opt/ros/kinetic/setup.bash" &gt;&gt; ~/.bashrcsource ~/.bashrcsudo apt-get install python-rosinstall 基础ROS操作教程开始基本操作。 基础环境首先是配置ROS的工作环境，创建新的工作空间。 12rosws init ~/kinetic_workspace /opt/ros/kinetic#如果rosws命令未找到，使用sudo apt-get install python-rosinstall命令即可 为new package创建目录。 1234mkdir ~/kinetic_workspace/sandboxrosws set ~/kinetic_workspace/sandboxsource ~/kinetic_workspace/setup.bash#建议将上一行命令加至~/.bashrc中 环境确认。 1echo $ROS_PACKAGE_PATH 正常情况下会出现如下类似的结果。 1/home/your_user_name/fuerte_workspace/sandbox:/opt/ros/fuerte/share:/opt/ros/fuerte/stacks ROS文件系统下一步为ROS文件系统。 首先确保安装了ros-tutorials包。 1sudo apt-get install ros-kinetic-ros-tutorials 对几个简单的概念做一个快速的浏览， Packages：包是最低级别的ROS软件组织，它包含了库、工具、可执行文件等。 Manifest： 清单是对包的描述，它最重要的作用是定义包之间的依赖关系。 Stacks：堆栈是构成更高级别库的包的集合。 Stack Manifest： 这些就像正常的清单，但是是用于堆栈的。 包是具有manifest.xml文件的目录，堆栈是一个具有stack.xml文件的目录。 文件系统工具，代码分布在许多ROS包和堆栈中。使用命令行工具（如ls和cd）导航可能非常乏味，这就是为什么ROS提供了帮助你的工具。rospack和rosstack允许您获取有关包和堆栈的信息。在本教程中，我们只讨论find选项，它返回包或堆栈的路径。实际用法如下： 12$ rospack find [package_name]$ rosstack find [stack_name] roscd是rosbash套件的一部分。它允许您将目录（cd）直接更改为包或堆栈，使用roscd可以直接跳到工作目录。查看当前路径可以直接使用UNIX命令pwd，实际用法如下： 1$ roscd [locationname[/subdir]] roscd log将带您到ROS存储日志文件的文件夹。 rosls是rosbash套装的一部分。它允许您直接在包，堆栈或公共位置通过名称，而不是通过包路径使用，实际用法如下。 1rosls [locationname[/subdir]] 注意：这些命令是支持Tab键补全的。 创建ROS Package这部分涵盖使用roscreate-pkg或catkin创建新软件包，以及使用rospack列出软件包依赖关系。 roscreate的用法： 123roscreate-pkg [package_name]roscreate-pkg [package_name] [depend1] [depend2] [depend3]#eg: roscreate-pkg beginner_tutorials std_msgs rospy roscpp 创建了新的Package后，需要更新一下profile，以便ROS能够找到新的Package。 123rospack profile#是否成功可以通过如下的命令测试rospack find beginner_tutorials 查看新建的Package的依赖关系下所示，另外这个也可以在Mainefest里面查到。 1rospack depends1 beginner_tutorials rospy是Python的客户端库， roscpp是C ++的客户端库。 编译ROS Package这部分涵盖了构建包的工具链。 一旦安装了所有的系统依赖关系，我们就可以构建我们刚刚创建的包。 rosmake可以编译一个也可以同时编译多个Package，用法如下： 1rosmake [package1] [package2] [package3] 理解ROS节点这部分介绍ROS图形概念，并讨论使用roscore，rosnode和rosrun命令行工具。 ROS节点可以使用客户端库与其他的节点进行沟通，节点可以发布或订阅主题，也可以提供或使用服务。 ROS客户端库允许以不同编程语言编写的节点进行通信。 roscore是使用ROS时应该运行的第一件事。 运行命令如下： 123456roscore#如果有权限问题，请留意下面的方法sudo chown -R &lt;your_username&gt; ~/.ros#如果本地主机配置出问题：$ export ROS_HOSTNAME=localhost$ export ROS_MASTER_URI=http://localhost:11311 rosnode显示有关当前运行的ROS节点的信息。 rosnode list命令列出这些活动节点，rosnode info命令返回有关特定节点的信息。 123#注意运行该命令是，在另外一个开启的Terminalrosnode listrosnode info /rosout rosrun允许您使用程序包名称直接运行程序包中的节点。用法跟示例如下： 12rosrun [package_name] [node_name]rosrun turtlesim turtlesim_node ROS的一个强大的功能是，您可以从命令行重新分配名称。这时使用rosnode list可以看到运行的节点名称，如果还存在之前关闭的节点命令，意味着你是通过ctr + c关闭的，可以通过rosnode cleanup清除，如下： 12rosrun turtlesim turtlesim_node __name:=my_turtlerosnode cleanup 我们可以通过另外一个rosnode ping工具检验该节点是否跑起来了。 理解ROS Topics这部分介绍ROS主题以及使用rostopic和rqt_plot命令行工具。 简单的例子，在两个Termenal分别运行node，然后可以通过方向按键控制海龟的前进方向。 12rosrun turtlesim turtlesim_noderosrun turtlesim turtle_teleop_key turtlesim_node和turtle_teleop_key节点通过ROS Topic彼此通信。 turtle_eleop_key以topic的形式发布键击，而turtlesim以subscribes的形式接收键击信息。 rqt_graph创建了系统中发生了什么的动态图。rqt_graph是rqt包的一部分。安装该应用程序如下： 12sudo apt-get install ros-kinetic-rqtsudo apt-get install ros-kinetic-rqt-common-plugins 使用如下命令可以看出键击控制乌龟的例子的关系动态图。 123rosrun rqt_graph rqt_graph#您可以使用帮助选项获取rostopic的可用子命令rostopic -h rostopic echo显示在一个topic上发布的数据。如下： 12rostopic echo /turtle1/cmd_vel#还是上面的例子，移动方向键后，可以看到有发布的信息出来，同时rqt_graph画面也更新了 rostopic list返回当前订阅和发布的所有主题的列表。如： 12rostopic list -v#这将显示要发布到和订阅的Topic的详细列表及其类型 可以使用rostopic type来确定在主题上发送的消息的类型。如下： 12345#用法rostopic type [topic]#例子rostopic type /turtle1/cmd_velrosmsg show geometry_msgs/Twist rostopic pub将数据发布到当前广告的topic。 1234567rostopic pub [topic] [msg_type] [args]rostopic pub -1 /turtle1/cmd_vel geometry_msgs/Twist -- '[2.0, 0.0, 0.0]' '[0.0, 0.0, 1.8]'#-1：此选项（破折号一）使rostopic只发布一个消息，然后退出#此选项（双破折号）告诉选项解析器，以下参数都不是选项#这些参数实际上是YAML语法rostopic pub /turtle1/cmd_vel geometry_msgs/Twist -r 1 -- '[2.0, 0.0, 0.0]' '[0.0, 0.0, -1.8]'#我们可以使用rostopic pub -r命令发布稳定的命令流 rostopic hz报告数据发布的速率。 1rostopic hz /turtle1/pose 我们还可以使用rostopic类型与rosmsg show结合获取有关某个主题的深入信息。 1rostopic type /turtle1/cmd_vel | rosmsg show rqt_plot显示关于主题发布的数据的滚动时间图。 12rosrun rqt_plot rqt_plot#添加 /turtle1/pose/x /turtle1/pose/y 理解ROS服务和参数服务是节点可以彼此通信的另一种方式。服务允许节点发送请求并接收响应。 1rosservice list list命令向我们显示turtlesim节点提供了九个服务：reset, clear, spawn, kill, turtle1/set_pen, /turtle1/teleport_absolute, /turtle1/teleport_relative, turtlesim/get_loggers, and turtlesim/set_logger_level. 12rosservice type /clear#此服务为空，这意味着当进行服务调用时，不需要任何参数（即，在发出请求时不发送数据，而在接收响应时不接收数据）。 这里我们将调用没有参数，因为服务类型为空： 12rosservice call [service] [args]rosservice call /clear 再看看一个服务类型不为空的服务例子spawn。 123456789rosservice type /spawn| rossrv show float32 x float32 y float32 theta string name#这项服务让我们在给定的位置和方向产生一只新的乌龟。 name字段是可选的，所以让我们不要给我们的新龟一个名字，让turtlesim为我们创建一个。rosservice call /spawn 2 2 0.2 ""---string name rosparam允许您存储和操作ROS参数服务器上的数据。参数服务器可以存储整数，浮点数，布尔值，字典和列表。rosparam使用YAML标记语言进行语法。YAML看起来很自然：1是一个整数，1.0是一个浮点数，one是一个字符串，true是一个布尔值，[1，2，3]是一个整数列表，{a：b，c：d}表示字典。rosparam有很多可以在参数上使用的命令，如下所示： 123456rosparam set set parameterrosparam get get parameterrosparam load load parameters from filerosparam dump dump parameters to filerosparam delete delete parameterrosparam list list parameter names 这里会改变红色通道的背景颜色，这改变了参数值，现在我们要调用clear服务使参数更改生效： 12rosparam set /background_r 150rosservice call /clear 现在让我们看看param服务器上其他参数的值。让我们得到绿色背景频道的值： 1rosparam get /background_g 我们还可以使用rosparam get /来向我们显示整个参数服务器的内容。 1rosparam get / 您可能希望将其存储在一个文件中，以便您可以在另一时间重新加载它。 1234567rosparam dump [file_name] [namespace]rosparam load [file_name] [namespace]#这里我们将所有参数写入文件params.yamlrosparam dump params.yaml#你甚至可以将这些yaml文件加载到新的命名空间rosparam load params.yaml copyrosparam get /copy/background_b 手工创建一个ROS包你的包有一个清单，ROS可以找到它。尝试执行命令: 1rospack find foobar 另外是要创建CMakeLists，才能进行编译。 使用rqt_console和roslaunch这部分介绍使用rqt_console和rqt_logger_level进行调试的ROS，以及一次性启动多个节点的roslaunch。 rqt_console附加到ROS的日志框架以显示节点的输出。rqt_logger_level允许我们在节点运行时更改节点的详细级别（DEBUG，WARN，INFO和ERROR）。 使用方法如下： 123rosrun rqt_console rqt_consolerosrun rqt_logger_level rqt_logger_level#fatal具有最高优先级，debug具有最低优先级。通过设置记录器级别，您将获得该优先级或更高级别的所有消息。 roslaunch启动在启动文件中定义的节点。 12345678910111213141516171819202122232425262728#Usageroslaunch [package] [filename.launch]roscd beginner_tutorialsmkdir launchcd launch#现在让我们创建一个名为turtlemimic.launch的启动文件并粘贴以下内容&lt;launch&gt; &lt;group ns="turtlesim1"&gt; &lt;node pkg="turtlesim" name="sim" type="turtlesim_node"/&gt; &lt;/group&gt; &lt;group ns="turtlesim2"&gt; &lt;node pkg="turtlesim" name="sim" type="turtlesim_node"/&gt; &lt;/group&gt; &lt;node pkg="turtlesim" name="mimic" type="mimic"&gt; &lt;remap from="input" to="turtlesim1/turtle1"/&gt; &lt;remap from="output" to="turtlesim2/turtle1"/&gt; &lt;/node&gt;&lt;/launch&gt;#启动节点roslaunch beginner_tutorials turtlemimic.launch#两个turtlesim将启动，在一个新的终端发送rostopic命令：rostopic pub /turtlesim1/turtle1/cmd_vel geometry_msgs/Twist -r 1 -- '[2.0, 0.0, 0.0]' '[0.0, 0.0, -1.8]'#查看效果图rqt_graph 使用rosed在ROS中编辑文件rosed是rosbash套装的一部分。它允许您使用软件包名称直接编辑软件包中的文件，而不必键入软件包的整个路径。 12rosed [package_name] [filename]rosed roscpp Logger.msg 这种方法您可以轻松地查看和可选地编辑包中的所有文件，而无需知道其确切的名称。 1234rosed [package_name] &lt;tab&gt;&lt;tab&gt;#更改默认编辑器export EDITOR='nano -w'export EDITOR='emacs -nw' 创建ROS msg和srv这部分将介绍如何创建和构建msg和srv文件以及rosmsg，rossrv和roscp命令行工具。 初学URDF从这里开始学习URDF，首先构建一个模糊地看起来像R2D2的机器人的视觉模型。 123#前提条件sudo apt-get install ros-kinetic-urdf-tutorial#会安装到/opt/ros/kinetic/share/urdf_tutorial 第一个简单的URDF例子，这是一个名为myfirst的机器人，它只包含一个关节（a.k.a. part），其视觉分量只是一个圆柱体.6米长，半径为.2米，视觉元素（圆柱）的原点在其几何的中心作为默认值。因此，一半的气缸在网格之下。运行如下 12345roscd urdfroslaunch urdf_tutorial display.launch model:=urdf/01-myfirst.urdf#或者直接在任意路径运行roslaunch urdf_tutorial display.launch model:='$(find urdf_tutorial)/urdf/01-myfirst.urdf'#请注意参数值周围的单引号 现在让我们来看看如何添加多个形状/关节，关节是根据父母和孩子来定义的。 URDF最终是一个具有一个根链路的树结构。这意味着腿的位置取决于base_link的位置。 123456roslaunch urdf_tutorial display.launch model:=urdf/02-multipleshapes.urdf #树状结果如下： &lt;joint name="base_to_right_leg" type="fixed"&gt; &lt;parent link="base_link"/&gt; &lt;child link="right_leg"/&gt; &lt;/joint&gt; 如果要更改原点坐标呢？ 关节点Joint的原点是根据父节点的参考帧定义的，分析的时候其余的坐标都是相对关节点而言的。 1roslaunch urdf_tutorial display.launch model:=urdf/03-origins.urdf 怎么给自己的零件着色呢？ 身体现在是蓝色的。通过添加第一个材质标签，我们定义了一种名为“蓝色”的新材料，红色，绿色，蓝色和alpha通道分别定义为0,0，.8和1。所有值可以在范围[0,1]内。对于第二条腿，我们可以通过名称来引用材料，因为它以前已经定义。没有人会抱怨，如果你重新定义它。您还可以使用纹理来指定用于对对象着色的图像文件。 如下： 1roslaunch urdf_tutorial display.launch model:=urdf/04-materials.urdf 更多：网格可以以多种不同的格式导入。 STL是相当普遍的，但引擎还支持DAE，它可以有自己的颜色数据，这意味着你不必指定颜色数据。网格也可以使用相对缩放参数或边界框大小来确定大小。 使用URDF构建可移动机器人模型这部分了解如何在URDF中定义活动关节，关节三种其他重要类型的连接：固定，连续，旋转和棱柱。 1roslaunch urdf_tutorial display.launch model:=urdf/06-flexible.urdf gui:=True 右和左夹爪接头被建模为旋转接头。这意味着它们以与连续关节相同的方式旋转，但是它们具有严格的限制。夹持臂是不同类型的接头…即棱柱形接头。这意味着它沿着一个轴移动，而不是围绕一个轴移动。这种平移运动允许我们的机器人模型延伸和缩回其夹持臂。此外，浮动接头不受约束，并且可以在三个维度中的任一个中移动。 当您在GUI中移动滑块时，模型在Rviz中移动。这是怎么做的？ 首先GUI解析URDF并找到所有非固定关节及其限制，然后，它使用滑块的值来发布sensor_msgs / JointState消息。 Anno URDF12rosrun tf static_transform_publisher 0.0 0.0 0.0 0.0 0.0 0.0 map my_frame 100#note: in most cases, Linux runs on top of a case-sensitive file system, which means that file.STL is not the same as file.stl. Make sure base_3.stl is not actually base_3.STL. This is a common problem with urdfs and meshes created under Windows, and then copied to your Linux installation. 关于Xacro学习一些技巧，使用Xacro URDF以减少文件中的代码量。主要从三个方面入手：常量、简单数学、宏。在本教程中，我们将查看所有这些快捷方式，以帮助减少URDF文件的整体大小，并使其更易于阅读和维护。语法如下： 1rosrun xacro xacro model.xacro &gt; model.urdf 您还可以在启动文件中自动生成urdf。这是方便的，因为它保持最新，不占用硬盘空间。但是，生成需要时间，因此请注意，启动文件可能需要较长时间才能启动。 12&lt;param name="robot_description" command="$(find xacro)/xacro '$(find pr2_description)/robots/pr2.urdf.xacro'" /&gt; 在URDF文件的顶部，您必须指定一个命名空间，以便正确解析该文件。例如，这些是有效xacro文件的前两行： 12&lt;?xml version="1.0"?&gt;&lt;robot xmlns:xacro="http://www.ros.org/wiki/xacro" name="firefighter"&gt; 常量定义：它们可以在任何地方（假设有效的XML），任何级别，使用之前或之后定义。通常他们在顶部。我们使用美元符号和大括号来表示值，而不是在geometry元素中指定实际半径。 12&lt;xacro:property name="width" value=".2" /&gt;&lt;xacro:property name="bodylen" value=".6" /&gt; 您可以使用四个基本操作（+， - ，*，/），一元减号和括号在$ {}构造中构建任意复杂的表达式。不支持指数和模量。 12&lt;cylinder radius="$&#123;wheeldiam/2&#125;" length=".1"/&gt;&lt;origin xyz="$&#123;reflect*(width+.02)&#125; 0 .25" /&gt; 宏定义部分： 1234567&lt;xacro:macro name="default_origin"&gt; &lt;origin xyz="0 0 0" rpy="0 0 0"/&gt;&lt;/xacro:macro&gt;#使用：&lt;xacro：$ NAME /&gt;的每个实例都将替换为xacro：macro标记的内容。#注意，即使它不完全相同（两个属性已切换顺序），生成的XML是等效的。#如果找不到具有指定名称的xacro，它将不会被展开，也不会产生错误。&lt;xacro:default_origin /&gt; 参数化宏： 123456789101112&lt;xacro:macro name="default_inertial" params="mass"&gt; &lt;inertial&gt; &lt;mass value="$&#123;mass&#125;" /&gt; &lt;inertia ixx="1.0" ixy="0.0" ixz="0.0" iyy="1.0" iyz="0.0" izz="1.0" /&gt; &lt;/inertial&gt;&lt;/xacro:macro&gt;#调用的时候如下，参数化宏，以使它们不会每次都生成相同的确切文本，mass表示给其参数传递实参&lt;xacro:default_inertial mass="10"/&gt;#也可以使用整个块作为参数&lt;xacro:insert_block name="shape" /&gt; 要查看由xacro文件生成的模型，请运行以下命令：roslaunch urdf_tutorial xacrodisplay.launch model:=urdf/08-macroed.urdf.xacro 解析PR2 Robot URDF本教程解释了复杂机器人（如PR2）的顶级URDF Xacro文件的布局。完整的PR2 URDF宏文件可以在文件robots / pr2.urdf.xacro中的pr2_description包中找到。 包括用于单个机器人组件的包含xacro宏的文件。这就像在C中包含一个头文件：它设置了一堆定义，但实际上不调用它们。 建立自己的Robot URDF12vi my_robot.urdfcheck_urdf my_robot.urdf 现在我们有了基本的树结构，让我们添加适当的维度。包括关节的定位与旋转轴的设定。最后转换成PDF进行查看。 12urdf_to_graphiz my_robot.urdfevince test_robot.pdf Moveit安装安装ROS Indigo，Jade或Kinetic。请确保您已遵循所有步骤并安装了最新版本的软件包。 12345678rosdep updatesudo apt-get updatesudo apt-get dist-upgrade#源安装需要wstool，catkin_tools和可选的clang-formatsudo apt-get install python-wstool python-catkin-tools clang-format-3.8#创建新的工作空间mkdir -p ~/ws_moveit/srccd ~/ws_moveit/src 从catkin工作区的/ src目录中拉下所需的存储库和编译。 1234567wstool init .wstool merge https://raw.githubusercontent.com/ros-planning/moveit/kinetic-devel/moveit.rosinstallwstool updaterosdep install --from-paths . --ignore-src --rosdistro kineticcd ..catkin_makesource ~/ws_moveit/devel/setup.bash # or .zsh, depending on your shell 另外关于moveit的源码介绍看这里，为了完整性，以下两个回合是可以找到文档的地方： moveit.ros.org - 这个主要网站 moveit_tutorials - 一步一步学习MoveIt的例子！ moveit_kinematics_tests - 带测试的实验性repo RViz基于GUI的界面可通过使用MoveIt! Rviz(ROS Visualizer)插件,该插件允许您设置机器人的工作场景，生成计划，可视化输出和直接与可视化的机器人交互。 你应该已经完成​​了MoveIt！安装助手教程，如果没有，安装如下，Setup Assistant是一个图形用户界面，用于配置与MoveIt一起使用的任何机器人！ 12345roslaunch moveit_setup_assistant setup_assistant.launch#当出现问题：ERROR: cannot launch node of type [moveit_ros_move_group/move_group]: can't locate node [move_group] in package [moveit_ros_move_group]时，重新source一下setup.sh文件#点击Create New MoveIt! Configuration Package#browse选择/opt/ros/kinetic/share/pr2_description/robots/pr2.urdf.xacro#load files 注意：配置anno机械臂时，将package包文件夹robot_anno_v6移动到/opt/ros/kinetic/share或ws_moveit，然后加载/opt/ros/kinetic/share/robot_anno_v6/urdf/RobotAnnoV6.urdf文件进行配置。或者建立自己的catkin_ws，里面放自己的package。 在添加arm的时候，不要把forearm_cam_frame_joint加进去了！ 安装配置完成后，继续进行RViz Plugin。 1234567891011mv ~/pr2_moveit_generated ~/kinetic_workspace/sandbox#或者修改~/.bashrc文件，注意加在最末尾export ROS_PACKAGE_PATH=$HOME/ws_moveit/src:$ROS_PACKAGE_PATH#然后启动包roslaunch pr2_moveit_generated demo.launch#如有错误sudo apt-get install ros-kinetic-moveit-ros-visualizationsudo apt-get install ros-kinetic-moveit-fake-controller-managersudo apt-get install ros-kinetic-moveit-planners-ompl#重新更改配置roslaunch abb_moveit_config setup_assistant.launch 在上面这个界面的使用过程中，可以移动手臂，并能追踪移动的整个轨迹过程。 您现在可以开始使用MoveIt！在Gazebo中模拟机器人。 MoveIt! 设计用于真实和模拟机器人。这部分了解如何配置MoveIt！用于PR2上的控制器，还将学习如何将传感器集成到PR2上与MoveIt！ 1234567#前提条件sudo apt-get install ros-kinetic-pr2-common#以下编辑的内容见原网页记载vi controllers.yamlvi pr2_moveit_controller_manager.launch.xmlvi moveit_planning_execution.launchroslaunch pr2_moveit_generated moveit_planning_execution.launch 上面的gazo包过时了，有些操作不一定可用，更多参考gazebo_ros_pkgs。 gazebo_ros_pkgs是一组ROS包，它们提供必要的接口来在机器人的Gazebo 3D刚体模拟器中模拟机器人。它使用ROS消息，服务和动态重新配置与ROS集成。 Move Group Interface首先看一个轨迹视频，下面仔细分析是怎么做到的？参考Move Group Interface Tutorial。 12345678cd ~/ws_moveit/srcgit clone https://github.com/ros-planning/moveit_tutorials.gitgit clone https://github.com/PR2/pr2_common.git -b kinetic-develgit clone https://github.com/davetcoleman/pr2_moveit_config.gitrosdep install --from-paths . --ignore-src --rosdistro kineticroslaunch pr2_moveit_config demo.launch#如果出现节点问题，记得sourceroslaunch moveit_tutorials move_group_interface_tutorial.launch 具体程序源码分析见原文，主要为Setup、Visualization、获取基本信息、Planning to a Pose goal、可视化计划、移动到姿势目标、规划联合空间目标、规划与路径约束、笛卡尔路径、添加/删除对象和附加/分离对象、双臂姿势目标。 Move Group Python Interface主用户是通过RobotCommander类进行交互，它为用户可能想要执行的大多数操作提供功能，特别是设置关节或姿势目标，创建运动计划，移动机器人，将对象添加到环境中以及从机器人附加/分离对象。 例程分析见如下，源码里面也有响应的代码解读。 12cd ~/ws_moveit/src/moveit_tutorialsvi doc/pr2_tutorials/planning/scripts/move_group_python_interface_tutorial.py +43 这一部分跟上一部分的源码分析差不多，可以参考着进行分析，只是整个定义了一个python函数move_group_python_interface_tutorial，最后运行main函数即可，其中launch文件见~/ws_moveit/src/moveit_tutorials/doc/pr2_tutorials/planning/launch/move_group_python_interface_tutorial.launch。 12345chmod +x ~/ws_moveit/src/moveit_tutorials/doc/pr2_tutorials/planning/scripts/move_group_python_interface_tutorial.pyroslaunch pr2_moveit_config demo.launchrosrun moveit_tutorials move_group_python_interface_tutorial.py#需要安装commander相关的软件包，通过apt-cache search moveit可以查看到应该安装如下sudo apt-get install ros-kinetic-moveit-commander 在Rviz中，可以看到如程序中安排的输出情况。 Kinematic Model Tutorial在本节中，将介绍通过C ++ API使用运动学。RobotModel和RobotState类是允许访问运动学的核心类。具体内容见原网页，这部分介绍到了IK和FK。 12#例程原函数vi ~/ws_moveit/src/moveit_tutorials/doc/pr2_tutorials/kinematics/src/kinematic_model_tutorial.cpp 对该CPP文件的编译参考源码编译，如果要运行该段程序，需要launch做的事情： - 将PR2 URDF和SRDF上传到param服务器。 - 将kinematics_solver配置上传到ROS param服务器。 最后运行如下： 1roslaunch moveit_tutorials kinematic_model_tutorial.launch rosserial_arduino本部分介绍如何设置Arduino IDE来使用rosserial。rosserial提供了一个ROS通信协议，使用你的Arduino的UART工作。它允许您的Arduino成为一个完整的ROS节点，可以直接发布和订阅ROS消息，发布TF变换，并获得ROS系统时间。 我们的ROS绑定​​实现为Arduino库。像所有的Arduino库一样，ros_lib的工作原理是把它的库实现放到你的素描本的libraries文件夹中。 为了在你自己的代码中使用rosserial库，你必须先放 12#include &lt;ros.h&gt;#include &lt;std_msgs/String.h&gt; 安装12sudo apt-get install ros-kinetic-rosserial-arduinosudo apt-get install ros-kinetic-rosserial 前面的安装步骤创建ros_lib，它必须复制到Arduino构建环境中，以使Arduino程序与ROS交互。现在你已经从源代码或debs安装，所有你需要做的是将rosserial_arduino / libraries目录复制到你的Arduino sketchbook。 123 cd /opt/arduino-1.6.7/librariesrm -rf ros_librosrun rosserial_arduino make_libraries.py . 重新启动IDE后，您应该看到ros_lib列在示例下： hello world我们将开始探索rosserial，为我们的Arduino创建一个“hello world”程序。选择示例-ros_lib-HelloWorld，进行编译上传，如果编译不通过，检查roslib创建的是否有问题。然后分别在各个窗口输入： 1234roscorerosrun rosserial_python serial_node.py /dev/ttyACM0rostopic echo chatter#如果Arduino与ros通信想使用Arduino硬件的其它的Uart端口，可以更改vi /opt/arduino-1.6.7/libraries/ros_lib/ArduinoHardware.h +72为其他数字，默认为Uart0 工业机器人资料地址：abb/首页/ABBgithub/roswiki]]></content>
      <categories>
        <category>机器人</category>
      </categories>
      <tags>
        <tag>机器人</tag>
        <tag>Moveit</tag>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArduPilot开发入门学习]]></title>
    <url>%2F2017%2F06%2F16%2FArduPilot%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[编译pixhawk环境搭建参考原网页进行说明，有两种搭建环境的方式。 第一种为自动执行脚本(推荐)，较为方便，但有问题需解决。 由于使用apt-get update时部分文件无法下载，导致脚本执行不完整，故可将ardupilot/Tools/scripts/install-prereqs-ubuntu.sh文件里的$APT_GET update行用#注释掉。 然后操作如下： 123456789101112~ $ sudo apt-get -qq -y install git~ $ cd ~/src#下载源代码~ $ git clone https://github.com/ArduPilot/ardupilot.git#修改脚本后运行~ $ ardupilot/Tools/scripts/install-prereqs-ubuntu.sh -y~ $ . ~/.profile#编译Copter~ $ cd ardupilot/ArduCopter~ $ make px4-v2#上传~ $ make px4-v2 upload 第二种为手动搭建环境，这里只提出一些主要的注意事项。 需要特定的交叉编译器，更多参考搭建px4原生开发环境的文章。 123456789101112pushd .# =&gt; 卸载新版的gcc-arm-none-eabi~ $ sudo apt-get remove gcc-arm-none-eabi~ $ wget https://launchpadlibrarian.net/186124160/gcc-arm-none-eabi-4_8-2014q3-20140805-linux.tar.bz2# =&gt; 安装下载好的gcc-arm-none-eabi~ $ tar xjvf gcc-arm-none-eabi-4_8-2014q3-20140805-linux.tar.bz2~ $ sudo mv gcc-arm-none-eabi-4_8-2014q3 /opt~ $ exportline="export PATH=/opt/gcc-arm-none-eabi-4_8-2014q3/bin:\$PATH"~ $ if grep -Fxq "$exportline" ~/.profile; then echo nothing to do ; else echo $exportline &gt;&gt; ~/.profile; fi# =&gt; 使路径生效~ $ . ~/.profilepopd 安装ccache加快编译速度。 123456789101112131415161718 ~ $ sudo apt-get install ccache ~ $ cd /usr/lib/ccache ~ $ sudo ln -s /usr/bin/ccache arm-none-eabi-g++ ~ $ sudo ln -s /usr/bin/ccache arm-none-eabi-gcc ``` 然后将`export PATH=/usr/lib/ccache:$PATH`加入到~/.profile中。- 安装make, gawk，genromfs等linux开发工具。- 权限：`sudo usermod -a -G dialout $USER`。&gt; `Tip`：编译过程中主要问题： &gt;1、考虑更新子模块，所有的子模块都放在modules/目录&gt; &gt; ```sh&gt; git submodule init&gt; git submodule update --recursive&gt; #或者一行就行&gt; git submodule update --init --recursive&gt; 2、如果以前编译正确，更新子模块后出现问题，make px4-clean后重新编译 3、如果子模块更新的时候出现如下错误： 123&gt; fatal: 目标路径 &apos;src/lib/ecl&apos; 已经存在，并且不是一个空目录。&gt; 无法克隆 &apos;https://github.com/PX4/ecl.git&apos; 到子模组路径 &apos;src/lib/ecl&apos;&gt; 直接删除src/lib/ecl即可。 参与贡献wiki知识点： 创建分支并改变一些代码：fork源仓库，克隆到本地，更改后推送到fork仓库。 保持代码更新：添加upstream远程官方库；更新git fetch upstream，fetch与pull的区别；重置当前的分支git rebase upstream/master，这里可能有冲突需要解决；更新子模块；推送的fork库git push origin master 提交分支到master：确保每次提交只是做了一件事情；简洁易懂的注释；清理本地提交历史；推送到本地分支git push -f origin master；创建上拉请求；在Pull Request页面选择New pull request按钮；选择需要提交的分支然后点击Click to create pull request for this comparison（base branch 是远程官方分支, head branch 是自己要提交的分支，这样做可以在任意时间段进行提交）；每个参与者都会收到新请求消息；管理pull requests；查看proposed changes；Pull request谈论；一段时间后可以查看long-running pull requests 下面我以ardupilot这个开源项目为例子做一个实际的演示： 下载源码并设置源，这一步只需进行一次就可以了。 123456789101112#首先进入https://github.com/ArduPilot/ardupilot进行fork#然后如下下载源码~ $ git clone git@github.com:your_github_name/ardupilot.git#设置官方更新源，一般origin 默认已经设置~ $ git remote add upstream git@github.com:ArduPilot/ardupilot.git#查看设置源效果~ $ git remote -v#正常显示如下origin git@github.com:your_github_name/ardupilot.git (fetch)origin git@github.com:your_github_name/ardupilot.git (push)upstream https://github.com/diydrones/ardupilot.git (fetch)upstream https://github.com/diydrones/ardupilot.git (push) 更改代码并推送到fork库。 12345678#首先添加更改的文件， .代表添加所有更改的文件~ $ git add .#查看添加状况~ $ git status#添加更改注释~ $ git commit -m "your comment"#推送到fork库~ $ git push origin master 保持与官方源代码同步，这一步一般与步骤2结合，保证推送到fork库时是在最新的代码上进行的更改。 12345678~ $ git fetch upstream master#重置当前的分支~ $ git rebase upstream/master#一般这里都需要更新子模块~ $ git submodule update --init --recursive#查看更新结果~ $ git status#如果更新后产生了冲突，先解决冲突再按照步骤2进行add/commit 在Pull Request页面选择New pull request按钮；选择需要提交的分支然后点击Click to create pull request for this comparison（base branch 是远程官方分支, head branch 是自己要提交的分支，这样做可以在任意时间段进行提交） 代码库原文参考这里!!! 1、ArduPilot的基本框架分为5个主要部分： vehicle目录 AP_HAL (Hardware Abstraction Layer)：能使ArduPilot移植到不同的平台；目录为 libraries/AP_HAL； libraries tools目录 外部支持代码 2、makefiles文件是在mk/directory目录里，为每个类型的支持定义编译规则，这里有一些辅助的make目标： make clean – clean the build for non-px4 targets make px4-clean – completely clean the build for PX4 targets make px4-cleandep – cleanup just dependencies for PX4 targets 3、探索自己的代码的第一步是使用库的example sketches。知道library API和约定在ArduPilot中的使用对理解代码是至关重要的。你可以看到这些example sketches： libraries/AP_GPS/examples/GPS_AUTO_test libraries/AP_InertialSensor/examples/INS_generic libraries/AP_Compass/examples/AP_Compass_test libraries/AP_Baro/examples/BARO_generic libraries/AP_AHRS/examples/AHRS_Test 理解example sketch代码： 每个使用AP_HAL特性的文件都需要声明一个hal引用，hal的实体在AP_HAL_XXX库里，最常用的hal函数： hal.console-&gt;printf() and hal.console-&gt;printf_P() to print strings (use the _P to use less memory on AVR) hal.scheduler-&gt;millis() and hal.scheduler-&gt;micros() to get the time since boot hal.scheduler-&gt;delay() and hal.scheduler-&gt;delay_microseconds() to sleep for a short time hal.gpio-&gt;pinMode(), hal.gpio-&gt;read() and hal.gpio-&gt;write() for accessing GPIO pins I2C access via hal.i2c SPI access via hal.spi setup()函数在板子启动的时候被调用一次，它实际的调用来自每块板子的HAL，所有main函数是在HAL里的，其后就是loop()函数的调用，sketch的主要工作体现在loop()函数里，注意这两个函数只是冰山一角； AP_HAL_MAIN()是一个HAL宏，用来产生必要的代码声明C++主要函数，以及一些板级的初始化代码，位于AP_HAL_XXX_Main.h。 4、理解ArduPilot线程：APM1 and APM2不支持线程，所以要做一个简单的定时器和回调；有很多您需要了解的ArduPilot线程相关的关键概念： 定时器回调函数：在AP_HAL里每个平台提供了一个1 khz 计时器；可以这样注册定时器回调函数(来自MS5611 barometer driver)： 1hal.scheduler-&gt;register_timer_process(AP_HAL_MEMBERPROC(&amp;AP_Baro_MS5611::_update)); HAL特定线程：创建一些线程支持基本的操作，这些线程提供了一种调度慢任务而不打断主飞行任务的方法，比如px4上的一些（用USB连接pixhawk，波特率为57600，命令ps，能看到一些固有的线程）： The UART thread, for reading and writing UARTs (and USB) The timer thread, which supports the 1kHz timer functionality described above The IO thread, which supports writing to the microSD card, EEPROM and FRAM 驱动程序特定线程：例程见AP_HAL_Linux/ToneAlarmDriver.cpp ArduPilot驱动和不同平台的驱动：举个例子，MPU6000传感器，non-PX4 平台使用AP_InertialSensor_MPU6000.cpp驱动，而PX4平台使用AP_InertialSensor_PX4.cpp驱动。 平台特定的线程和任务：在某些平台，一些基本的任务和线程将在开机的时候被创建。如PX4： idle task – called when there is nothing else to run init – used to start up the system px4io – handle the communication with the PX4IO co-processor hpwork – handle thread based PX4 drivers (mainly I2C drivers) lpwork – handle thread based low priority work (eg. IO) fmuservo – handle talking to the auxillary PWM outputs on the FMU uavcan – handle the uavcan CANBUS protocol 它们是由 rc.APM script脚本创建，在启动的时候执行，一个学习启动更加有效的方法是无SD卡启动，因为rcS script是在rc.APM之前执行的。可以用pixhawk启动后在nsh里做如下的练习： tone_alarm stop uorb start mpu6000 start mpu6000 info mpu6000 test mount -t binfs /dev/null /bin ls /bin perf 这些的源代码在PX4Firmware/src/drivers里，如果你看了mpu6000驱动，你会看到这么一行： hrt_call_every(&amp;_call, 1000, _call_interval, (hrt_callout)&amp;MPU6000::measure_trampoline, this); 它跟AP_HAL里的hal.scheduler-&gt;register_timer_process()是等效的，用在操作迅速的常规事件里，如SPI设备驱动。或者你还可以看到hmc5883驱动里的 work_queue(HPWORK, &amp;_work, (worker_t)&amp;HMC5883::cycle_trampoline, this, 1); 而这个适用于速度慢一点的设备，比如IIC。 AP_Scheduler系统：AP_Scheduler 库的作用是在主线程里面划分时间片；可以通过例子 AP_Scheduler/examples/Scheduler_test.cpp学习，这个文件里边有一个表单： 12345static const AP_Scheduler::Task scheduler_tasks[] PROGMEM = &#123; &#123; ins_update, 1, 1000 &#125;, &#123; one_hz_print, 50, 1000 &#125;, &#123; five_second_call, 250, 1800 &#125;,&#125;; 函数后面的第一个数字是调用频率，它的单位由ins.init()调用控制，这个例子使用的是RATE_50HZ，即20ms，所以ins_update()调用是20ms一次，one_hz_print()调用是1s一次，five_second_call为5s一次。第三个数字是函数预计花费的最长时间。另一个关键点是 ins.wait_for_sample()函数的调用，它是ArduPilot驱动调度的节拍器，它阻塞主函数的执行直到一个新的IMU采集的到来，而阻塞的时间是由ins.init()控制的。 AP_Scheduler tables必须有如下的属性： 它们不能被阻塞，除非ins.update()被调用； 在飞行中不能执行睡眠函数； 它们应该有可预测的最坏情况时间； 现在可以在Scheduler_test例子里做练习了。 比如做如下的事情： read the barometer read the compass read the GPS update the AHRS and print the roll/pitch 信号量：为了防止多个线程访问一个共享的数据结构而产生冲突，这里有三种原理方法：semaphores, lockless data structures and the PX4 ORB；查看libraries/AP_Compass/AP_Compass_HMC5883.cpp里的_i2c_sem变量，自己探索它的工作原理。 无锁的数据结构：ArduPilot两个无锁的数据结构的例子： the _shared_data structure in libraries/AP_InertialSensor/AP_InertialSensor_MPU9250.cpp the ring buffers used in numerous places. A good example is libraries/DataFlash/DataFlash_File.cpp DataFlash_File中可以查看 _writebuf_head 和 _writebuf_tail两个变量。 PX4 ORB：ORB是一种从系统的一部分到系统的另一部分提供数据的方式，它在一个多线程的环境中使用了发布/订阅模型。所有的定义都在PX4Firmware/src/modules/uORB/topics；例子有AP_HAL_PX4/RCOutput.cpp里的_publish_actuators()，你将看到它订阅了一个“actuator_direct”主题，它包含了每个电调的设定速度。另外的两种与px4驱动通信的机制为： ioctl calls (see the examples in AP_HAL_PX4/RCOutput.cpp) /dev/xxx read/write calls (see _timer_tick in AP_HAL_PX4/RCOutput.cpp) 5、uart和控制台：ArduPilot HAL目前有5UARTs： uartA – the console (usually USB, runs MAVLink telemetry) uartB – the first GPS uartC – primary telemetry (telem1 on Pixhawk, 2nd radio on APM2) uartD – secondary telemetry (telem2 on Pixhawk) uartE – 2nd GPS 你可以任意使用，但最好是按它原来的方式，因为有现成的代码。有些UARTs有着双重角色，如SERIAL2_PROTOCOL参数使uartD用于MAVLink变为用于Frsky telemetry。可以参看这个例子 libraries/AP_HAL/examples/UART_test做练习。每个UART有一些基本的IO函数： printf – formatted print printf_P – formatted print with progmem string (saves memory on AVR boards) println – print and line feed write – write a bunch of bytes read – read some bytes available – check if any bytes are waiting txspace – check how much outgoing buffer space is available get_flow_control – check if the UART has flow control capabilities 6、RC输入与输出：ArduPilot根据板类支持几种不同类型的RC输入： PPMSum – on PX4, Pixhawk, Linux and APM2 SBUS – on PX4, Pixhawk and Linux Spektrum/DSM – on PX4, Pixhawk and Linux PWM – on APM1 and APM2 RC Override (MAVLink) – all boards 其中SBUS 和 Spektrum/DSM都是串口协议。 RC输出是ArduPilot控制伺服系统和电机，RC输出默认为50 hz PWM值，但是可以更高，通常在400hz。 AP_HAL RCInput对象(hal.rcin) 它提供目前板上收到的低级的访问通道值。例子为libraries/AP_HAL/examples/RCInput/RCInput.cpp。 AP_HAL RCOutput(hal.rcout) hal.rcin 和 hal.rcout 对象都是低级函数，所有用户配置都是通过RC_Channel，例子在 libraries/RC_Channel/examples/RC_Channel/RC_Channel.cpp。 RC_Channel_aux 位于libraries/RC_Channel，是RC_Channel的子类，可以由用户指定附加属性。 7、存储和eeprom管理 AP_HAL::Storage：hal.storage API有三个主要的函数： init() to start up the storage subsystem read_block() to read a block of bytes write_block() to write a block of bytes 提倡使用API，只有在使用新板子或debug的时候才用hal.storage。可用存储的大小 AP_HAL/AP_HAL_Boards.h里的宏HAL_STORAGE_SIZE定义。所以如果你想使用动态存储只能使用Posix IO。 StorageManager库 详情见libraries/StorageManager/StorageManager.cpp，在板子上做测试的时候注意备份好配置文件。 DataFlash库 用于板载logs；也提供API从log文件里边取回数据；例子 libraries/DataFlash/examples/DataFlash_test/DataFlash_test.cpp，或者在loop()里可以看到： DataFlash.get_log_boundaries(log_num, start, end); Posix IO 一个很好的例子是AP_Terrain库,其中包含地形数据；是否支持可以从 AP_HAL_Boards.h查看HAVE_OS_POSIX_IO macro，还可以定义数据的存储位置；这个操作比较耗时，特别在飞行过程中不宜使用；可以看这个例子 libraries/AP_Terrain/TerrainIO.cpp学会怎么使用Posix IO。 上位机安装由于我使用的是Ubuntu, 所以我会想办法使Mission Planner上位机能在linux平台上运行，在pixhawk的官网上也发现了这样的文章以及谷歌搜到的文章。 这里mono版本下载，参考Install Mono on Linux安装mono 123456789101112131415~ $ sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 3FA7E0328081BFF6A14DA29AA6A19B38D3D831EF# =&gt; If for some reason you want to pin an older version of Mono rather than updating to the latest, you can modify the Debian repository to “wheezy/snapshots/X.XX.X” instead of “wheezy”. For example, “wheezy/snapshots/3.10.0” will lock you to that version.~ $ echo "deb http://download.mono-project.com/repo/debian wheezy main" | sudo tee /etc/apt/sources.list.d/mono-xamarin.list~ $ echo "deb http://download.mono-project.com/repo/debian wheezy-apache24-compat main" | sudo tee -a /etc/apt/sources.list.d/mono-xamarin.list~ $ sudo apt-get update~ $ sudo apt-get install mono-runtime~ $ sudo apt-get install mono-complete festival# =&gt; The package mono-devel should be installed to compile code.# =&gt; The package mono-complete should be installed to install everything - this should cover most cases of “assembly not found” errors.# =&gt; The package referenceassemblies-pcl should be installed for PCL compilation support - this will resolve most cases of “Framework not installed: .NETPortable” errors during software compilation.# =&gt; The package ca-certificates-mono should be installed to get SSL certificates for HTTPS connections. Install this package if you run into trouble making HTTPS connections.# =&gt; 或者单独安装，这样比较省硬盘# =&gt; festival 用于MP的语言输出~ $ sudo apt-get install mono-runtime libmono-system-windows-forms4.0-cil libmono-system-xml-linq4.0-cil libmono-system-management4.0-cil libmono-system-web4.0-cil libmono-corlib4.5-cil libmono-system-numerics4.0-cil festival~ $ mono MissionPlanner.exe If the .NET program does run well under Mono then running it with Mono would be a better choice. You can extract the executables from the MSI using something like 7zip. It’s like this: Program -&gt; Mono (Framework) -&gt; System Versus Program -&gt; .NET (Framework) -&gt; WINE -&gt; System 然后下载Mission Planner的ZIP版本，解压运行即可。 1~ $ wget http://ardupilot.com/wp-content/plugins/download-monitor/download.php?id=83 对于apm_planner2可以选择安装linux版 12~ $ wget http://firmware.diydrones.com/Tools/APMPlanner/apm_planner2_latest_ubuntu_trusty64.deb~ $ sudo dpkg -i apm_planner2_latest_ubuntu_trusty64.deb 参考文章User Manual: http://copter.ardupilot.com/Developer Manual: http://dev.ardupilot.com/]]></content>
      <categories>
        <category>飞控</category>
      </categories>
      <tags>
        <tag>ArduPilot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux下sublime text 2使用技巧]]></title>
    <url>%2F2017%2F06%2F16%2Flinux%E4%B8%8Bsublime-text-2%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[由于sublime的多平台性，以及也有很多强悍的插件可供使用，是我不得不将兴趣移植这个编辑器上面来。将查看代码而言，在linux下也可以通过wine安装sourceinsight，但是对于安装跟使用来说不是很方便，特别是有git项目的时候。 安装首先下载安装文件。将下载好的文件解压至/opt，然后创建链接文件。 1$ ln -s /opt/Sublime\ Text\ 2/sublime_text /usr/bin/ 下面解决不能输入中文的问题保存下面的代码到文件sublime_imfix.c(位于~目录，即主文件夹目录) 12345678910111213141516171819202122#include &lt;gtk/gtkimcontext.h&gt;void gtk_im_context_set_client_window (GtkIMContext *context, GdkWindow *window)&#123; GtkIMContextClass *klass; g_return_if_fail (GTK_IS_IM_CONTEXT (context)); klass = GTK_IM_CONTEXT_GET_CLASS (context); if (klass-&gt;set_client_window) klass-&gt;set_client_window (context, window); g_object_set_data(G_OBJECT(context),"window",window); if(!GDK_IS_WINDOW (window)) return; int width = gdk_window_get_width(window); int height = gdk_window_get_height(window); if(width != 0 &amp;&amp; height !=0) gtk_im_context_focus_in(context);&#125; 将上一步的代码编译成共享库libsublime-imfix.so，命令如下： 123$ cd ~$ gcc -shared -o libsublime-imfix.so sublime_imfix.c pkg-config --libs --cflags gtk+-2.0 -fPIC$ sudo mv libsublime-imfix.so /usr/lib 创建/usr/bin/sublcn，输入 12#!/bin/shLD_PRELOAD=/usr/lib/libsublime-imfix.so exec sublime_text "$@" 之后打开权限 12cd /usr/binsudo chmod 777 ./sublcn 下面通过sublcn命令打开sublime text 2就可以输入中文了。 查看代码sublime快捷键参考文章：木木木 多行编辑： ctrl+左键 , Ctrl+Shift+L 文件切换： ctrl+p 搜索项目中的文件，支持模糊匹配 ctrl+r：列出当前文件中的所有函数，同ctrl+p后按一个@符号一样，其实可以把ctrl+r理解成ctrl+p的快捷键 全局替换搜索 ： ctrl+shift+f 函数查找 ctrl+p 然后输入@，加上# 和 @ 分别为变量和函数，其实搜变量也能搜到函数 跳到指定行 ctrl+p 然后输入’:’ ctrl+f：当前文件中查找关键字 跳到某个类某个方法 ctrl+p 输入 类名@函数名 调出命令面板 ctrl+shift+p F11：全屏 shift+F11：全屏免打扰模式，只编辑当前文件 Ctrl+M 光标移动至括号内开始或结束的位置 Ctrl+Shift+M 选择括号内的内容（按住-继续选择父括号） Ctrl+D 选中光标所占的文本，继续操作则会选中下一个相同的文本 Alt+F3 选中文本按下快捷键，即可一次性选择全部的相同文本进行同时编辑。举个栗子：快速选中并更改所有相同的变量名、函数名等 Alt+Shift+2 窗口两列显示 Alt+Shift+8 窗口两行显示 Ctrl+Enter 光标所在行后插入行 Ctrl+Shift+Enter 光标所在行前插入行 Ctrl+Shift+↑ 与上行互换 Ctrl+Shift+↓ 与下行互换 Ctrl+Shift+K 删除整行 Ctrl+Shift+D 复制整行 Ctrl+D 选中光标所在字符串 （按住继续选择下个相同字符串） Alt+F3 选中与光标处相同的全部词 重新打开关闭的标签：和Chrome浏览器一样，如果你不小心关闭了一个页面，你只要按下Shift+Cmd+T（Windows下按住Shift+Ctrl+T）就可以重新打开该页面。如果你连续按这样的组合键，你就可以按照关闭的顺序重新打开它们。 上下移动设置。快捷键为ctrl + up\ctrl + down。如默认为设置，需手动进行用户设置 12&#123; "keys": ["ctrl+up"], "command": "scroll_lines", "args": &#123;"amount": 1.0 &#125; &#125;,&#123; "keys": ["ctrl+down"], "command": "scroll_lines", "args": &#123;"amount": -1.0 &#125; &#125; 标签页移动。ctrl + PgUp/PgDn 行首/尾。Home/End 复制至行首/尾。shift + Home/End 文章的首部/尾部。ctrl + Home/End 工程切换：ctrl + alt + o 1&#123; "keys": ["ctrl+alt+o"], "command": "prompt_select_project" &#125; 高亮设置Sublime Text对于一些常见的扩展名的文件都能够识别并选择Sublime Text内置对应的高亮语法，但是对于一些使用频率比较少的扩展名文件就无法识别，Sublime Text打开此类文件后默认显示成普通文本，没有语法高亮。 打开文件后点击右下角的Plain Text，在出现的文件格式中选择open all with current extension as… -&gt;”需要显示的语法类型”。这样以后打开这个类型的文件就会自动进行语法高亮了。 ctags与cscope下面就想通过sublime实现类似SI的功能，毕竟这个编辑器是比较强大的。具体方案为采用ctags和cscope插件。下面参考sublime添加ctags实现代码跳转进行安装。具体为： 下载Package Control.sublime-package放入/home/username/.config/sublime-text-2/Installed Packages中，可以用如下命令行实现 12$ cd /home/username/.config/sublime-text-2/Installed\ Packages/$ wget http://sublime.wbond.net/Package%20Control.sublime-package 在sublime下快捷键Ctrl+Shift+P，输入install，选择Package Control: Install Package回车，可以点击Ctrl + `查看安装状态。如果要卸载插件， Ctrl+Shift+P 输入 remove， 选择Package Control: Remove Package 然后再选择已安装的插件， 回车即可卸载。 现在开始安装ctags的插件，在package control中选择install package，搜索ctags就能找到ctags的插件，安装之。 到这里ctags就安装好了，肯定无法使用，必须系统中有ctags才能用，安装ctags如下： 1$ sudo apt-get install ctags 这时在侧左栏的工程/项目文件上右键会看到CTags: Rebuild Tags菜单项就是可用的了，点击建立.tags文件完成后进行如下操作。 也可以用命令生成.tags文件 12345678910111213141516171819#=&gt; 进入主目录$ ctags -R -f .tags``` 这时再选中一个函数，右键打开Navigate to Definition菜单项并执行，当然这里可以用[快捷键](https://github.com/SublimeText/CTags)： Command | Key Binding | Alt Binding | Mouse Binding------------------|---------------------------------|---------------|-------------------rebuild_ctags | ctrl+t, ctrl+rnavigate_to_definition | ctrl+t, ctrl+t |ctrl+&gt; |ctrl+shift+left_clickjump_prev | ctrl+t, ctrl+b | ctrl+&lt; | ctrl+shift+right_clickshow_symbols | alt+sshow_symbols (all files) | alt+shift+sshow_symbols (suffix) | ctrl+alt+shift+s也可以自定义热键。&lt;img src="/images/ctags.png" alt=""&gt;输入如下： { &quot;command&quot;: &quot;navigate_to_definition&quot;, &quot;keys&quot;: [&quot;ctrl+shift+period&quot;] }, { &quot;command&quot;: &quot;jump_prev&quot;, &quot;keys&quot;: [&quot;ctrl+shift+comma&quot;] } 1234564. ctags用官方的解释就是产生标记文件，帮助在文件中定位对象。其实就是你可以找到一个对象的定义处。更多请查看[Sublime之Ctags](http://ju.outofmemory.cn/entry/36068)5. 搜索下载cscope插件。这里参考了[使用Sublime Text3+Ctags+Cscope替代Source Insight](https://www.zybuluo.com/lanxinyuchs/note/33551)。 下载cscope ```sh $ sudo apt-get install cscope 在工程目录下执行命令 12345#=&gt; R 表示把所有子目录里的文件也建立索引#=&gt; b 表示cscope不启动自带的用户界面，而仅仅建立符号数据库#=&gt; q 生成cscope.in.out和cscope.po.out文件，加快cscope的索引速度#=&gt; k 在生成索引文件时，不搜索/usr/include目录$ cscope -Rbkq 或者如下安装好Ctags和Cscope工具之后，可以在想要导入的工程的根路径下，通过下面命令建立Cscope索引数据库和.tags文件。 123find . -name "*.h" -o -name "*.c" -o -name "*.cc" -o -name "*.S" -o -name "*.ch" -o -name "*.cpp" &gt; cscope.filescscope -bkq -i cscope.filesctags -R -f .tags 热键： + `Ctrl/Super + \` - Show Cscope options + `Ctrl/Super + L``Ctrl/Super + S` - Look up symbol under cursor + `Ctrl/Super + L``Ctrl/Super + D` - Look up definition under cursor + `Ctrl/Super + L``Ctrl/Super + E` - Look up functions called by the function under the cursor + `Ctrl/Super + L``Ctrl/Super + R` - Look up functions calling the function under the cursor + `Ctrl/Super + Shift + [` - Jump back + `Ctrl/Super + Shift + ]` - Jump forward 进入cscope查找结果后，按回车即可进入结果相应页面。 sublime部分插件下面安装的这些插件可有可无，但是安装他们并熟练运用将成为你得力的助手。参考文章：实用的sublime插件集合 – sublime推荐必备插件/Sublime插件：C语言篇 Tip:已安装插件具体请查看/home/username/.config/sublime-text-2/Packages Terminal插件 Terminal插件可以允许在Sublime Text2中打开cmd命令窗口，很实用的一个插件，安装好该插件好，打开cmd命令窗口的快捷键是 Ctrl+Shift+T。可在Preferences -&gt; Package Setting找到README。 DocBlockr插件 用来生成注释块的插件，安装好之后直接输入”/*”，然后再按回车键，即可生成代码注释块。它会解析函数，变量，和参数，根据它们自动生成文档范式，你的工作就是去填充对应的说明。 SublimeCodeIntel插件 代码自动提示 MarkDown Editing插件支持Markdown语法高亮；支持Github Favored Markdown语法；自带3个主题。 Git插件 该插件基本上实现了git的所有功能。设置git推送 1234git push --set-upstream origin mastergit config --global push.default simple#=&gt; 先进行绑定git push -u origin master Emmet插件 Emmet作为zen coding的升级版，对于前端来说，可是必备插件，如果你对它还不太熟悉，可以在其官网上看下具体的演示视频。 BracketHighlighter插件 可匹配[], (), {}, “”, ”, ，高亮标记，便于查看起始和结束标记 AutoFileName插件 自动完成文件名的输入，如图片选取 FileDiffs插件 比较当前文件与选中的代码、剪切板中代码、另一文件、未保存文件之间的差别。可配置为显示差别在外部比较工具，精确到行。 Git​Gutter插件指示代码中插入、修改、删除的地方 Alignment插件选中并按ctrl+alt+a就可以使其按照等号对齐 C Improved插件更加人性化的C语言着色方案。设置如下： 对比效果： CoolFormat插件简单好用的代码格式化工具，相当于简化版的Astyle，默认ctrl+alt+shift+q格式化当前文件，ctrl+alt+shift+s格式化当前选中。 格式设置 SublimeAStyleFormatter插件国人做的Astyle Sublime版，蛮不错的。安装完成之后，下面这个配置一定要打开，即保存自动格式化，这个相比于CoolFormat要简单很多。 配置 All Autocomplete插件Sublime自带的可以对当前文件中的变量和函数名进行自动提示，但是AllAutocomplete可以对打开的所有文件的变量名进行提示，增强版的代码自动提示符。 Extend Sublime autocompletion to find matches in all open files of the current window Markdown Extended + Monokai Extended插件不错的Markdown主题，支持对多种语言的高亮 HexViewer插件玩单片机的玩家都懂这个是很重要 TableeEitor插件Markdown中的表格书写体验真心不咋样，所有有人为这个开发了一个插件，具有较好的自适应性，会自动对齐，强迫症患者喜欢。 TrailingSpaces插件强迫症患者必备 sublimelinter插件sublimelinter是sublime的代码校验插件，它可以帮你找出错误或编写不规范的代码，支持 C/C++、CoffeeScript、CSS、Git Commit Messages、Haml、HTML、Java、JavaScript、Lua、Objective-J、Perl、PHP、Puppet、Python、Ruby 和 XML 语言。当需要对相应的语言进行代码校验的时候，就要下载相应的校验程序，例如： C/C++ - lint via cppcheck CoffeeScript - lint via coffee -s -l CSS - lint via built-in csslint Git Commit Messages - lint via built-in module based on A Note About Git Commit Messages. Haml - syntax check via haml -c HTML - lint via tidy (actually tidy for HTML5) Java - lint via javac -Xlint JavaScript - lint via built in jshint, jslint, or the closure linter (gjslint) (if installed) Lua - syntax check via luac Objective-J - lint via built-in capp_lint Perl - lint via Perl:Critic or syntax+deprecation check via perl -c PHP - syntax check via php -l Puppet - syntax check via puppet parser validate Python - native, moderately-complete lint Ruby - syntax check via ruby -wc XML - lint via xmllint Search in Project插件由于不是c文件的文件不能被ctags和cscope搜索到，所以建议安装这个插件。比较一下速度，选用了pt引擎，需下载安装。快捷键为Ctrl+Alt+Shift+F，这种方法相对sublime 自身的全局搜索Ctrl+Shift+F要快一些。 用户设置为 1"search_in_project_engine": "the_platinum_searcher" 效果如下 Translate翻译插件直接通过Package Control搜索Translate下载安装。快捷键为”ctrl+1” 和 “ctrl+2”。 ChineseTranslator(sublime text 3)插件快捷键为Ctrl+shift+c，启动插件后，若此时有文本被选中，则会出现一个面板显示翻译结果。 工程设置建议参考译:Sublime Text 2 项目设置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&#123; &quot;folders&quot;: [ &#123; // theme &quot;path&quot;: &quot;/C/wamp/www/wordpress/wp-content/themes/twentyeleven&quot;, &quot;name&quot;: &quot;Twenty Eleven Theme&quot;, &quot;file_exclude_patterns&quot;:[ &quot;._*&quot;, &quot;*.ico&quot;, &quot;*.swf&quot; ], &quot;folder_exclude_patterns&quot;: [ &quot;images&quot; ] &#125;, &#123; // plugins folder &quot;path&quot;: &quot;/C/wamp/www/wordpress/wp-content/plugins&quot;, &quot;name&quot;: &quot;Plugins Folder&quot;, &quot;file_exclude_patterns&quot;:[ &quot;._*&quot;, // you need to specify this *again* &quot;*.bak&quot;, &quot;*.sample&quot;, &quot;*.tar&quot;, &quot;*.tgz&quot;, &quot;*.zip&quot; ], &quot;folder_exclude_patterns&quot;: [ &quot;akismet&quot;//, // add any other plugins you wish to exclude ] &#125; ], &quot;settings&quot;: &#123; &quot;tab_size&quot;: 4 &#125; &quot;build_systems&quot;: [ &#123; &quot;name&quot;: &quot;PX4: make all&quot;, &quot;working_dir&quot;: &quot;$&#123;project_path&#125;&quot;, &quot;file_regex&quot;: &quot;^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$&quot;, &quot;cmd&quot;: [&quot;make&quot;], &quot;shell&quot;: true &#125;, &#123; &quot;name&quot;: &quot;PX4: make and upload&quot;, &quot;working_dir&quot;: &quot;$&#123;project_path&#125;&quot;, &quot;file_regex&quot;: &quot;^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$&quot;, &quot;cmd&quot;: [&quot;make upload px4fmu-v2_default -j8&quot;], &quot;shell&quot;: true &#125;, &#123; &quot;name&quot;: &quot;PX4: make posix&quot;, &quot;working_dir&quot;: &quot;$&#123;project_path&#125;&quot;, &quot;file_regex&quot;: &quot;^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$&quot;, &quot;cmd&quot;: [&quot;make posix&quot;], &quot;shell&quot;: true &#125; ]&#125; 版本升级尝试使用新版本sublime text 3，安装方式如下 1234#首先下载安装文件~ $ wget https://download.sublimetext.com/sublime-text_build-3114_amd64.deb#安装~ $ sudo dpkg -i sublime-text_build-3114_amd64.deb 最后程序可以通过subl命令打开，同样解决输入中文问题参考第一节。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>sublime-text-2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初学PX4之大体构架]]></title>
    <url>%2F2017%2F06%2F16%2F%E5%88%9D%E5%AD%A6PX4%E4%B9%8B%E5%A4%A7%E4%BD%93%E6%9E%84%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[PX4源代码PX4项目建立在这些主要软件模块: PX4 Flight Stack (estimation and control, cross-platform) PX4 Middleware (IPC / ORB, *nix (NuttX, Linux, MacOS, etc)) PX4 ESC Firmware (for motor controllers) PX4 Bootloader (for STM32 boards) Operating System (NuttX or Linux/Mac OS) 项目地址： PX4 Firmware source PX4飞行栈 PX4飞行栈能控制多轴飞行器，航模，直升机，实验飞机和地面车辆的飞行。它由一组单独的应用程序/节点组成。 flight control modules PX4中间件 PX4中间件提供了硬件接口和进程间通信。 drivers uORB PX4电调固件 PX4电调固件控制无刷电机，可以通过UAV CAN进行交互。 PX4 ESC source PX4 Bootloader PX4引导装载程序是用于STM32微控制器新飞行软件加载到闪存。用于Pixhawk。 PX4 Bootloader source 操作系统 PX4飞行栈和中间件可以在微控制器Nuttx小型操作系统上执行，或者在全面POSIX系统，如Linux，Mac OS 或 BSD。 NuttX OS Tip:px4编译系统使用的是cmake，关于cmake与make的区别见CMake与Make 代码运行分析 关于系统的启动过程请查看我之前文章里的系统启动。 知道了系统的启动过程，那么就知道代码运行的思路基本上就是脚本rcS的写法了，如果你想深入了解NSH启动脚本的自定义，可以参考定制NSH初始化，所以下面就从脚本开始看起。 首先通过sercon开启串口驱动CDC/ACM，这样才能打印出下面echo出的串口信息。 设置模式为自动启动。 再设置文件路径如下 12345set FRC /fs/microsd/etc/rc.txtset FCONFIG /fs/microsd/etc/config.txtset LOG_FILE /fs/microsd/bootlog.txt#=&gt; 运行出错时会发出下面的声音set TUNE_ERR ML&lt;&lt;CP4CP4CP4CP4CP4 挂载microSD卡&quot;mount -t vfat /dev/mmcsd0 /fs/microsd&quot;，如果/dev/mmcsd0不存在，还要创建文件系统&quot;mkfatfs /dev/mmcsd0&quot;，这里边调用了tone_alarm应用来根据声音判断，这个应用可以在源代码里找到，如果你使用了Qt creator，你可以这样搜到它。 可以看出函数的原定义是这样的，借助于IDE可以很快的查出应用程序的来龙去脉，后面碰到的应用都可以这样去查看。 接着分析，接下来很关键的一步，检查是否存在/fs/microsd/etc/rc.txt，如果存在，执行它，设置模式被设置为自定义，否则为默认的自动启动。一般情况是没有的，因为etc/rc.txt文件的创建将完全禁用内置启动进程，高级用户可以这样做而已。 然后就是自动启动的一些东西。 由nshterm /dev/ttyACM0 &amp;启用/dev/ttyACM0串口； 启动uorb； 载入/fs/microsd/params里的参数（一般是由mtd将其载入ram中，然后路径变为/fs/mtd_params），param应用功能比较多，如select select/select load/select compare； 对比参数RC_MAP_THROTTLE、RC_MAP_ROLL、RC_MAP_PITCH、RC_MAP_YAW并保存默认值； 启动系统状态指示灯； 设置这些参数的默认值，一般为none； 判断SYS_AUTOCONFIG，设置AUTOCNF为yes； 根据板子型号设置USE_IO； SYS_AUTOSTART设置，启动/etc/init.d/rc.autostart脚本，从nsh里可以看到，在这个脚本里调用机身配置文件； 打开用户设置文件etc/config.txt设置参数，如果存在的话； 保存参数； crc校验/etc/extras/px4io-v2.bin是否需要更新及启动px4io打开电机是否安全； 设置输出模式OUTPUT_MODE； 启动航点存储； 启动传感器/etc/init.d/rc.sensors、GPS； 开始主输出TTYS1_BUSY； 启动commander； 检查UAVCAN是否可用； 根据OUTPUT_MODE，启动px4io，运行/etc/init.d/rc.io、fmu、mkblctrl、pwm_out_sim； 开启mavlink； 运行/etc/init.d/rc.uavcan； 运行/etc/init.d/rc.logging； 根据VEHICLE_TYPE启动设置（如四轴：rc.interface/rc.mc_apps），姿态估计、控制算法在/etc/init.d/rc.interface里，mixer导入在/etc/init.d/rc.mc_apps里； 启动导航navigator； 运行etc/extras.txt； 自启动完后告诉MAVLink app启动完成；启动光流； 下面就可以单独的研究应用软件了。 总个程序运行的框架如下： 下面给出一个大神的图： 参考文件：PX4 Source Code/Nuttx系统启动/NuttX 编译系统]]></content>
      <categories>
        <category>飞控</category>
      </categories>
      <tags>
        <tag>PX4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BLE核心模块FS-QN9021模块开发-linux版]]></title>
    <url>%2F2017%2F06%2F16%2FBLE%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97FS-QN9021%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91-linux%E7%89%88%2F</url>
    <content type="text"><![CDATA[这段时间又参与了一个新的小项目，简单概括为蓝牙、智能、家居吧，虽然时间有点紧，还是希望能把这一些东西记录下来。 BLE什么是BLE？参考这篇文章做如下总结。中文名称为蓝牙低功耗。主要特点为低成本、超低功耗、短距离、标准接口和可互操作性强，并且工作在免许可的2.4GHz ISM射频段，需要支持蓝牙4.0（系统为Android4.3及以上）的主机设备才能与其连接。 目前生产BLE芯片的厂家主要有CSR、TI、Nodic和NXP（QN902x），各个厂家芯片对比如下图 从如上图对比可以看出，NXP的QN902x在功耗方面比CSR和TI更省电，在接收灵敏度和模式方面比Nodic的胜一筹，它的从设备相比其它几家可以连接的更多，共有8个，这也算是蓝牙4.0的一大特色吧，并且NXP的芯片已经过了MFI认证，直接能与苹果设备相连接，因为这种认证也是挺贵的。 因为BLE的低功耗、低成本及强大的处理能力，并且随着iPhone的设备支持蓝牙4.0，BLE的终端设备在我们的生活当中将会越来越多，在未来将会有爆发式增长。 QN902X是一款内核为M0的蓝牙BLE SOC芯片，其SDK对蓝牙BLE的profile都有实现，并提供源码，SDK也提供很多工具以便使用芯片，比如引脚配置，NVDS读写，串口USB Dongle(配合上位机可以调试各profile，没有手机也可以调试)，ISP下载等，但QN902X不提供数据手册，所有的外设操作都以库的方式提供，SDK说明比较全面但全是英文的。 与NODRDIC的51822和TI的CC2540不同QN902X的架构是M0+ROM+FLASH+SRAM的方式，其中ROM放的是蓝牙协议和内部一个小的调度核，FLASH放的是用户程序和数据，RAM用于跑程序。其中ROM:96K，SRAM:64K，FLASH:64K/128K。因为QN902X程序是跑到SRAM中，所以它的深度睡眠电流比较大些。 环境搭建老生长谈，开发一款产品，第一步当然是搭建开发环境咯。 wine安装由这里可知，keil不支持linux环境，所以必须自己想办法了。这是在linux环境下运行windows的程序，本身使用windows的请自动忽略这一步。具体请看官网/博文。 12345678~ $ sudo add-apt-repository ppa:ubuntu-wine/ppa~ $ sudo apt-get update# =&gt; 我的是64为的系统，所有安装64位版~ $ sudo apt-get install wine1.8-amd64# =&gt; 配置~ $ winecfg# =&gt; 中文路径：~/ .wine/drive_c/windows/Fonts/~ $ winetricks corefonts keil安装首先得下载keil，可以自己去官网下载最新的，也可以直接点击mdk5.17下载地址，参考这篇博文并实践做如下记录。 12# =&gt; 进入下载目录安装~ $ wine mdk517.exe 提示：卸载程序可以用wine uninstaller如编译有限制，下载破解注册机Keygen：http://pan.baidu.com/s/1hqGSRqs 安装完成后，会弹出来一个安装器件（pack installer）如下的界面，也就是说，你要用它来开发哪个芯片（此项目可以忽略，后面步骤导入DB）。 或者打开keil界面会看到如下图标 要开发哪一款芯片，点击install即可，或者先网页端下载好在导入，具体参考上面提供的博文地址。 MCU DB库安装下载Quintic最新的SDKQBlue1.3.7，安装： 1~ $ wine QBlue-1.3.7.exe 会弹出窗口如下，点击安装即可，或者打开桌面QBlue里的QN9020DevDBforIDE工具安装。 keil使用首先获取开源代码 12~ $ cd~ $ git clone git@bitbucket.org:T-Firefly/fireble.git 桌面打开keil，假如我们希望开始proxr工程： 在keil的Project菜单中选择Open Project… 弹出文件选择框中，打开/home/xxx/fireble/BLE/prj_proxr/keil/proxr.uvproj工程文件（linux可能在z磁盘里） 配置DB如下，如果没发现库，请重启软件 编译代码，成功后如下，具体配置选项请参考这里 下载程序，下载的时候需要按复位键，如下载出错，可先下载到SRAM。 Tip:在ubuntu 上串口识别为ttyS0或ttyUSB0之类，在wine上识别不到，可用： 1234&gt;# =&gt;将其该为小写的com1，如果不行，将其改为大写的COM1&gt;~ $ sudo ln -s /dev/ttyUSB0 ~/.wine/dosdevices/com1&gt;~ $ sudo usermod -a -G dialout $USER&gt;~ $ sudo chmod 777 ~/.wine/dosdevices/com1 即可在wine的应用程序使用串口 项目实践点亮LED对于新的芯片与开发板，从LED实验开始。首先下载该开发板的原理图对该LED部分的电路进行分析。 本程序非常简单，复制gpio demo代码 实现让开发板D1灯闪烁如下： 123456789/* Set pin D1/P2_7 */gpio_set_direction_field(GPIO_P27, (uint32_t)GPIO_OUTPUT);while(1)&#123; gpio_write_pin_field(GPIO_P27, GPIO_LOW); delay(100000); gpio_write_pin_field(GPIO_P27, GPIO_HIGH); delay(100000);&#125; 程序流程：系统初始化–&gt;GPIO配置–&gt;各驱动模块初始化–&gt;主循环实现功能效果如下： UART实验串口通信可以用来打印数据，调试程序，有必要实验一下。同样复制uart demo代码改程序如下： 123//Print out "Hello NXP!\n" thought uart.uart_printf(QN_UART0, (uint8_t *)"Hello NXP!\n");uart_printf(QN_UART0, (uint8_t *)"This is nephen's test!\n"); 波特率设置为115200，现象如下： PWM实验由于这个项目会控制到电机什么的，所以pwm少不了，这个实验是通过pwm控制陶瓷蜂鸣器报警和呼吸灯。通过PWM方式调节脉冲频率和占空比，变换LED亮度，渐变亮度实现呼吸灯效果。FireBLE板载的贴片蜂鸣器是压电式陶瓷蜂鸣器，压电陶瓷蜂鸣器要想响起来，需要满足四个条件：多谐振荡器、压电蜂鸣片、阻抗匹配器及共鸣箱，压电蜂鸣片由锆钛酸铅或铌镁酸铅压电陶瓷材料制成，在陶瓷片的两面镀上银电极，经极化和老化处理后，再与黄铜片或不锈钢片粘在一起。板载的蜂鸣器缺少的只是多谢振荡器，这里我们用PWM来代替，输出1.5KHz-2.5KHz的方波信号推动压电蜂鸣片发声，频率在1.5KHz-2.5KHz才会响，太高太低都不响，直接加3.3V更不会响，直接加3.3V响的那是电磁式蜂鸣器，有源和无源。首先看下电路连接 同样复制pwm代码，改写如下： 12345678910111213141516171819202122232425262728293031int main (void)&#123; SystemInit(); pwm_init(PWM_CH0); pwm_io_config(); //P2.7 will output pwm wave with period for 1000us and pulse for 400us pwm_config(PWM_CH0, PWM_PSCAL_DIV, PWM_COUNT_US(1000, PWM_PSCAL_DIV), PWM_COUNT_US(500, PWM_PSCAL_DIV)); pwm_enable(PWM_CH0, MASK_ENABLE); pwm_io_dis_config(); pwm_init(PWM_CH1); pwm_io_config(); //P2.6 will output pwm wave with period for 1000us and pulse for 500us pwm_config(PWM_CH1, 119, PWM_COUNT_US(1000, 119), PWM_COUNT_US(500, 119)); pwm_enable(PWM_CH1, MASK_ENABLE); while (1) /* Loop forever */ &#123; int i; for(i=0;i&lt;=1000;i++) &#123; pwm_config(PWM_CH1, 119, PWM_COUNT_US(1000-i, 119), PWM_COUNT_US(500, 119)); if(i%2) pwm_config(PWM_CH0, PWM_PSCAL_DIV, PWM_COUNT_US(1000-i, PWM_PSCAL_DIV), PWM_COUNT_US(500, PWM_PSCAL_DIV)); else pwm_config(PWM_CH0, PWM_PSCAL_DIV, PWM_COUNT_US(i, PWM_PSCAL_DIV), PWM_COUNT_US(500, PWM_PSCAL_DIV)); delay(2000); &#125; &#125;&#125; 呼吸灯效果： 按键广播看到有些人对买的fireBLE按键广播不懂，其实刚开始我也是这样的，摸不着头脑，现在至少不会太迷糊，就给大家记录下吧。首先按键按下属于gpio中断，找到中断初始化函数：SystemInit(); ——》 gpio_init(gpio_interrupt_callback); ——》 void gpio_interrupt_callback(enum gpio_pin pin) ——》 void usr_button1_cb(void) ——》 ke_evt_set(1UL &lt;&lt; EVENT_BUTTON1_PRESS_ID); 找到EVENT_BUTTON1_PRESS_ID对应的事件，搜索EVENT_BUTTON1_PRESS_ID，找到void usr_init(void)里的if(KE_EVENT_OK != ke_evt_callback_set(EVENT_BUTTON1_PRESS_ID, app_event_button1_press_handler))可知为app_event_button1_press_handler ——》ke_timer_set(APP_KEY_SCAN_TIMER,TASK_APP,2); 同样通过搜索APP_KEY_SCAN_TIMER可知定时器事件为app_key_scan_timer_handler ——》app_key_scan_timer_handler，这里进行adc采集，完成后由adc_read(&amp;read_cfg, adc_key_value, KEY_SAMPLE_NUMBER, adc_test_cb);可知进入adc_test_cb，在这里设置了EVENT_ADC_KEY_SAMPLE_CMP_ID，搜索找到对应事件app_event_adc_key_sample_cmp_handler ——》app_event_adc_key_sample_cmp_handler，判断按键朝哪个方向按，定时回调 ——》app_key_process_timer_handler，如下： 1234567891011121314151617int app_key_process_timer_handler(ke_msg_id_t const msgid, void const *param, ke_task_id_t const dest_id, ke_task_id_t const src_id)&#123; ke_evt_clear(1UL &lt;&lt; EVENT_ADC_KEY_SAMPLE_CMP_ID); switch (key_value0) &#123; case key_up: if (APP_IDLE == ke_state_get(TASK_APP)) &#123; // start adv //QPRINTF("you press up key\r\n!"); app_gap_adv_start_req(GAP_GEN_DISCOVERABLE | GAP_UND_CONNECTABLE, app_env.adv_data, app_set_adv_data(GAP_GEN_DISCOVERABLE), app_env.scanrsp_data, app_set_scan_rsp_data(app_get_local_service_flag()), GAP_ADV_FAST_INTV1, GAP_ADV_FAST_INTV2); 这里一看就明白，向上按时，进入广播。其实在系统上电的时候，已经进行了一系列的gap建立连接的初始话，就差广播了，所以这里只要广播出去就能和别的蓝牙建立连接。 QTool使用及蓝牙了解使用QBlueStudio中QTool工具进行蓝牙开发分析，可以方便的对各个蓝牙操作的过程进行细致的研究，并结合具体的源代码进行查看，能够更加深入的了解到蓝牙协议的实现过程，大部分的API接口在GAP和GATT。具体的使用文档请查看QBlueStudio里的Document。Linux里可以采取这种方法查看：地址见/home/username/.wine/drive_c/QBlue/QN9020/QBlue-1.3.7/Documents，然后使用evince命令打开。 在这之前，还需对蓝牙的一些术语做一个大概的了解，比如什么是master，slave，主机。客户端与服务器又是什么。GAP与GATT有什么区边。蓝牙各个协议层都有哪些分工。下面参考做一些归纳： BLE规范中定义了GAP（Generic Access Profile）和GATT(Generic Attribute)两个基本配置文件。a.协议中的GAP层负责设备访问模式和进程，包括设备发现，建立连接，终止连接。初始化安全特性和设备配置。b.GATT层用于已连接的蓝牙设备之间的数据通信。GATT通俗理解为用于主从机之间的客户端和服务器端的数据交互，以Attribute Table来体现。 BLE低功耗蓝牙中有四种设备类型，Central主机,Peripheral从机,Observer观察者,Broadcaster广播者。通常Central主机,Peripheral从机一起使用，Observer观察者,Broadcaster广播者一起使用。Central和Peripheral连接交换数据，平时我们使用到的基本上是这种模式。而像多温度采集器，通常使用Observer和Broadcaster这种无连接形式。主机和从机是这样开机工作的:从机开始广播，然后主机扫描广播的从机，当从机收到主机的扫描请求后，会向主机发送扫描回应数据。然后主机发起连接，然后开始通讯。所以从机需要设置广播内容和扫描回应内容。这方面的代码可以查看App_gap.c和App_gap_task.c。 profile：可以理解为一种规范，一个标准的通信协议，profile存在于从机中。蓝牙组织规定了一系列的标准profile，如防丢计、心率计。每个profile中包含多个service，每个service代表从机的一种能力。 Service：可以理解为一种服务，在BLE从机里，通过有多个服务，例如电量信息服务、系统信息服务等。每个service又包含多个characteristic特征值。每个具体的characteristic特征值才是BLE通讯的主体，比如当前电量是80%。所以会通过电量的characteristic特征值特征值保存在从机的profile里，这样主机就可以通过这个characteristic来读取80%这个数。 characteristic：characteristic特征值，BLE主从机均是通过characteristic来实现，可以理解为一个标签，通过这个标签可以获取或者写入想要的内容。 UUID：统一标识吗，我们刚提到的characteristic和service，都需要一个唯一的UUID来标识。 每个从机都会有个叫做profile的东西存在，不管自定义的还是标准的profile，他们都是由一系列的Service组成，然后每个service又包含多个characteristic，主机和从机之间的通信，均是通过characteristic来实现。BLE协议栈中传输数据分为两方面，一个GATT的client主动向service发送数据。另一个是GATT的service主动向client发送数据。即主从之前相互传数据。主机向从机发送数据，使用GATT_Write从机向主机发送数据，使用GATT_Notification GATT有Service和Client，Service作为服务器端，对GATT Client提供read/write接口，一般情况下，Central作为Client，Peripheral作为Service。所以主机会调用read/write来和作为Service端的Peripheral从机通讯。而Peripheral则通过notify的方式即调用GATT_Notifycation发起和主机通讯。 特征值声明值可以有五种属性：Read(可读) Write(可靠的可写,带响应) Write without resp(不可靠的可写,不带响应) Indicate(可靠通知，带响应) Notify（不可靠通知，不带响应） 更多请查看蓝牙设计问与答 /Android 蓝牙4.0 BLE 理解 BLE中主从机建立连接，到配对和绑定的过程如下图。 QPPS工程在此之前，建议先了解一下Firefly的QPPS介绍/对QPPS profile中服务和特征实现的分析理解/对profile QPPS的分析理解。关于蓝牙的数据收发部分可以看Firefly的协议栈介绍。数据帧格式如下： Tip：技术案例中串口透传案例，实现的是将蓝牙模组串口所接收到的数据透传到app，并且把app的数据通过蓝牙透传到串口输出，案例本身的实现是针对串口通信和蓝牙透传的结合。 其实BLE完成初始化的条件并不是进入main函数的while（1）中（系统在调度了几个消息之后才完成的初始化，前几次进入while（1）时初始化都是没完成的），真正完成初始化并且可以运行是在打印BLE is Ready这句话的地方。那个地方你可以看到只要开启QN_DEMO_AUTO宏定义就可以上电广播了。 设备名默认从NVDS中写入，但是软件也可以修改，可以用app_gap_set_devname_req修改设备名。 如果你非要用软件指定，参考广播内容设定，取消NVDS读取，直接利用app_gap_set_devname_req函数指定设备名，然后将QN_LOACL_NAME广播出去，那么设备名和广播中的设备名都会是QN_LOCAL_NAME了。 具体实施如下 修改自动广播，无需向上拨动按键： 12#=&gt; App_config.h中，取消如下的注释即可#define QN_DEMO_AUTO 1 在广播之前改变设备的名字，注意app_set_adv_data函数 12345678//Set remote device nameapp_gap_set_devname_req("nephen",6);// Created DB should has been finished by each profile service,// Start Adv mode automatically hereapp_gap_adv_start_req(GAP_GEN_DISCOVERABLE|GAP_UND_CONNECTABLE, app_env.adv_data, app_set_adv_data(GAP_GEN_DISCOVERABLE), app_env.scanrsp_data, app_set_scan_rsp_data(app_get_local_service_flag()),GAP_ADV_FAST_INTV1, GAP_ADV_FAST_INTV2); 接收手机app中9600可写属性发送的数据。由下面Qpps_task.c可知，当有数据到达蓝牙时，会触发gatt_write_cmd_ind_handler，同理，发送数据触发qpps_data_send_req_handler，得到通知触发gatt_notify_cmp_evt_handler，app层对应的api是app_qpps_data_send_cfm_handler、app_qpps_data_ind_handler、app_qpps_cfg_indntf_ind_handler，下文会提到，只会对这些做修改 1234567/// Connected State handler definition.const struct ke_msg_handler qpps_connected[] =&#123; &#123;QPPS_DATA_SEND_REQ, (ke_msg_func_t) qpps_data_send_req_handler&#125;, &#123;GATT_WRITE_CMD_IND, (ke_msg_func_t) gatt_write_cmd_ind_handler&#125;, &#123;GATT_NOTIFY_CMP_EVT, (ke_msg_func_t) gatt_notify_cmp_evt_handler&#125;,&#125;; 而在gatt_write_cmd_ind_handler函数里，会对QPPS_IDX_RX_DATA_VAL属性进行处理 12345678910111213141516171819202122else if (param-&gt;handle == (qpps_env.shdl + QPPS_IDX_RX_DATA_VAL)) &#123; if (param-&gt;length &lt;= QPP_DATA_MAX_LEN) &#123; //inform APP of configuration change struct qpps_data_val_ind * ind = KE_MSG_ALLOC_DYN(QPPS_DAVA_VAL_IND, qpps_env.appid, TASK_QPPS, qpps_data_val_ind, param-&gt;length); memcpy(&amp;ind-&gt;conhdl, &amp;(qpps_env.conhdl), sizeof(uint16_t)); //Send received data to app value ind-&gt;length = param-&gt;length; memcpy(ind-&gt;data, param-&gt;value, param-&gt;length); ke_msg_send(ind); &#125; else &#123; status = QPPS_ERR_RX_DATA_EXCEED_MAX_LENGTH; &#125; &#125; 再由上面的QPPS_DAVA_VAL_IND可知会跳到下面这个函数，在这里对接收到的数据进行处理 1234567891011121314151617181920int app_qpps_data_ind_handler(ke_msg_id_t const msgid, struct qpps_data_val_ind *param, ke_task_id_t const dest_id, ke_task_id_t const src_id)&#123; uint8_t i; if (param-&gt;length &gt; 0) &#123; QPRINTF("len=%d, I%02X", param-&gt;length, param-&gt;data[0]); QPRINTF("\r\n"); QPRINTF("the receive data is :"); for(i=0;i&lt;param-&gt;length;i++) &#123; QPRINTF("%x",param-&gt;data[i]); &#125; &#125; QPRINTF("\r\n"); return (KE_MSG_CONSUMED);&#125; 当发送数据为29时，CuteCom蓝牙接收数据为 12345678910QN BLE is ready.Set device name completeAdvertising start.Connection with 1FDA7E9F8E30 result is 0x0.LTK request indication idx is 0, auth_req is 0.Start encryption complete, idx 0, status 0, key_size 0, sec_prop 1, bonded 0.Slave update success.Update parameter complete, interval: 0xc, latency: 0x0, sup to: 0x12c.len=1, I29the receive data is :29 App收取蓝牙通知。通过点击app上5个特征的通知，能获取蓝牙模块的实时通知。Gatt层与通知相关的函数是qpps_data_send_req_handler，但我们只需要修改app开头的api即可完成相应的开发，现象及分析如下： 当点击app上的通知时，会进入如下的函数，为了调试将其调整为如下： 12345678910111213141516171819202122232425262728293031323334int app_qpps_cfg_indntf_ind_handler(ke_msg_id_t const msgid, struct qpps_cfg_indntf_ind *param, ke_task_id_t const dest_id, ke_task_id_t const src_id)&#123; if (app_qpps_env-&gt;conhdl == param-&gt;conhdl) &#123; QPRINTF("enter app_qpps_cfg_indntf_ind_handler"); QPRINTF("\r\n"); if (param-&gt;cfg_val == PRF_CLI_START_NTF) &#123; QPRINTF("enter PRF_CLI_START_NTF"); QPRINTF("\r\n"); app_qpps_env-&gt;features |= (QPPS_VALUE_NTF_CFG &lt;&lt; param-&gt;char_index); QPRINTF("app_qpps_env-&gt;features is %d, param-&gt;char_index is %d",app_qpps_env-&gt;features,param-&gt;char_index); QPRINTF("\r\n"); // App send data if all of characteristic have been configured if (get_bit_num(app_qpps_env-&gt;features) == app_qpps_env-&gt;tx_char_num)//num is 5 &#123; QPRINTF("enter app_qpps_env-&gt;features"); QPRINTF("\r\n"); app_qpps_env-&gt;char_status = app_qpps_env-&gt;features; app_test_send_data(app_qpps_env-&gt;tx_char_num - 1); &#125; &#125; else &#123; app_qpps_env-&gt;features &amp;= ~(QPPS_VALUE_NTF_CFG &lt;&lt; param-&gt;char_index); app_qpps_env-&gt;char_status &amp;= ~(QPPS_VALUE_NTF_CFG &lt;&lt; param-&gt;char_index); &#125; &#125; return (KE_MSG_CONSUMED);&#125; 其中，param-&gt;char_index代表第几个可通知特征，app_qpps_env-&gt;tx_char_num为特征的数量5，只有当所有特征都进入通知状态时蓝牙模块才会发数据到手机app。 数据发送的过程见如下函数，这个函数中的数据val可以改为项目中的需求，如IO口状态 12345678910111213141516171819202122static void app_test_send_data(uint8_t max)&#123; uint8_t cnt; QPRINTF("enter app_test_send_data"); QPRINTF("\r\n"); for (cnt = 0; (max != 0) &amp;&amp; cnt &lt; app_qpps_env-&gt;tx_char_num; cnt++) &#123; if ((app_qpps_env-&gt;char_status &gt;&gt; cnt) &amp; QPPS_VALUE_NTF_CFG) &#123; static uint8_t val[] = &#123;0, '0', '1', '2','3','4','5','6','7','8','9','8','7','6','5','4','3','2','1','0'&#125;; // Increment the first byte for test val[0]++; max--; // Allow next notify until confirmation received in this characteristic app_qpps_env-&gt;char_status &amp;= ~(QPPS_VALUE_NTF_CFG &lt;&lt; cnt); app_qpps_data_send(app_qpps_env-&gt;conhdl, cnt, sizeof(val), val); &#125; &#125;&#125; 数据发送后，有一个发送确认函数app_qpps_data_send_cfm_handler，发送成功后手机上看到的现象是这样的 至此完成的功能为，实时反应蓝牙通知信息，app发数据控制蓝牙模块。 QTool使用QTool是一个运行在PC端的应用软件，允许用户启动两个BLE设备之间的连接，它能帮助用户分析BLE蓝牙。它是通过串口与BLE设备进行通信，通过ACI命令扮演网络处理器的作用。 打开pdf使用文档 12~ $ cd /home/nephne/.wine/drive_c/QBlue/QN9020/QBlue-1.3.7/Documents~ $ evince QBlue\ ISP\ Studio\ Manual\ v1.0.pdf 插入USB连接蓝牙模块，下载np_controller_B2.bin，然后打开QTool进入设备连接。关于界面说明见系统文档。 例如：点击Setting-Server-QPPS里的Create DB，然后进入Setting-Mode里点击Advertising，即可实现如上QPPS工程的效果。而在旁边的Local Device Traces窗口可以看到程序的大概运行过程。 参考文档 FireBLE-wiki BLE编程API参考手册 BLE软件开发手册 数据手册 QN9020快速入门 QN902x周立功版 防丢器项目 MDK-ARM PRO SET 总有“一道菜”适合你——BLE 【FireBLE试用体验】体验报告汇总 FireBLE 开发板试用汇总贴（2015.11.29更新 共收录145篇） [板块置顶] [精华] FireBLE驱动第一篇：呼吸灯 FireBLE低功耗蓝牙开发板评测 &gt; 可穿戴手环+蓝牙防丢器 esp8266]]></content>
  </entry>
  <entry>
    <title><![CDATA[初识NuttX操作系统之NSH]]></title>
    <url>%2F2017%2F06%2F16%2F%E5%88%9D%E8%AF%86NuttX%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8BNSH%2F</url>
    <content type="text"><![CDATA[这篇文章主要记录学习NuttX的过程以及对NuttX的理解，并结合apm里的px4-v2例程设置进行说明。 1.0 NuttX Operating System User’s ManualNuttX Operating System User’s Manual从软件开发者的视角为NuttX提供一般的使用信息。 2.0 NSH 启动脚本——翻译自NuttX文档1.8节，欢迎提出宝贵意见 Tip: 源码中apps/nshlib/README.txt即为说明书。 NSH 启动脚本。NSH支持选项来为NSH提供一个启动脚本。一般来说这种能力是使能CONFIG_NSH_ROMFSETC启用，但是还有几个其他相关的配置选项，见这个链接里的描述。这种能力还取决于： CONFIG_DISABLE_MOUNTPOINT 未设置 CONFIG_NFILE_DESCRIPTORS &gt; 4 CONFIG_FS_ROMFS 使能 例程演示： 1234#define CONFIG_NSH_ROMFSETC 1//CONFIG_DISABLE_MOUNTPOINT未定义#define CONFIG_NFILE_DESCRIPTORS 50#define CONFIG_FS_ROMFS 1 默认启动行为。所提供的这些做法目的是在为启动文件的使用提供极大的灵活性。本段将讨论所有配置选项设置为默认值时的一般行为。 在默认情况下，使能CONFIG_NSH_ROMFSETC将导致NSH在启动时表现如下： NSH将创建一个只读的RAM盘（ROM盘），它含有一个包含以下内容的微小的ROMFS文件系统： `--init.d/ `-- rcS 其中rcS是NSH的启动脚本。 NSH然后将挂载ROMFS文件系统到/etc，如下： |--dev/ | `-- ram0 `--etc/ `--init.d/ `-- rcS 默认情况下，rcS脚本的内容： # Create a RAMDISK and mount it at XXXRDMOUNTPOINTXXX mkrd -m 1 -s 512 1024 mkfatfs /dev/ram1 mount -t vfat /dev/ram1 /tmp NSH将在启动时执行脚本/etc/init.d/rcS(在第一个NSH提示出现前)。脚本执行后，根文件系统目录为： |--dev/ | |-- ram0 | `-- ram1 |--etc/ | `--init.d/ | `-- rcS `--tmp/ 修改ROMFS镜像。/etc目录的内容保留在文件apps/nshlib/nsh_romfsimg.h里，或者如果定义了CONFIG_NSH_ARCHROMFS则会包含在include/arch/board/nsh_romfsimg.h里。这里注意，原官方文档有误，参考这里进行改写，这部分在px4的定制中没有涉及。 12345#ifdef CONFIG_NSH_ARCHROMFS# include &lt;arch/board/nsh_romfsimg.h&gt;#else# include "nsh_romfsimg.h"#endif 为了修改启动行为，有三件事情要学习： 配置选项。额外的CONFIG_NSH_ROMFSETC配置选项将与其他的NSH-specific configuration settings一起讨论。 tools/mkromfsing.sh脚本。脚本tools/mkromfsing.sh创建nsh_romfsing.h，它不自动执行。如果你想改变创建和安装/tmp目录相关的配置设置，则必须使用tools/mkromfsimg.sh脚本重新生成该头文件。这个脚本的行为依赖三点： 已经安装的NuttX配置是怎么设置的。 genromfs工具，可从http://romfs.sourceforge.net下载，或者这里。 文件apps/nshlib/rcS.template。 rcS.template。 apps/nshlib/rcS.template文件包含一般形式的rcS文件，配置的值插入到该模板文件来产生最终的rcS文件。 总结：1.为了生成一个自定义的rcS文件，rcS.template的副本需要放到toos/，根据需要的启动行为改变。运行tools/mkromfsimg.sh创建包含ROMFS系统映像的头文件nsh_romfsimg.h，这个头文件需要复制到apps/nhslib目录，或者如果CONFIG_NSH_ARCHROMFS在NuttX配置文件中定义，那么这个自定义的板级相关的nsh_romfsimg.h文件将被复制到configs/\/include目录里使用。注意：当操作系统配置完成后，include/arch/board目录将被链接到configs/\/include目录，此目录里含有board.h和nsh_romfsimg.h。 所有的启动行为都包含在rcS.template。mkromfsimg.sh的作用是将特定的配置来设置rcS.template创建最终的rcS。 3.0 定制NuttShell——翻译自NuttX文档4.0节，欢迎提出宝贵意见概要。NuttShell (NSH)是一个简单的可用于NuttX的shell程序。它支持多种命令，是（非常）松散基于bash shell和用于unix shell编程的常用工具。本附录的段落将专注于定制NSH：添加新命令，改变初始化序列，等等。 3.1 NSH 库和NSH 初始化概要。NSH是一个库，可以在apps/nshlib发现实现。作为一个库，它可以定制成任何遵循以下描述的NSH初始化序列中的应用。作为一个例子，在 apps/examples/nsh/nsh_main.c在的代码说明如何启动NSH，逻辑也适用于您自己的自定义代码。虽然代码生成简单的作为一个例子，在大多数人只是用这个例子的代码作为应用main()功能。在下面的段落中讨论了这个例子的初始化。 3.1.1 NSH初始化序列 NSH启动顺序很简单。作为一个例子，apps/examples/nsh/nsh_main.c的代码说明如何启动NSH。简单工作如下： 如果你有C++静态初始化器，它将调用up_cxxinitialize()的执行，这个函数将依次调用这些静态初始化器。在对STM3240G-EVAL板的情况下，对up_cxxinitialize()的实施可以在nuttx/configs/stm3240g-eval/src/up_cxxinitialize.c中发现。 12345 /* Call all C++ static constructors */#if defined(CONFIG_HAVE_CXX) &amp;&amp; defined(CONFIG_HAVE_CXXINITIALIZE) up_cxxinitialize();#endif 注册BINFS文件系统。 12345678910 /* Register the BINFS file system */#if defined(CONFIG_FS_BINFS) &amp;&amp; (CONFIG_BUILTIN) ret = builtin_initialize(); if (ret &lt; 0) &#123; fprintf(stderr, "ERROR: builtin_initialize failed: %d\n", ret); exitval = 1; &#125;#endif 然后调用nsh_initialize()，它将初始化NSH库，nsh_initialize()将具体描述如下节。 如果Telnetconsole启用，它调用驻留在NSH库里的nsh_telnetstart()。nsh_telnetstart()将启动telnet守护进程来监听Telnet连接和启动远程NSH会话。 123456789101112#ifdef CONFIG_NSH_TELNET ret = nsh_telnetstart(); if (ret &lt; 0) &#123; /* The daemon is NOT running. Report the the error then fail... - either with the serial console up or just exiting. */ fprintf(stderr, "ERROR: Failed to start TELNET daemon: %d\n", ret); exitval = 1; &#125;#endif 如果一个本地控制台启用（可能在一个串行端口），然后nsh_consolemain()将被调用。nsh_consolemain()也位于NSH库。nsh_consolemain()不返回，完成整个NSH初始化序列。 123456789101112 /* If the serial console front end is selected, then run it on this thread */#ifdef CONFIG_NSH_CONSOLE ret = nsh_consolemain(0, NULL); /* nsh_consolemain() should not return. So if we get here, something - is wrong. */ fprintf(stderr, "ERROR: nsh_consolemain() returned: %d\n", ret); exitval = 1;#endif 3.1.2 nsh_initialize() NSH初始化函数，nsh_initialize()，在apps/nshlib/nsh_init.c发现。 1234567891011121314void nsh_initialize(void)&#123; /* Mount the /etc filesystem */ (void)nsh_romfsetc(); /* Perform architecture-specific initialization (if available) */ (void)nsh_archinitialize(); /* Bring up the network */ (void)nsh_netinit();&#125; 它也只有三件事： 1.nsh_romfsetc():如果是这样的配置，它执行一个NSH启动脚本，这个脚本可以在目标文件系统/etc/init.d/rcS中发现。nsh_romfsetc()函数可以在apps/nshlib/nsh_romfsetc.c中发现。这个函数将一个ROMFS文件系统登记注册，然后挂载这个只读的ROMFS文件系统到默认位置/etc。 12345678910111213141516171819202122/* Create a ROM disk for the /etc filesystem */ret = romdisk_register(CONFIG_NSH_ROMFSDEVNO, romfs_img, NSECTORS(romfs_img_len), CONFIG_NSH_ROMFSSECTSIZE);if (ret &lt; 0) &#123; dbg("nsh: romdisk_register failed: %d\n", -ret); return ERROR; &#125;/* Mount the file system */vdbg("Mounting ROMFS filesystem at target=%s with source=%s\n", CONFIG_NSH_ROMFSMOUNTPT, MOUNT_DEVNAME);ret = mount(MOUNT_DEVNAME, CONFIG_NSH_ROMFSMOUNTPT, "romfs", MS_RDONLY, NULL);if (ret &lt; 0) &#123; dbg("nsh: mount(%s,%s,romfs) failed: %d\n", MOUNT_DEVNAME, CONFIG_NSH_ROMFSMOUNTPT, errno); return ERROR; &#125; ROMFS镜像本身编译成固件。默认情况下，该rcS启动脚本中包含以下逻辑： # Create a RAMDISK and mount it at XXXRDMOUNTPOINTXXX mkrd -m XXXMKRDMINORXXX -s XXMKRDSECTORSIZEXXX XXMKRDBLOCKSXXX mkfatfs /dev/ramXXXMKRDMINORXXX mount -t vfat /dev/ramXXXMKRDMINORXXX XXXRDMOUNTPOINTXXX ROMFS镜像被创建时模板中的XXXX*XXXX字符得到替换： XXXMKRDMINORXXX 将成为RAM的次设备号。默认：0 XXMKRDSECTORSIZEXXX 将成为内存设备扇区大小 XXMKRDBLOCKSXXX 将成为该设备的扇区数 XXXRDMOUNTPOINTXXX 将成为配置的安装点。默认值：/etc 默认情况下，替换的值将产生一个rcS文件如： # Create a RAMDISK and mount it at /tmp mkrd -m 1 -s 512 1024 mkfatfs /dev/ram1 mount -t vfat /dev/ram1 /tmp 然后： 在/dev/ram1创建一个大小为512 * 1024字节的RAMDISK， 在磁盘/dev/ram1格式化FAT文件系统，然后 挂载FAT文件系统在配置挂载点，/tmp。 rcS模板文件能在apps/nshlib/rcS.template找到。由此产生的ROMFS文件系统可以在apps/nshlib/nsh_romfsimg.h发现。 2.nsh_archinitialize()：未来的任何特定于体系结构的NSH初始化将被执行（如果有）。如STM3240G-EVAL，这种特定结构的初始化可以在configs/stm3240g-eval/src/up_nsh.c配置。这也像：（1）初始化SPI设备，（2）初始化SDIO，和（3）安装，可以插入的任何SD卡。 3.nsh_netinit()：nsh_netinit()函数可以在apps/nshlib/nsh_netinit.c中发现。 3.2 NSH命令概要。NSH支持多种命令，是NSH程序的一部分。所有的NSH命令都列在上面的NSH文档里。然而，并不是所有这些命令都可以在任何时候使用。许多命令取决于某些NuttX配置选项。你可以输入命令help在NSH提示后看到实际可用的命令： nsh&gt; help 例如，如果网络不支持，那么所有的网络相关的命令将从’nsh&gt; help’展现的命令列表中消失。 3.2.1 添加新的NSH命令 新的命令可以非常容易地增加到NSH。你只需增加2件事： 实现您的命令，和 NSH命令表中一个新的条目 实现您的命令。例如，如果你想添加一个新的叫mycmd命令到NSH，你会先在函数原型实现mycmd代码： int cmd_mycmd(FAR struct nsh_vtbl_s *vtbl, int argc, char **argv); argc和argv是用来传递命令行参数到NSH命令。命令行参数是在一个非常标准的方式传递：argv [ 0 ]将该命令的名称，argv[1] 到 argv[argc-1]在NSH命令行提供额外的参数。 第一个参数，vtbl，是特殊的。这是一个指向特定会话状态信息的指针。你不需要知道状态信息的内容，但是当你与NSH的交互逻辑时你需要传递vtbl参数。你只需要利用vtbl参数来输出数据到控制台。你不用在NSH命令使用printf()，反而你会使用： void nsh_output(FAR struct nsh_vtbl_s *vtbl, const char *fmt, …); 所以，如果你只想在控制台上输出“Hello, World!”，然后你的整个命令的执行可能是： int cmd_mycmd(FAR struct nsh_vtbl_s *vtbl, int argc, char **argv) { nsh_output(vtbl, &quot;e;Hello, World!&quot;e;); return 0; } 对新命令的原型应该放在apps/examples/nshlib/nsh.h。 加入你命令到NSH命令表。所有出现在单个表中支持NSH的命令都调用： const struct cmdmap_s g_cmdmap[] 该表可以在文件apps/examples/nshlib/nsh_parse.c中找到，结构cmdmap_s也是定义在apps/nshlib/nsh_parse.c中： struct cmdmap_s { const char *cmd; /* Name of the command */ cmd_t handler; /* Function that handles the command */ uint8_t minargs; /* Minimum number of arguments (including command) */ uint8_t maxargs; /* Maximum number of arguments (including command) */ const char *usage; /* Usage instructions for &apos;help&apos; command */ }; 这个结构提供了你需要的一切来描述你的命令：它的名字（CMD），处理命令的函数（cmd_mycmd()），命令需要的最大最小参数个数，和一个描述命令行参数字符串，最后一个字符串是输入”nsh&gt; help”打印出来的东西。 所以，对于你commnd样本，你可以添加下面到g_cmdmap [ ]表： { &quot;mycmd&quot;, cmd_mycmd, 1, 1, NULL }, 这项特别简单，因为mycmd是如此简单。在g_cmdmap [ ]看看其他的命令更为复杂的例子。如： 12345678910# ifndef CONFIG_NSH_DISABLE_CD &#123; "cd", cmd_cd, 1, 2, "[&lt;dir-path&gt;|-|~|..]" &#125;,# endif#endif# ifndef CONFIG_NSH_DISABLE_CP &#123; "cp", cmd_cp, 3, 3, "&lt;source-path&gt; &lt;dest-path&gt;" &#125;,# endif# ifndef CONFIG_NSH_DISABLE_CMP &#123; "cmp", cmd_cmp, 3, 3, "&lt;path1&gt; &lt;path2&gt;" &#125;,# endif 3.3 NSH“内置”的应用概要。除了属于NSH一部分的命令之外，外部程序也可以作为NSH执行的命令。由于历史的原因这些外部程序被称之为“内置”应用。这个术语有点混乱，因为如上所述的实际的NSH命令是真正内置到NSH的，而这些应用是外接到NuttX的。 它们可以通过在NSH提示简单地键入应用程序的名称执行，在这个意义上这些应用可以内置到NSH。内置的应用程序支持是启用这些配置选项： CONFIG_BUILTIN：使能NuttX支持内置应用。 CONFIG_NSH_BUILTIN_APPS：使能NSH支持内置应用。 12#define CONFIG_BUILTIN #define CONFIG_NSH_BUILTIN_APPS 1 当设置完这些配置选项，输入”nsh&gt; help”可以看到这些内置应用。它们将出现在NSH命令列表的底部： Builtin Apps: 请注意：这些内置应用程序名字的外面没有提供详细的帮助信息。 3.3.1 内置应用 概要。基本逻辑就是支持NSH内置的应用程序称为“内置程序”。内置的应用程序方法可以在apps/builtin发现。这些方法简单实现如下： 它支持注册机制，内置的应用程序可以在构建的时候动态注册自己，和 查找，列表，并执行内置应用的实用函数。 内置应用实用函数。内置应用程序方法导出的实用函数原型在nuttx/include/nuttx/binfmt/builtin.h和apps/include/builtin.h。这些实用函数包括： int builtin_isavail(FAR const char *appname); 检查应用程序在构建时间注册为appname的可用性。 const char *builtin_getname(int index);通过索引返回一个指向内置应用程序名称的指针。这是NSH使用的实用函数，为了输入“nsh&gt; help”时列出可用的内置应用程序。 int exec_builtin(FAR const char *appname, FAR const char **argv); 在编译时间执行内置式应用程序注册。这是NSH使用于执行内置应用的实用函数。 自动生成的头文件。当NuttX第一次建立时带有需求的应用程序入口点都聚集在两个文件： apps/builtin/builtin_proto.h: 应用程序任务入口点的原型。 apps/builtin/builtin_list.h:应用程序特定信息和启动要求。 内置应用程序的注册。NuttX编译有几个不同的阶段，因为不同的编译目标被执行。（1）context目标，当配置建立时，（2）depend目标，当目标依赖性产生时，（3）default（all）目标，当正常编译链接操作完成时。内置应用程序信息是在make context目标阶段收集。 在apps/examples/hello目录是一个内置应用程序的例子。让我们一起通过这个具体的例子来说明内置的应用程序创建和如何他们自己注册的一般方式，最后它们可以在NSH使用。 apps/examples/hello.apps/examples/hello主程序可以在apps/examples/hello/main.c发现。主程序是： int hello_main(int argc, char *argv[]) { printf(&quot;Hello, World!!\n&quot;); return 0; } 这是一个内置的函数，它将在NuttX编译阶段注册。注册是由apps/examples/hello/Makefile方法实现。但是，编译系统通过一个相当曲折的路径到达这个方法： 顶层的make目标context在nuttx/Makefile。所有的编译目标依赖于context编译目标。对于apps/目录，这个编译目标将执行apps/Makefile里的context目标。注：context编译目标可以在makefile里面找到。 apps/Makefile将轮流执行所有配置的子目录context目标，在我们的情况下，将包括apps/examples里的Makefile。 最后，apps/examples/Makefile将执行所有配置了的example子文件夹的context目标，最后到apps/examples/Makefile，如下。 注意：由于此context，编译阶段只能执行一次，任何随后您将作出的配置更改，然后将不反映在编译序列。这是一个常见的混乱地区。在你可以实例化新的配置，你首先要摆脱旧的配置。最激烈的方式是： make distclean 但你将不得不从头开始重新配置NuttX。但是，如果你只想在apps/sub-directory重新编译配置，那么很少的工作量就可以实现。以下nuttx命令将只从apps/目录删除配置，将让你无需重新配置一切来继续： make apps_distclean 在apps/examples/hello/Makefile里的context目标方法来注册builtin’s builtin_proto.h 和 builtin_list.h文件里的hello_main()应用。这样的方法在apps/examples/hello/Makefile里，摘录如下： 1、首先，Makefile 包括apps/Make.defs: include $(APPDIR)/Make.defs 这定义一个称为REGISTER的宏，能添加数据到内置的头文件： define REGISTER @echo &quot;Register: $1&quot; @echo &quot;{ \&quot;$1\&quot;, $2, $3, $4 },&quot; &gt;&gt; &quot;$(APPDIR)/builtin/builtin_list.h&quot; @echo &quot;EXTERN int $4(int argc, char *argv[]);&quot; &gt;&gt; &quot;$(APPDIR)/builtin/builtin_proto.h&quot; endef 当这个宏运行时，你会看到”Register:hello“的输出，这现象代表注册成功。 2、make文件然后定义应用程序名字（hello），任务的优先级（default），和将被分配到的任务运行的栈的大小（2K）。 APPNAME = hello PRIORITY = SCHED_PRIORITY_DEFAULT STACKSIZE = 2048 3、最后，Makefile调用寄存器宏添加hello_main()内置应用。然后，当系统建立完成，hello命令可以从NSH命令行执行。当hello命令执行时，它将用默认的优先级和一个2K的堆栈大小启动任务的入口点hello_main()。 context: $(call REGISTER,$(APPNAME),$(PRIORITY),$(STACKSIZE),$(APPNAME)_main) 内置应用程序的其他用途。内置应用程序的主要目的是支持应用程序从NSH命令行执行。然而，有内置的应用程序应该提到的另一个用途。 binfs。binfs是一个位于apps/builtin/binfs.c的很小的文件系统。这提供一种替代可视化安装内置应用的方法。没有binfs，你能用NSH帮助命令看到已经安装的内置应用。binfs将创建一个小的伪文件系统安装在/bin。使用binfs，你可以通过列出/bin目录的内容来看到可用的内置应用程序。这肤浅兼容Unix，但是没有添加任何新的功能。 3.3.2 同步构建的应用程序 默认情况下，从NSH命令行开始启动的内置命令将与NSH异步运行。如果你想强迫NSH执行命令，然后等待命令执行，您可以通过添加下面到NuttX配置文件启用功能： CONFIG_SCHED_WAITPID=y 此配置选项可以为标准的waitpid() RTOS接口提供支持。当接口启用，NSH将用它来等待，睡眠到内置的应用程序执行完成。 当然，即使CONFIG_SCHED_WAITPID=y定义，具体的应用程序仍然可以在NSH命令后添加符号（&amp;）强制异步运行。 3.4 定制NSH初始化定制NSH初始化的方法。这里有三种方法来定制NSH启动行为。依照难易程度呈现如下： 你可以在configs/stm3240g-eval/src/up_nsh.c扩展初始化方法。这里的方法在每次NSH启动时调用，它特别适合任何设备相关初始化。 用任何你想启动的方法替换apps/examples/nsh/nsh_main.c里的示例代码。NSH是一个位于apps/nshlib的库，apps/example/nsh只是一个微小的启动示例函数（CONFIG_USER_ENTRYPOINT()），你能快速运行，并说明如果你想要别的东西立即运行该如何启动NSH，然后你可以写你自己的自定义CONFIG_USER_ENTRYPOINT()函数，从你的自定义CONFIG_USER_ENTRYPOINT()开始其他的任务。 NSH还支持NSH第一次运行时执行的启动脚本。这种机制的优点是启动脚本可以包含任何NSH命令，可以用很少的代码做很多工作。缺点是，创建启动脚本是相当复杂的。px4的定制采用的就是这种方法，这是足够复杂的，值得有自己的段落。 3.4.1 NuttShell 启动脚本 这一部分大部分的内容能在2.0部分找到，这里只是做适当的补充。 如上面提到的，在NuttX代码树中使用自定义/etc/init.d/rcS文件的唯一的例子是：configs/vsn/nsh。configs/vsn的自定义脚本是位于configs/vsn/include/rcS.template: 1234567891011121314echo "Versatile Sensor Node V1.2, www.netClamps.com"# Create a RAMDISK and mount it at XXXRDMOUNTPOUNTXXX#mkrd -m XXXMKRDMINORXXX -s XXMKRDSECTORSIZEXXX XXMKRDBLOCKSXXX#mkfatfs /dev/ramXXXMKRDMINORXXX#mount -t vfat /dev/ramXXXMKRDMINORXXX XXXRDMOUNTPOUNTXXXmount -t binfs /dev/ram0 /sbinramtron start 3mount -t vfat /dev/mtdblock0 /usrsdcard start 0mount -t vfat /dev/mmcsd0 /sdcard 所有的自定义行为都包含在rcS.template。mkromfsimg.sh脚本的作用是（1）将特定的配置设置rcS.template来创建最终的rcS，和（2）生成包含romfs文件系统映像的头文件nsh_romfsimg.h。要做到这一点，mkromfsimg.sh使用必须安装在您的系统的两个工具： genromfs工具，用来生成ROMFS文件系统映像。 xxd 用来创建C头文件。 你能在configs/vsn/include/rcS.template找到为configs/vsn生成的ROMFS文件系统。]]></content>
      <categories>
        <category>飞控</category>
      </categories>
      <tags>
        <tag>Nuttx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[疯狂后的冬天]]></title>
    <url>%2F2016%2F04%2F27%2F%E7%96%AF%E7%8B%82%E5%90%8E%E7%9A%84%E5%86%AC%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[开心的片段里，恨不得马上告诉全世界，看到的东西都是欢乐的色彩，烦闷的时候，有些事，宁愿烂在心里，也不愿意向别人透露半句，所以我更加喜欢上了这个平台，既满足了发泄，或许还会留下点点回忆。 2014年这一年，是我步入大三的第一年，也是我初步觉得紧张与彷徨不安的一年，在这一年里，发生了好多事情，但是也想说没发生什么大事情，总的看来，一切的一切，都最终归于平淡的流年。 愤慨加无聊之中突然想到了自己的梦想，一些有关很近的未来的打算，我的第一个五年计划是什么样子的，每一年我该实现些什么？按照表哥的话，人生其实就是那样，每个阶段干好每个阶段的事就行了，该干嘛干嘛去。如果不忘初心，我的梦想是很简单的，我期待有一个LOFT，周末的时间，兄弟们了好好聚聚，就当成自己的酒吧，续续旧也是好的，作为科技爱好者，我希望能有自己的一间工作室，里面各种开发板、元器件及相关设备齐全，安静祥和的日子了，做个真正的技术宅，我还会把它打扮的非常像个样子，比如这些样子的： 开始工作的时间，我渴望有那么一间租房，这里边种满了花花草草，贴上了各种萌画，都是我跟她精心设计的。我想象着有一个地方，在那里我们谁也不认识，只属于我们两个人的世界，拼命的吃喝游乐，我们互相深爱着对方。我热爱着我的事业，认真的对待着，或许会找个志同道合的人一起打拼，或许会有自己仔仔细细写的书籍，不求销量，只求更好的完善自己。平常周末的时间，我也想尽可能的去玩，带上自己喜欢的人一起远游，我们不愁吃不愁喝，只求更好更快乐的生活着。 可是梦想归梦想，现实还是现实，现阶段的我确莫名其妙的跟“躁动不安”拉上钩了，我确定好久没有这感觉了，至少有一年了，确不曾还是逃离不了，只能这样告诉自己，该来的还是勇敢的去面对吧，为了提醒自己，我的网名变成了勇敢的心。细数开来，还有好多事情等待着我去做，去完善，去结尾。最不能落下的是我的飞思卡尔，虽然感觉困难重重，但是还是要坚定信心，没有就会有希望。其次是我的求职之路，虽然飞思卡尔能给我些许的助攻，但我很清楚“功课”不能落下，首先是基本课程知识，其次是linux应用、驱动设计，因为这是自己的特长，已经没有了足够的时间，我必须立马出发，努力努力再努力！还有我的保险箱，原本答应别人的事情，却成了自己心头的一块疙瘩，得自己想办法把它抹去，别人自己都不能失望。其实有点让我不安的是20几岁的情感问题，有人付出，有人感动，有人徘徊，有人流泪，生活当中的点点滴滴，傻傻的几个人，我喜欢认认真真的喜欢一个人，没有太多原因，喜欢上了就从不吝啬自己的付出，也相信着付出就会有回报，虽然运气占了绝大部分因素。 如果有人说我是一个喜欢念旧的人，那我也不能说你是不正确的，的确有时候我会想你们想到流泪，还有不经意的笑，更愿意理解为一个疯子、呆子。2014年这一年马上接近尾声了，我又要一个人默默的叙旧了，一想到这一年，我第一件想到的事情是我爸突然眼睛出毛病了，清楚的记得当时听到这个消息的第一反应是心里面阵阵的痛，后来忍不住的哭，直到第二次手术成功后，感觉稍微欣慰了点，或许这个泪点就是，父母为自己为家庭付出了那么多，为什么老来还要遭受那样的痛苦，我现在能做的只有快乐的生活，努力的奋斗，能给他们带来点欣慰也是令人满足的。 第二件事是搞飞思卡尔那段时间，真是令人怀念，虽然结果是没能取得良好的成绩。在那些日子里，我们满地板的打地铺，吹着综实的热风扇，撩乱的跑道，晚上的西瓜，书包里的外卖，半夜老蒋的米粥，龙兄等学长学姐不经意间的来访，真是令人快乐和惊喜，还有学弟学妹们时常的看望，主动的打扫杂乱的卫生，为我们加油打气，老师的辛勤指导，不离不弃，这些综实调车的日子，深深的刻在了我的脑海里，有时让人快乐有时让人伤感。在武汉比赛那些时光，是我比较在意的，半夜三更还在为我的终身大事着想的你们让我真是记忆犹生，比赛成绩不够理想，大家相互包揽责任，当时的我没能控制住了哭了，所以你们都成了我的兄弟，忘了谁也不会忘记你们。比赛完后我们到处玩耍，只为让各自开心，现在回忆起来，有你们真好。 从现在开始，已经马上新年了，我的愿望已经全部写在上面了，我要让自己振作起来，有自己想做的事，有一帮好的朋友，有自己喜欢的人，有着执着的追求，不言弃，勇敢前行，不拖延，立马行动。世界上只有两种人，一种是好人，一种是坏人，我一直是个好人，盼望着一个好的结果。祝愿美好的2015～]]></content>
      <categories>
        <category>感悟</category>
      </categories>
      <tags>
        <tag>冬天</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[祭奠即将逝去的大一]]></title>
    <url>%2F2016%2F04%2F27%2F%E7%A5%AD%E5%A5%A0%E5%8D%B3%E5%B0%86%E9%80%9D%E5%8E%BB%E7%9A%84%E5%A4%A7%E4%B8%80%2F</url>
    <content type="text"><![CDATA[要想真正的有所成就，就必须学会付出，忍受失去，必须去投入大量的时间，有失必有得。 每一个成功的人或者团队在达到成功之前难得有一段辛酸的过去，慢慢的要学会去奉献，而不是不停的索取，让自己慢慢地去感受，体验这个过程，也许也是一个成长的过程。 大学我如果没进这基地，我也是想过去缀学的，确实在大学如果你不主动去学，就那点考试根本不能学到什么，何必浪费四年才去找工作，但进这基地总的来说，还是兴趣支撑了我，如果我没有兴趣，我就不会去发现这个基地，更不会进这个基地，的确这兴趣我也费了好大的劲，慢慢才发现的，进这基地后，我就一直的坚持，甚至哪天如果我失去了它我会感觉到空虚，人生失去了动力，不知道下一步要去干嘛，我觉得有句话总结的挺好的，梦想是你坚持了而感到幸福的事情，所以我现在我倍感幸福，我庆幸我在迷茫的大一找到了自己人生的方向。 听学长们说了基地的大小年，我这一届恰好逢大年，所以带点迷信的想法我们必须去努力，甚至超过学长他们，从另外一个角度讲，基地也要一年比一年强，慢慢的越不越强大，这一直都是我们最希望的。 这一天，你成功地感染到了我，不久以后我就要不断地去影响他人，改变他人，传播好情绪，好思想。 想想马上要大一完了，好多人都在谋划着如何去纪念我们即将逝去的大一，我觉得好好去总结一下大一是怎么过来的，在大一里自己觉得过得还行吗，经历的事情还多吗，哪些事情觉得过得还行，哪些事情自己印象最深刻真正的让你觉得学到了东西，至少我现在觉得能安安静静地去总结真好，我自己也平时想了想，别人问我时我也会这么说，我真正感到满意的不是我学到了多少知识，而是我学到了一种如何去获取知识的方法，我不管我这种方法还精不精，但我能明显的感觉到能够自我的去发现问题，解决问题真好。特别的，当我去自己看现在学的这些科目的时候，我觉得能够及格还是挺容易的，根本不要浪费那么多时间去学，况且也学不到什么东西，于是我也学会了放弃，去获取自己真正需要的东西。]]></content>
      <categories>
        <category>感悟</category>
      </categories>
      <tags>
        <tag>大一</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读哲学后感]]></title>
    <url>%2F2016%2F04%2F27%2F%E8%AF%BB%E5%93%B2%E5%AD%A6%E5%90%8E%E6%84%9F%2F</url>
    <content type="text"><![CDATA[这几天在看哲学，哲学真是一门使人聪明的学科，让人受益匪浅，慢慢地我也学会了从生活中去发现问题，总结经验，确实有好多值得去思考的地方，我有必要不断的去完善自己的思想，甚至给自己的各方面创造一套属于自己的规则，能够逐渐的在科技领域扎根，慢慢地形成自己的看法。 首先谈谈我对哲学的看法，古代先哲们在哲学领域已经创下了不朽的成绩，中国外国都是的，中国的孔夫子从古至今就享誉全世界，可见其思想是有多么的深刻，是的，哲学在各个领域都留下了它们的身影，可知其重要性，毛泽东就是一个活生生的例子。我对之前思想家们是有多么的敬佩，他们都是伟大的人物，为后人创下了不少的精神财富，同时我很看重这些思想精华的汲取，要做到批判的继承，学习其有用之处为我所用，深化自己的思想，形成自己的思想观价值观。 这里我又不得不说明我要干些什么，我也不得不和我的兴趣爱好联系在一起，这一段时间我也有仔细想过，我究竟默默地在喜欢一些什么，更高一层次来讲，我这辈子能干些什么，怎么做才能使我的人生过得更加充实，更加有意义，现在我也大概把它记一下，我想这也是一个反省的过程，不得不承认我平时喜欢想一些问题，为自己总结一些经验，记得有一个成语叫作前车之鉴，我才知道先人也给了我们留下了很多宝贵的东西，我们现在管它叫哲学或思想，所以哲学我肯定得攻，令一方面，我喜欢设计一些自己的小东西小产品，搞搞科技，创创新，但顾及我的有意义的人生，我又不能只是一名科技人员，我现在可以把它上升到一个民族的或者国家的角度来看待这个问题，大家都知道，我国的科技水平还真的不怎么样，教育水平也是一个样，要找到最为本质的原因就离不开对教育体制的改革，高等教育就要沿着内涵式方向发展，外沿式图的只是数量，而我们现在要的就是质量，其实这不是一个小问题，这关乎到一个国家的发展，而我要做的就是发展一套属于自己的理论，改造人们对教育学习的思想观念，作一个不一样的科技人员，作一个身先士卒的教育改革者，现在真正能做的就是多读书，多怀疑，多研究，多请教，多总结，等到哪天我出了名，等到哪一天我有了实力，有了成就，我一定要将自己的思想传播全世界，向世界证明中国人不旦能创新，还能用脑创新。 我暂时想将我的主张定为一个字”本”，正如笛卡尔一样，他用”理性”二字来描述自己对科学研究的看法，为后人所称赞，哲学这一个体系真的很庞大的，我们必须学会剪枝蔓，立主脑，从繁芜的事物中走出来，这样才能看清事情的本质，所以我现在用一个字来概括它，或许以后会有更好的词、新的思想，这也许和我的生活、学习经历有关。 我之所以用一个”本”字，我发现这个世界变得很是奇妙，我们甚至可以用一生的时间来满足我们的好奇心，但是有越来越多的人会被这表面繁华的世界所侵害，整天沉迷网络游戏，手机随手不离，读书只为图个文凭，殊不知，游戏只为益智，休闲，手机只为即时通讯，读书是为修身养性，充实自己，其实仔细想想，我们在不知不学中脱离了事物的本质，这一路上要走多少弯路。李小龙在创建属于自己的武术思想《截拳道》时就把简化的武术理论称为”攻”与”防”，这与《孙子兵法》里描述的战争的本质”攻击”与”防御”有异曲同工之妙。他们都看清了事物的本来面目，所以只会离自己的成功越来越近。同样的道理，我认为学习也一样，学习不能只是学到一些浮浅的东西，不能浅尝辄止，要学会在前人的基础上不断的深入，去挖掘其根基，这样你才能把自己所学到的东西应用的游刃有余，发挥它应有的作用，创造出属于你自己的成果。就比如说，笛卡尔是这样来看待科学认识的，我认识他说到了重点，我很赞成他的看法，他说：科学认识不止是感性材料的机械堆积，它必须有一个扎扎实实的核心作统帅，把形形色色的材料贯穿起来，统一形成一个整体。这核心非常重要，没有它就没有科学，材料再多也只是一盘散沙。但是它并不是天上掉下来的，只是由综合、提高一般认识发展出来的。逻辑、数学的范畴看起来虽然非常光鲜，却只是用平常材料加工制造的。人类通过反复实践获得一些基本资料之后，又在实践中精炼、打磨，制成高级观念，从个别提高到一般，再从比较狭窄的一般提高到更加广阔的一般，永无止境。]]></content>
      <categories>
        <category>感悟</category>
      </categories>
      <tags>
        <tag>哲学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[也谈大一]]></title>
    <url>%2F2016%2F04%2F27%2F%E4%B9%9F%E8%B0%88%E5%A4%A7%E4%B8%80%2F</url>
    <content type="text"><![CDATA[都回来这么多天时间了，也去做了一些事情，也有一些事情没去做。每次回来就是这样，在学校就想着在家要怎么的怎么的，在家里就时间一天一天过去了，结果没怎么着，我想这一方面的原因很多，最主要的是自制力的因素，这也是以后的生活要慢慢去做好的。其实这次写日记是预谋已久的，主要是想总结一下，大学一年以来的所得所想，确实在这一年中收获了许多，而且每次写日记我都会有新的体悟，我不想失去这次感悟的机会，我要从中厚积薄发，以后回头看来时的路也是一种美好，或许以后在迷茫中又找回了曾经的清醒。 首先说说写日记吧，还记得以前的我老是喜欢一有事没事就发说说表明一下自己目前的心情，我现在也不知道这种习惯好不好，但我能清醒的意识到，一个成就一番大事业并取得事业上的成功的人，是应该耐得住寂寞的，况且当你取得成功时，别人看到的是你最光鲜的一面，或者也是当你取得成功时，别人才会慢慢去发觉你一路走过来的艰辛。是的，可以说道理就是这样，我们目前要做的就是好好把握时间，而没必要去花费一些时间在抱怨上，应该为了取得成功努力去走好每一步路，为自己走向成功做好铺垫。所以换了一种方式，我把心里所想所感悟的都写在日记里，因为有时候能找到一个真正懂自己的人很难，别人也有自己的事情要去做，要去处理，唯有自己才是真正懂自己的人。 其实这一年以来确实懂了好多，但现在想想竟然有点想不起来的感觉了，我差点都不知道自己干过什么了，有点感觉自己这篇日记写得太及时了，必须好好反省一下了。 谈谈我大学一年以来对学习的感悟吧，记得之前我见到合适的人就跟他们讲讲自己的学习体验，仿佛自己就是一个老者，仿佛自己已经步入了中年，反正没了年青时的那种年少轻狂，感觉自己说的都是对的。的确自己确实有了不一样的对学习的认识，暂时来说是一个进步。我就从自己感觉最重要的来说起吧，我感觉最重要的是改变了对学习的看法，以前我会认为学习就是记忆一些东西，把书本上的，老师讲的都会了，学习基本上就差不多了，总的来说，以前是老师在强行向你灌输一些东西，从来都没有主动的去接受。我想中国的大部分学生都是这样，远远不止我一个，那是肯定的，因为这和中国目前的教育制度有关，什么制度呢，应试教育，在小学，中学，一些都是为了应付考试，考试行你就行，考试不行你这一段时间的学习就是失败的，甚至考试可以决定你的前途命运。我为什么要讲这个原因呢，那是和我的所得分不开的，我的所得恰恰相反，大学的考试只是一个考查你的途径，你考的厉害并不代表你真的就有很大的本事，只能说明你平时花了比别人平时更多的时间在学习功课上，你能拿到奖学金而别人不能，但并不代表着你毕业后的出路就一定比别人要好，这是不一定的，甚至比别人要差，在我看来。当然这只是讲了下下大学与中学的考试有何不同，这也只是我想的，但也确实有人去践行了，而且是一些原来是学霸的人，有拿过奖学金的，现在在安分守己的往自己感兴趣的一方面发展，也许他们的思维方式和我的是相同的，之前我也与一位好朋友达成了共识，我们认识，用长远的眼光来看，在学校老是拿最高的奖学金不会比刚毕业去拿最高的工资要强，所以我们都在为第一份工作拿到高薪而努力，奖学金什么都是次要的。 这一段我来重点谈谈在大学中我感悟到的学习吧，在上一段中是重点讲了在中学是个怎样的学习处境，以及这样做有什么坏处。一句话，学习要学会思考，也许有人会反驳我学习哪个人不会去思考问题？是的，是有人去思考过问题，但我所说的去思考问题是指要去主动的思考问题，这其中是有前因和后果的，比如说，我为了去思考问题，我必须去努力发现问题，你没有问题哪来的问题去思考，当然书上有问题，但书上的毕竟是书上的，在发现问题的过程中，我就能学到很多东西，甚至可以这么说，如果不是对你要学的内容非常的了解，你就根本发现不了问题，所以这样看来，自己发现问题和看书本上的问题根本不是一个层次上的。再者我们要去把发现的问题分析好它，并通过自己各方面的努力去亲自动手去解决好它，有一句话总结的好，叫做大胆假设，小心求证，其实这一过程你看似简单，但要是能自己亲自把它搞定就已经很不简单了，一旦你能证明你这个问题的想法或者证明的想法是多少的不合理，在这一过程中，你已经获利不少了，你懂得了怎么样通过多方面的途径主动的去获取知识，懂得了如何将一个大问题化小，一步一步的去调试好它，懂得了甚至解决好生活当中的一切难题。还记得有一次我总天全然没有心思去认真做一件事情，结果那一天我回寝室的心情很是糟糕，因为我觉着一天没学到我想要学到的东西，而是突然对其它事物发生了兴趣，一时兴起，对其它事物又忙活了一下，后来我总结了一下，一个人要真心想去做好一件自己想做的事情，就必须用心，专注，并发挥好您的热情去做一件事情，后面的几天果然如此，令自己收获不少。总的说来，这都是一种自学能力的培养，并且它是一种快速学习能力，这在今后无论是工作还是生活都有很大的好处。 第三件事情我要谈谈人际交往。我不管以前的人际交往还是目前的，也不管它是成功还是失败，我都觉得我学到了很多，我觉得很值，当然人际交往无所谓成功与失败，它只是与它在你心目中的那个自己定的标准相不相符合而已。我把我那段时间的一些体验写下来吧，自己好好的总结一下，一、我一真以来自己要求自己要做到的最重要的一点就是为人要真诚，因为在我看来假情假意暂时能取得一个人的欢心，但我认为它并不会长久。二、要学会去发现别人的优点，学会去赞美别人，因为一个人纵使有再多的缺点，他都能有自己的闪光点，而有时候他的那个闪光点有可能正是他成就一番事业的支点，或者说我们作为好朋友，而恰恰你发现的他的那个缺点正是他成功的致命点，那么你必须去提醒他，无论你采取何种方式，作为朋友我必须去提醒他，但我们要是能达到目的，能够以委婉的方式或者能以一个故事我方式去暗示别人会更好，或许我们能有其它更好的办法。三、要学会与人交流，还记得上一次学长说的话，他可能没放在心上，但却深深的印在了我的心里，他就说不要刻意去学好口才，平时多注重和别人交流。确实自己感觉最缺的就是这一方面，也自己默默的查过这一方面的资料，可是尽管这样，也没有多少的进步，所以我就感觉自己哪一方面出了问题，而师兄又恰好给了我一个方向。四、这是我之前就发现了的一个问题，所谓口才，虽在重于说，但其重心在于大脑的高速运转，所以要解决这一大问题就在于平时的大量阅读，以及生活当中的积极思考，这是我在多次的聚会中发现的，有一些学长虽看他在那一动一动，二话不说，但他一上台就有东西，可以说可以跟我们去分析，这就足以说明他在台下就想过了，这就养成了我生活当中爱积极思考的习惯。这里我在谈人际交往时说到了口才，确实口才影响交往，行动有时候是占第二的地位的。 最重要的一点我们来探讨一下远大的理想和目标吧。作为男生，我们往往喜欢从事业说起，因为毕竟我们有一点上进心的可能都幻想过自己今后的事业有多么的美满，衣食无忧，妻儿幸福。但作为年轻一代的我们，可能都有过这样的问题，究竟要怎么我们才能达到自己理想的目的地？我想如何明确自己的目标就是一个问题。还记得以前读过一本书叫做《气场》，里面有一个观点我觉得非常的对，我可以把它运用在我对目标的定位上，那就是你要做成一件事，心里面就要有强烈的意识，并且心里面能每天反复的想着它，直到实现它，这一点非常的重要。这几天我又看了《李小龙传奇》，我只能说我太崇拜BRUCE lee了，他真的太受人尊敬了，可以说，他指引了我的人生，又起了我对人生的又一次思考，我想过了些什么呢？①目标的是否明确，我不得不考虑我的目标了，我的目标是什么呢？首先我得说明一下影响目标的因素，以我自己的经历来看，兴趣是很重要的，它甚至能决定你能坚持多久，而在我看来，有了真正的兴趣也就可以轻而易举的将职业转变为自己的事业，不让自己的一生留下任何遗憾。但我现在选择了嵌入式，我能发现我对设计方向很是感兴趣，常常期待自己能做出一些小科技出来，甚至有过想在学校一展自己的科技成果的念想，可是我又不是非常的有把握，因为我没有整天下意识的去想着它，而且学起来感觉有点累，有时候我真应该认真想想我的短期目标和长期目标了，我想了想李小龙，他在20来岁就取得了不少的成绩，我也分析了一下他这个人的个性特点，他对未来充满了信心，有着强烈的意愿，做事只要自己认为有意义的就敢于下决心，从不优柔寡断，做人真诚，感动了不少人，为他以后在事业上结交了多少兄弟，敢于闯，敢于创新，总能给自己的妻子带来不少的惊喜，最最重要的一点，他有自己的功夫梦，从没被人击垮过。②其实我特别羡慕他的一点就是他不但在事业上获得大丰收，而且爱情也是那么的完美，他是真正的有实力，他在他爱人心中是一个多么了不起的英雄，甚至也岳母都说你是用什么方法骗走了我的女儿，后来也妻子也说自己是全美国最幸福的妻子。依我看，他的确在很多方面都打动了琳达，比如说，有幽默感，对生活充满信心，有思想，总能给妻子带来惊喜，做事情要做就做最好的等等，感动了生活，感动了世界。这里也引发了我的一系列问题，在我未来的妻子身上，究竟怎么选取，该和我的事业有关吗？但有一点我非常认同，能够和你共患难的一定是真正爱你的，无论如何也不能亏待了她。③我又想到了我们的人生价值的体现，到底人的一生是安安静静或四处奔波为了钱奋斗，还是为了自己的理想将金钱置于第二位呢？我为什么说到这个问题，那是因为我们有时候确定自己的目标的时候考虑到的一个重要的因素就是钱，以后能不能赚钱，不能赚钱就有可能自己目标会发生改变，这就是社会的现实。所以按照这个道理，我认为可以做到在赚钱的同时，为自己的家乡或自己的国家尽一点力，一个人有自己的尊严，一个乡有自己的尊严，一个国家更应该如此，我想我可以在这一方面尽到自己的一份力。说了这么多，我想我下一步就是要想清楚自己的长期目标和短期目标了，虽然自己觉得有一点目标了，但相对于来说还是比较迷茫的，毕竟都20来岁了，该有点自己的小成就了，只有有了自己清晰的目标，才有可能创造属于自己的奇迹，我们都可以成为创造奇迹的人，说起来还真有点愧疚，好好想想，为自己，为未来，加油！]]></content>
      <categories>
        <category>感悟</category>
      </categories>
      <tags>
        <tag>大一</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的大二上学期]]></title>
    <url>%2F2016%2F04%2F27%2F%E6%88%91%E7%9A%84%E5%A4%A7%E4%BA%8C%E4%B8%8A%E5%AD%A6%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[这个学期已经结束了，回过头来想好好理清一下思绪，也不枉我即将逝去的青春年华，不管它是平淡无奇还是充满激情，未来的日子还很长，我知道它总是充满希望的，也许生命的快乐源于创造，不断去反省总结自己的过去，美好的未来掌控在自己的手中。 总的看来，时间可过的真快，仿佛眨眼间一学期就过去了，可是回头看来我的感觉又是怎么样的呢，我又学了多少东西，有哪些收获，对下学期又有什么打算呢，面对这些问题，我能感觉到有些悲伤，因为我做的并不是很好，还有很多值得我改进的地方，我想好好总结一下自己觉得不好的地方。一、自我控制力不强，这是我这学期做得特别失败的一件事，来来回回多少次，必须得下苦功夫必才行。二、学习效率不高，这样的结果是，看起来是时间花了一大把，结果没能干成什么事。三、执行能力过低，直接导致信任度降低，这是我第一次干也是我做得还不到位的事情，必须想办法去改进它。四、情感遇到挫折，沟通做的不到位，以及涉及到各方各面的综合能力还亟待提高。五、发现问题解决问题能力不灵活，以前我过老是这们要求别人，现在才发现自己做的并不够，这里我是用了一个是否灵活，因为我发现有时候并不是你自己执行的力度不够，而是执行的方式根本不是最佳的，所以要试着去换个角度去想问题，不管黑猫还是白猫能抓到老鼠的都是好猫。六、做事想事没有一个良好的规划，直接导致有时候不该有的时间紧，后果更严重一点有可能会导致前功尽弃，做规划这是一个良好的习惯，必须好好培养它才行。七、团队协作能力不强，其它很多时候我都非常想要一个自己的团队，这个团队里人人各司其职，干自己想干也能够干好的事情，朝夕相处，其乐融融，这也是我目前所向往的，但目前我个人的能力还非常不够，一方面是领导能力，如何带领一个团队在艰难险阻中突破重围，找到自己的目标，这是团队里面亟需解决的问题，另一方面就是技术能力的提升，首先自我能力需要稳扎稳打，提升到一定的层次，还有要队员在团队中能找到自己的出发点，在团队中能发挥自己的角色作用，并且能学到自己想要学到的东西，这也是团队的一个出发点，我想能解决好这两点，团队就不会出现大的偏差，而这两点是我过去做的不到位的，也是我来年要想办法去做好的事情。 最后我想在反省一个过去的同时也展望一个未来，要相信，未来它终究是美好的一个代名词，开始我也讲到了，生命的快乐源于创造，这个快乐可以在创造的这一个过程中，也可以在有所创造之后去享受这一切，就像我们去创造的是一个美好的生活一样，我们可以为自己去创造一个美好的未来，更伟大点可以为人类社会去创建一个更加温馨和谐的家园。所以无聊时想着去做点新玩意吧，呵呵，这样的日子你会充满激情的！ 这里我也想去幻想一个，现在的我想去找一个充满阳光的海滩，在这个附近建一个不是很大的工作室，在这里有一个属于我们自己的团队，不限男女，我们拥有我们自己的奋斗目标，不受外界影响，研发一些对这个世界有用的东西，顺便做一些服务外包，过着自己喜欢的小日子，等到资金足了，召集几好兄弟，也找一个离市区不是太远的郊区，建一loft，业余时间大家欢聚一堂，桌游、K歌、聊天随你怎么玩，既放松了又增进了感情，不亦乐乎。 加油吧，少年，珍惜每一分每一秒！]]></content>
      <categories>
        <category>感悟</category>
      </categories>
      <tags>
        <tag>大二</tag>
      </tags>
  </entry>
</search>
