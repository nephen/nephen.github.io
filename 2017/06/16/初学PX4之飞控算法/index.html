<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="PX4,飞控算法,">










<meta name="description" content="注意：基于参考原因，本文参杂了APM的算法分析。  本篇文章首先简述了下px4和apm调用姿态相关应用程序出处，然后对APM的DCM姿态解算算法参考的英文文档进行了翻译与概括，并结合源代码予以分析，在此之前，分析了starlino的DCM，并进行了matlab的实现，因为它更加利于理解。后段时间会对px4的四元数姿态解算进行分析。姿态控制部分描述了串级PID在APM里的实现流程，同样后期会完善对">
<meta name="keywords" content="PX4,飞控算法">
<meta property="og:type" content="article">
<meta property="og:title" content="初学PX4之飞控算法">
<meta property="og:url" content="http://nephen.cn/2017/06/16/初学PX4之飞控算法/index.html">
<meta property="og:site_name" content="来风的官方网站">
<meta property="og:description" content="注意：基于参考原因，本文参杂了APM的算法分析。  本篇文章首先简述了下px4和apm调用姿态相关应用程序出处，然后对APM的DCM姿态解算算法参考的英文文档进行了翻译与概括，并结合源代码予以分析，在此之前，分析了starlino的DCM，并进行了matlab的实现，因为它更加利于理解。后段时间会对px4的四元数姿态解算进行分析。姿态控制部分描述了串级PID在APM里的实现流程，同样后期会完善对">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://www.starlino.com/wp-content/uploads/2011/11/clip_image0024.jpg">
<meta property="og:image" content="http://www.starlino.com/wp-content/uploads/2011/11/clip_image0044.gif">
<meta property="og:image" content="http://www.starlino.com/wp-content/uploads/2011/11/clip_image0064.gif">
<meta property="og:image" content="http://www.starlino.com/wp-content/uploads/2011/11/clip_image0084.gif">
<meta property="og:image" content="http://www.starlino.com/wp-content/uploads/2011/11/clip_image0104_thumb.gif">
<meta property="og:image" content="http://www.starlino.com/wp-content/uploads/2011/11/clip_image0124_thumb.gif">
<meta property="og:image" content="http://www.starlino.com/wp-content/uploads/2011/11/clip_image0144.jpg">
<meta property="og:image" content="http://www.starlino.com/wp-content/uploads/2011/11/clip_image0164.jpg">
<meta property="og:image" content="http://www.starlino.com/wp-content/uploads/2011/11/clip_image0204.gif">
<meta property="og:image" content="http://www.starlino.com/wp-content/uploads/2011/11/clip_image0224.jpg">
<meta property="og:image" content="http://nephen.cn/images/dcm.png">
<meta property="og:image" content="http://nephen.cn/images/R.png">
<meta property="og:image" content="http://nephen.cn/images/RR.png">
<meta property="og:image" content="http://nephen.cn/images/lean.png">
<meta property="og:image" content="http://nephen.cn/images/cons.png">
<meta property="og:image" content="http://nephen.cn/images/anti.png">
<meta property="og:image" content="http://nephen.cn/images/frame.png">
<meta property="og:image" content="http://nephen.cn/images/body.png">
<meta property="og:image" content="http://nephen.cn/images/rotate.png">
<meta property="og:image" content="http://nephen.cn/images/L1.png">
<meta property="og:image" content="http://nephen.cn/images/方向余弦矩阵R.png">
<meta property="og:image" content="http://nephen.cn/images/正交矩阵.png">
<meta property="og:image" content="http://nephen.cn/images/矩阵推理.png">
<meta property="og:image" content="http://nephen.cn/images/060231194231745.png">
<meta property="og:image" content="http://nephen.cn/images/061036414865256.png">
<meta property="og:image" content="http://nephen.cn/images/L2.png">
<meta property="og:image" content="http://nephen.cn/images/L3.png">
<meta property="og:image" content="http://nephen.cn/images/endl.png">
<meta property="og:image" content="http://nephen.cn/images/eqn1.png">
<meta property="og:image" content="http://nephen.cn/images/eqn2.png">
<meta property="og:image" content="http://nephen.cn/images/LLL.png">
<meta property="og:image" content="http://nephen.cn/images/3r.png">
<meta property="og:image" content="http://nephen.cn/images/eqn3.png">
<meta property="og:image" content="http://nephen.cn/images/eqn4.png">
<meta property="og:image" content="http://nephen.cn/images/eqn5.png">
<meta property="og:image" content="http://nephen.cn/images/eqn6.png">
<meta property="og:image" content="http://nephen.cn/images/eqn7.png">
<meta property="og:image" content="http://nephen.cn/images/eqn8.png">
<meta property="og:image" content="http://nephen.cn/images/eqn9.png">
<meta property="og:image" content="http://nephen.cn/images/eqn10.png">
<meta property="og:image" content="http://nephen.cn/images/eqn11.png">
<meta property="og:image" content="http://nephen.cn/images/eqn12.png">
<meta property="og:image" content="http://www.starlino.com/wp-content/uploads/2011/11/clip_image0144_thumb.jpg">
<meta property="og:image" content="http://nephen.cn/images/eqn13.png">
<meta property="og:image" content="http://nephen.cn/images/eqn14.png">
<meta property="og:image" content="http://nephen.cn/images/eqn15.png">
<meta property="og:image" content="http://nephen.cn/images/eqn16.png">
<meta property="og:image" content="http://nephen.cn/images/eqn17.png">
<meta property="og:image" content="http://nephen.cn/images/eqn18.png">
<meta property="og:image" content="http://nephen.cn/images/eqn19.png">
<meta property="og:image" content="http://nephen.cn/images/eqn20.png">
<meta property="og:image" content="http://nephen.cn/images/eqn21.png">
<meta property="og:image" content="http://nephen.cn/images/ahrs.png">
<meta property="og:image" content="http://nephen.cn/images/ek.png">
<meta property="og:image" content="http://nephen.cn/images/ekfenable.png">
<meta property="og:image" content="http://ardupilot.org/dev/_images/Pixhawk_FTDICable_NSH.jpg">
<meta property="og:image" content="http://nephen.cn/images/gcslog.png">
<meta property="og:updated_time" content="2018-11-23T01:38:49.387Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="初学PX4之飞控算法">
<meta name="twitter:description" content="注意：基于参考原因，本文参杂了APM的算法分析。  本篇文章首先简述了下px4和apm调用姿态相关应用程序出处，然后对APM的DCM姿态解算算法参考的英文文档进行了翻译与概括，并结合源代码予以分析，在此之前，分析了starlino的DCM，并进行了matlab的实现，因为它更加利于理解。后段时间会对px4的四元数姿态解算进行分析。姿态控制部分描述了串级PID在APM里的实现流程，同样后期会完善对">
<meta name="twitter:image" content="http://www.starlino.com/wp-content/uploads/2011/11/clip_image0024.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://nephen.cn/2017/06/16/初学PX4之飞控算法/">





  <title>初学PX4之飞控算法 | 来风的官方网站</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">来风的官方网站</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://nephen.cn/2017/06/16/初学PX4之飞控算法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="nephen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="来风的官方网站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">初学PX4之飞控算法</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-16T07:43:37+08:00">
                2017-06-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/飞控/" itemprop="url" rel="index">
                    <span itemprop="name">飞控</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/06/16/初学PX4之飞控算法/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2017/06/16/初学PX4之飞控算法/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o">本文总阅读量</i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>次
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p><code>注意</code>：基于参考原因，本文参杂了APM的算法分析。</p>
</blockquote>
<p>本篇文章首先简述了下px4和apm调用姿态相关应用程序出处，然后对APM的DCM姿态解算算法参考的英文文档进行了翻译与概括，并结合源代码予以分析，在此之前，分析了starlino的DCM，并进行了matlab的实现，因为它更加利于理解。后段时间会对px4的四元数姿态解算进行分析。姿态控制部分描述了串级PID在APM里的实现流程，同样后期会完善对px4的分析。最后针对自己平时使用的一些调试技巧进行了总结。    </p>
<p><br></p>
<h1 id="姿态出处分析"><a href="#姿态出处分析" class="headerlink" title="姿态出处分析"></a>姿态出处分析</h1><ol>
<li>下面看下重要的一个<a href="https://github.com/PX4/Firmware/blob/master/ROMFS/px4fmu_common/init.d/rc.mc_apps" target="_blank" rel="noopener">脚本</a><code>/etc/init.d/rc.mc_apps</code>，可以知道姿态估计用的是attitude_estimator_q和position_estimator_inav，用户也可以选择local_position_estimator、ekf2，而姿态控制应用为mc_att_control和mc_pos_control。</li>
</ol>
<pre><code><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!nsh</span></span><br><span class="line"><span class="keyword">if</span> param compare INAV_ENABLED 1</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">	attitude_estimator_q start</span><br><span class="line">	position_estimator_inav start</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="keyword">if</span> param compare LPE_ENABLED 1</span><br><span class="line">	<span class="keyword">then</span></span><br><span class="line">		attitude_estimator_q start</span><br><span class="line">		local_position_estimator start</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		ekf2 start</span><br><span class="line">	<span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> mc_att_control start</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="comment"># try the multiplatform version</span></span><br><span class="line">	mc_att_control_m start</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> mc_pos_control start</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="comment"># try the multiplatform version</span></span><br><span class="line">	mc_pos_control_m start</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</code></pre><ol start="2">
<li><p>而在ardupilot中，姿态解算与控制算法在ArduCopter.cpp的fast_loop任务中以400Hz的频率运行。</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Main loop - 400hz</span></span><br><span class="line"><span class="keyword">void</span> Copter::fast_loop()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IMU DCM Algorithm</span></span><br><span class="line">    <span class="comment">// --------------------</span></span><br><span class="line">    read_AHRS();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Copter::read_AHRS(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">    ahrs.update();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>了解了上面的源码出处后，下面将分具体应用进行分析。   </p>
<p><br></p>
<h1 id="姿态传感器数据采集"><a href="#姿态传感器数据采集" class="headerlink" title="姿态传感器数据采集"></a>姿态传感器数据采集</h1><p>首先进行传感器的初始化，主要步骤为：关闭软件低频滤波器、设置传感器量程、关闭硬件低频滤波器、设置采样频率、设置队列深度，具体实现如下：   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// software LPF off</span></span><br><span class="line">ioctl(fd, ACCELIOCSLOWPASS, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 16g range</span></span><br><span class="line">ioctl(fd, ACCELIOCSRANGE, <span class="number">16</span>);</span><br><span class="line"><span class="keyword">switch</span>(devid) &#123;</span><br><span class="line">    <span class="keyword">case</span> DRV_ACC_DEVTYPE_MPU6000:</span><br><span class="line">    <span class="keyword">case</span> DRV_ACC_DEVTYPE_MPU9250:</span><br><span class="line">        <span class="comment">// hardware LPF off</span></span><br><span class="line">        ioctl(fd, ACCELIOCSHWLOWPASS, <span class="number">256</span>);</span><br><span class="line">        <span class="comment">// khz sampling</span></span><br><span class="line">        ioctl(fd, ACCELIOCSSAMPLERATE, <span class="number">1000</span>);</span><br><span class="line">        <span class="comment">// 10ms queue depth</span></span><br><span class="line">        ioctl(fd, SENSORIOCSQUEUEDEPTH, _queue_depth(<span class="number">1000</span>));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DRV_ACC_DEVTYPE_LSM303D:</span><br><span class="line">        <span class="comment">// hardware LPF to ~1/10th sample rate for antialiasing</span></span><br><span class="line">        ioctl(fd, ACCELIOCSHWLOWPASS, <span class="number">194</span>);</span><br><span class="line">        <span class="comment">// ~khz sampling</span></span><br><span class="line">        ioctl(fd, ACCELIOCSSAMPLERATE, <span class="number">1600</span>);</span><br><span class="line">        ioctl(fd,SENSORIOCSPOLLRATE, <span class="number">1600</span>);</span><br><span class="line">        <span class="comment">// 10ms queue depth</span></span><br><span class="line">        ioctl(fd, SENSORIOCSQUEUEDEPTH, _queue_depth(<span class="number">1600</span>));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后以400HZ频率的循环任务通过SPI通信来采集传感器数据，并将采集到的数据进行纠错处理，如减去静态偏差量。此时，将采集到的这些数据同步写入SD卡，以便于飞行测试后期进行数据分析。这个过程的数据是以结构体的形式存放于全局变量imu中，后面进行姿态解算时直接读取该变量的值即可。同步写入SD卡实现如下：   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DataFlash_Class *dataflash = get_dataflash();</span><br><span class="line"><span class="keyword">if</span> (dataflash != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> now = AP_HAL::micros64();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">log_GYRO</span> <span class="title">pkt</span> = &#123;</span></span><br><span class="line">       LOG_PACKET_HEADER_INIT((<span class="keyword">uint8_t</span>)(LOG_GYR1_MSG+instance)),</span><br><span class="line">        time_us   : now,</span><br><span class="line">        sample_us : sample_us?sample_us:now,</span><br><span class="line">        GyrX      : gyro.x,</span><br><span class="line">        GyrY      : gyro.y,</span><br><span class="line">        GyrZ      : gyro.z</span><br><span class="line">    &#125;;</span><br><span class="line">    dataflash-&gt;WriteBlock(&amp;pkt, <span class="keyword">sizeof</span>(pkt));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h1 id="姿态估算"><a href="#姿态估算" class="headerlink" title="姿态估算"></a>姿态估算</h1><h2 id="DCM-tutorial"><a href="#DCM-tutorial" class="headerlink" title="DCM_tutorial"></a>DCM_tutorial</h2><blockquote>
<p><a href="http://www.starlino.com/imu_guide.html" target="_blank" rel="noopener">imu_guide</a>/<a href="http://www.itdadao.com/2016/03/19/629990/" target="_blank" rel="noopener">imu_guide中文翻译</a>/<a href="http://www.starlino.com/dcm_tutorial.html" target="_blank" rel="noopener">dcm_tutorial</a>/<a href="https://zh.wikipedia.org/wiki/Wikipedia:%E9%A6%96%E9%A1%B5" target="_blank" rel="noopener">wiki资料查询</a>/<a href="https://github.com/nephen/picquadcontroller/blob/master/imu.h" target="_blank" rel="noopener">该部分算法源码参考</a><br>将该算法转换为了matlab实现，想了解的可以查看我的github里的<a href="https://github.com/nephen/DCM" target="_blank" rel="noopener">DCM工程</a>，能够更好的理解算法，另外，该matlab实现还有一定的bug，希望各位大神的pull request~<br>这部分翻译自<a href="http://www.starlino.com/dcm_tutorial.html" target="_blank" rel="noopener">dcm_tutorial</a>，并结合源码进行分析，可作为下部分DCM理论介绍的基础哦，所以建议先将这部分看完再往下看～</p>
</blockquote>
<p><strong>DCM矩阵</strong>：</p>
<ul>
<li><p>设机体坐标系为Oxyz，与机体坐标系同x,y,z方向的单位向量为i, j, k。地理坐标系为OXYZ，同理地理坐标系的单位向量为 I, J, K。共同原点为O。如图</p>
<p>  <img src="http://www.starlino.com/wp-content/uploads/2011/11/clip_image0024.jpg"></p>
<p>  I\(^G\) = {1,0,0}\(^T\), J\(^G\)={0,1,0}\(^T\) , K\(^G\) = {0,0,1}\(^T\)<br>  i\(^B\) = {1,0,0}\(^T\), j\(^B\)={0,1,0}\(^T\) , k\(^B\) = {0,0,1}\(^T\)<br>  下面将i，j，k向量用地理坐标系表示，首先以i作为一个例子。<br>  i\(^G\) = {i\(_x\)\(^G\) , i\(_y\)\(^G\) , i\(_z\)\(^G\)}\(^T\)<br>  其中i\(_x\)\(^G\)表示的是i向量在地理坐标系X轴上的投影，即<br>  i\(_x\)\(^G\) = |i| cos(X,i) = cos(I,i)<br>  在这个式子中，|i|是i单位向量的范式（长度），cos(I,i)是向量I和向量i夹角的余弦，因此可以这样写：<br>  i\(_x\)\(^G\) = cos(I,i) = |I||i| cos(I,i) = I.i<br>  在这个式子中，I.i是向量I和向量i的点积，由于只是计算点积，我们并不关心向量是在哪个坐标系中测量的，只要都是以同一个坐标系表示即可。所以：<br>   I.i = I\(^B\).i\(^B\) = I\(^G\).i\(^G\) = cos(I\(^B\).i\(^B\)) = cos(I\(^G\).i\(^G\))<br>  同样的：<br>  i\(_y\)\(^G\) = J.i , i\(_z\)\(^G\)=K.i<br>  所以i向量可以用地理坐标系表示为：<br>  i\(^G\)= { I.i, J.i, K.i}\(^T\)<br>  同样的，j，k向量可以表示为：<br>  j\(^G\)= { I.j, J.j, K.j}\(^T\) , k\(^G\)= { I.k, J.k, K.k}\(^T\)<br>  将机体坐标i，j，k的地理坐标表示以矩阵的形式表示为：   </p>
<p>  <img src="http://www.starlino.com/wp-content/uploads/2011/11/clip_image0044.gif"></p>
<p>  这就是方向余弦矩阵，它是由机体坐标系和地理坐标系向量所有两两向量组合的夹角的余弦组成，可以算出共有9\(\times\)9种。<br>  下一节的<code>DCM理论里面有另外一种推理DCM的方法</code>，建议交互思考！</p>
</li>
<li><p>而将地理坐标系在机体坐标系中表示与将机体坐标系在地理坐标系中表示是对称的，所以只需简单交换I, J, K 和 i, j, k即可。<br>I\(^B\)= { I.i, I.j, I.k}\(^T\) , J\(^B\)= { J.i, J.j, J.k}\(^T\) , K\(^B\)= { K.i, K.j, K.k}\(^T\)<br>转化为矩阵形式为：   </p>
<p>  <img src="http://www.starlino.com/wp-content/uploads/2011/11/clip_image0064.gif"></p>
<p>  很容易可以发现：<br>  DCM\(^B\) = (DCM\(^G\))\(^T\) or DCM\(^G\) = (DCM\(^B\))\(^T\)，换句话说，这两个矩阵是可以相互转换的。<br>  也可以发现：<br>  DCM\(^B\). DCM\(^G\) = (DCM\(^G\))\(^T\) .DCM\(^G\) = DCM\(^B\). (DCM\(^B\))\(^T\) = I\(_3\)<br>  其中I\(_3\)为3\(\times\)3的单位矩阵，换句话说，DCM矩阵是正交矩阵。<br>  证明如下：<br>  <img src="http://www.starlino.com/wp-content/uploads/2011/11/clip_image0084.gif"></p>
<p>  证明这个我们需要知道这些特性：i\(^{GT}\). i\(^G\) = | i\(^G\)|| i\(^G\)|cos(0) = 1， i\(^{GT}\). j\(^G\) = 0，因为i和j是正交的。   </p>
</li>
<li><p>方向余弦矩阵也称为旋转矩阵，如果知道机体坐标，则可以算出任意向量的地理坐标（反之同理），下面以机体坐标系向量使用DCM算出地理坐标作为例子进行推理：<br>r\(^B\)= { r\(_x\)\(^B\), r\(_y\)\(^B\), r\(_z\)\(^B\)}\(^T\)<br>而r\(^G\) = { r\(_x\)\(^G\) , r\(_y\)\(^G\) , r\(_z\)\(^G\) }\(^T\)<br>现在让我们分析第一个坐标r\(_x\)\(^G\)：<br>r\(_x\)\(^G\) = | r\(^G\)| cos(I\(^G\),r\(^G\))，由于坐标系旋转，向量的大小，夹角都不会变，故有：<br>| r\(^G\)| = | r\(^B\)| , | I\(^G\)| = | I\(^B\)| = 1 ， cos(I\(^G\),r\(^G\)) = cos(I\(^B\),r\(^B\))，所以：<br>r\(_x\)\(^G\) = | r\(^G\)| cos(I\(^G\),r\(^G\)) = | I\(^B\) || r\(^B\)| cos(I\(^B\),r\(^B\)) = I\(^B\). r\(^B\) = I\(^B\). { r\(_x\)\(^B\), r\(_y\)\(^B\), r\(_z\)\(^B\)}\(^T\)<br>由上可知，r\(^B\)= { r\(_x\)\(^B\), r\(_y\)\(^B\), r\(_z\)\(^B\)}\(^T\)，替换得：<br>r\(_x\)\(^G\) = I\(^B\). r\(^B\) = { I.i, I.j, I.k}\(^T\) . { r\(_x\)\(^B\), r\(_y\)\(^B\), r\(_z\)\(^B\)}\(^T\) = r\(_x\)\(^B\) I.i + r\(_y\)\(^B\) I.j + r\(_z\)\(^B\) I.k<br>同样的思路：<br>r\(_y\)\(^G\) = rx\(^B\) J.i + ry\(^B\) J.j + rz\(^B\) J.k<br>rz\(^G\) = rx\(^B\) K.i + ry\(^B\) K.j + rz\(^B\) K.k<br>转化为矩阵形式为：   </p>
<p>  <img src="http://www.starlino.com/wp-content/uploads/2011/11/clip_image0104_thumb.gif"></p>
<p>  得证。<br>  同样的思路可以证明：   </p>
<p>  <img src="http://www.starlino.com/wp-content/uploads/2011/11/clip_image0124_thumb.gif"></p>
<p>  也可以这样证明：<br>  DCM\(^B\) r\(^G\) = DCM\(^B\) DCM\(^G\) r\(^B\) = DCM\(^{GT}\) DCM\(^G\) r\(^B\) = I\(_3\) r\(^B\) = r\(^B\)</p>
</li>
</ul>
<p><strong>角速度</strong>：</p>
<ul>
<li><p>如下图所示，r为任意的旋转向量，t时刻的坐标为r(t)。时间间隔dt后：r = r (t) , r’= r (t+dt) and dr = r’ – r。   </p>
<p>  <img src="http://www.starlino.com/wp-content/uploads/2011/11/clip_image0144.jpg"></p>
<p>  dt时间后向量r绕着与单位向量u同向的轴旋转了d\(\theta\)，停到了向量r’的位置。其中u垂直与旋转的机身，因此u正交于r与r’，图中显示了u与u’，它们与r和r‘的叉乘结果方向相同。故有<br>  u = (r x r’) / |r x r’| = (r x r’) / (|r|| r’|sin(dθ)) = (r x r’) / (|r|\(^2\) sin(dθ))<br>  由于旋转并不改变向量的长度，因此有| r’| = |r|。<br>  向量r的线速度可以表示如下：<br>  v = dr / dt = ( r’ – r) / dt<br>  当dθ → 0时，向量r和dr的夹角\(\alpha\)可通过r，r’和dr组成的等腰三角形计算：<br>  α = (π – dθ) / 2 当dθ→ 0时，α → π/2。<br>  这告诉我们，当dt → 0时，r垂直于dr，因此r ⊥ v （v和dr的方向是一致的）。<br>  现在定义角速度向量，其中反应了角度的变化率和旋转轴方向。<br>  w = (dθ/dt ) u   </p>
</li>
<li>下面分析w和v之间的关系：<br>w = (dθ/dt ) u = (dθ/dt ) (r x r’) / (|r|\(^2\) sin(dθ))<br>当dt → 0时，dθ → 0，因此sin(dθ) ≈ dθ。化简得：<br>w = (r x r’) / (|r|\(^2\) dt)<br>现在由于 r’ = r + dr , dr/dt = v , r x r = 0，利用叉乘的加法分配率可得：<br>w = (r x (r + dr)) / (|r|\(^2\) dt) = (r x r + r x dr)) / (|r|\(^2\) dt) = r x (dr/dt) / |r|\(^2\)<br>最后得出：<br>w = r x v / |r|\(^2\)<br>下面反向推理证明v = w x r<br>利用向量的<a href="https://zh.wikipedia.org/wiki/%E4%B8%89%E9%87%8D%E7%A7%AF" target="_blank" rel="noopener">三重积</a>公式：(a x b) x c = (a.c)b – (b.c)a，以及v和r是垂直的，所以v.r = 0<br>w x r = (r x v / |r|\(^2\)­) x r = (r x v) x r / |r|\(^2\)­ = ((r.r) v + (v.r)r) / |r|\(^2\)­ = ( |r|\(^2\)­ v + 0) |r|\(^2\) = v<br>得证。</li>
</ul>
<p><strong>陀螺仪及角速度向量</strong></p>
<ul>
<li>如果我们定期获取陀螺仪的值，时间间隔为dt，那么陀螺仪将会告诉我们在这段时间，地球绕陀螺仪各轴旋转的度数。<br>dθ\(_x\) = w\(_x\)dt，dθ\(_y\) = w\(_y\)dt，dθ\(_z\) = w\(_z\)dt<br>其中w\(_x\) = w\(_x\) i = {w\(_x\) , 0 , 0 }\(^T\) , w\(_y\) = w\(_y\) j = { 0 , w\(_y\) , 0 }\(^T\) , w\(_z\) = w\(_z\) k = { 0 , 0, w\(_z\) }\(^T\)<br>每次旋转都会产生线性的位移<br>dr\(_1\) = dt v\(_1\) = dt (w\(_x\) x r) ; dr\(_2\) = dt v\(_2\) = dt (w\(_y\) x r) ; dr\(_3\) = dt v\(_3\) = dt (w\(_z\) x r) .<br>矢量相加：<br>dr = dr\(_1\) + dr\(_2\) + dr\(_3\) = dt (w\(_x\) x r + w\(_y\) x r + w\(_z\) x r) = dt (w\(_x\) + w\(_y\) + w\(_z\)) x r<br>因此线速度可以表示为：<br>v = dr/dt = (w\(_x\) + w\(_y\) + w\(_z\)) x r = w x r<br>这里的条件是dt很小才能这么推理，也就是说，dt越大误差也就越大。</li>
</ul>
<p><strong>基于6DOF或者9DOF的IMU传感器DCM互补滤波算法</strong></p>
<ul>
<li><p>科普：6DOF由三轴陀螺仪和三轴加速度计组成，9DOF由三轴磁力计、三轴陀螺仪和三轴加速度计组成。<br>定义右手地理坐标系：I指向北方，K指向顶部，J指向西方。   </p>
<p>  <img src="http://www.starlino.com/wp-content/uploads/2011/11/clip_image0164.jpg"></p>
<p>  IMU组成机体坐标系，IMU包括陀螺仪、加速度计等。<br>  加速度计能感应重力，重力向量指向地心，与顶部向量K\(^B\)方向相反，假如加速度计输出为A = {A\(_x\) , A\(_y\) , A\(_z\) }，则K\(^B\) = –A。<br>  磁力计与加速度计相似，除了磁力计可以感应地理的北方以外，假设正确的磁力计输出为M = {M\(_x\) , M\(_y\) , M\(_z\) }，由于I\(^B\)是指向北方，因此I\(^B\) = M.<br>  现在可以计算出J\(^B\) = K\(^B\) x I\(^B\)。<br>  所以加速度计和磁力计就能单独的给出DCM矩阵：<br>  DCM\(^G\) = DCM\(^{BT}\) = [I\(^B\), J\(^B\), K\(^B\)]\(^T\)<br>  DCM矩阵能转换机体坐标系中的任意向量到地理坐标系中：<br>  r\(^G\) = DCM\(^G\) r\(^B\)   </p>
</li>
<li><p>加速度计和磁力计都需要初始化校正和纠错。<br>陀螺仪没有绝对的方向感，比如它不知道北方和顶部在哪里，但加速度计和磁力计知道，因此当我们知道t时刻的方向，矩阵形式表示为DCM(t)，那么我们可以用陀螺仪算出更精确的方向DCM(t+1)，所以这就是从带有噪音的加速度计或者有磁场干扰的磁力计估算出来的姿态。<br>事实是我们可以利用陀螺仪、加速度计和磁力计融合来估算姿态。下面将介绍这种算法：<br>地理坐标系表示的DCM矩阵如下：   </p>
<p>  <img src="http://www.starlino.com/wp-content/uploads/2011/11/clip_image0204.gif"></p>
<p>  该DCM矩阵的各行为I\(^B\), J\(^B\), K\(^B\)向量。我们会将重心放在K\(^B\)（由加速度计测定），I\(^B\)（由磁力计测定）上。 J\(^B\)可以由J\(^B\) = K\(^B\) x I\(^B\)计算出来。<br>  假设机体坐标的顶部向量在t\(_0\)时刻表示为K\(^B\)\(_0\)，陀螺仪的输出为 w = {w\(_x\) , w\(_y\) , w\(_z\) }，一段时间后，该顶部向量表示为K\(^B\)\(_1G\)<br>  K\(^B\)\(_1G\) ≈ K\(^B\)\(_0\) + dt v = K\(^B\)\(_0\) + dt (w\(_g\) x K\(^B\)\(_0\)) = K\(^B\)\(_0\) + ( dθ\(_g\) x K\(^B\)\(_0\))<br>  其中dθ\(_g\) = w\(_g\)dt为三个轴角度的变化<code>向量</code>，这意味这在dt时间内K\(^B\)向量在3个轴改变的角度。w\(_g\)为陀螺仪测得的角速度。<br>  程序如下：   </p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//---------------</span></span><br><span class="line"><span class="comment">//dcmEst</span></span><br><span class="line"><span class="comment">//---------------</span></span><br><span class="line"><span class="comment">//gyro rate direction is usually specified (in datasheets) as the device's(body's) rotation </span></span><br><span class="line"><span class="comment">//about a fixed earth's (global) frame, if we look from the perspective of device then</span></span><br><span class="line"><span class="comment">//the global vectors (I,K,J) rotation direction will be the inverse</span></span><br><span class="line"><span class="keyword">float</span> w[<span class="number">3</span>];					<span class="comment">//gyro rates (angular velocity of a global vector in local coordinates)</span></span><br><span class="line">w[<span class="number">0</span>] = -getGyroOutput(<span class="number">1</span>);	<span class="comment">//rotation rate about accelerometer's X axis (GY output) in rad/ms</span></span><br><span class="line">w[<span class="number">1</span>] = -getGyroOutput(<span class="number">0</span>);	<span class="comment">//rotation rate about accelerometer's Y axis (GX output) in rad/ms</span></span><br><span class="line">w[<span class="number">2</span>] = -getGyroOutput(<span class="number">2</span>);	<span class="comment">//rotation rate about accelerometer's Z axis (GZ output) in rad/ms</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">	w[i] *= imu_interval_ms;	<span class="comment">//scale by elapsed time to get angle in radians</span></span><br><span class="line">	<span class="comment">//compute weighted average with the accelerometer correction vector</span></span><br><span class="line">	w[i] = (w[i] + ACC_WEIGHT*wA[i] + MAG_WEIGHT*wM[i])/(<span class="number">1.0</span>+ACC_WEIGHT+MAG_WEIGHT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  很显然，还可以通过另外的方式估算K\(^B\)。如加速度估算值K\(^B\)\(_{1A}\)，如下推理：<br>  w­\(_a\) = K\(^B\)\(_0\) x v\(_a\) / | K\(^B\)\(_0\)|2­   这个在上面的角速度部分得到了证实。<br>  其中 v\(_a\) = (K\(^B\)\(_{1A}\)­ – K\(^B\)\(_0\)) / dt，v\(_a\)为K\(^B\)\(_0\)的线速度，且| K\(^B\)\(_0\)|\(^2\)­­ = 1 ，故可以这么计算：<br>  dθ\(_a\) ­= dt w\(_a\) = K\(^B\)\(_0\) x (K\(^B\)\(_{1A}­\) – K\(^B\)\(_0\)) = K\(^B\)\(_0\) x K\(^B\)\(_{1A}­\) – K\(^B\)\(_0\) x K\(^B\)\(_0\) = K\(^B\)\(_0\) x K\(^B\)\(_{1A}­\) - 0 = K\(^B\)\(_0\) x K\(^B\)\(_{1A}­\)<br>  程序如下：   </p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//---------------</span></span><br><span class="line"><span class="comment">//Acelerometer</span></span><br><span class="line"><span class="comment">//---------------</span></span><br><span class="line"><span class="comment">//Accelerometer measures gravity vector G in body coordinate system</span></span><br><span class="line"><span class="comment">//Gravity vector is the reverse of K unity vector of global system expressed in local coordinates</span></span><br><span class="line"><span class="comment">//K vector coincides with the z coordinate of body's i,j,k vectors expressed in global coordinates (K.i , K.j, K.k)</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">//Acc can estimate global K vector(zenith) measured in body's coordinate systems (the reverse of gravitation vector)</span></span><br><span class="line">Kacc[<span class="number">0</span>] = -getAcclOutput(<span class="number">0</span>);	</span><br><span class="line">Kacc[<span class="number">1</span>] = -getAcclOutput(<span class="number">1</span>);</span><br><span class="line">Kacc[<span class="number">2</span>] = -getAcclOutput(<span class="number">2</span>);</span><br><span class="line">vector3d_normalize(Kacc);</span><br><span class="line"><span class="comment">//calculate correction vector to bring dcmEst's K vector closer to Acc vector (K vector according to accelerometer)</span></span><br><span class="line"><span class="keyword">float</span> wA[<span class="number">3</span>]; </span><br><span class="line">vector3d_cross(dcmEst[<span class="number">2</span>],Kacc,wA);	<span class="comment">// wA = Kgyro x	 Kacc , rotation needed to bring Kacc to Kgyro</span></span><br></pre></td></tr></table></figure>
<p>  可以通过融合K\(^B\)\(_{1A}\) 和K\(^B\)\(_{1G}\) 计算新的估算值K\(^B\)1 ，首先通过求dθa和dθg的加权平均来求dθ：<br>  dθ = (s\(_a\) dθ\(_a\) + s\(_g\) dθ\(_g\)) / (s\(_a\) + s\(_g\)­)<br>  为什么要求dθ，因为可以同时求得：<br>  K\(^B\)\(_1\) ≈ K\(^B\)\(_0\) + ( dθ x K\(^B\)\(_0\))<br>  I\(^B\)\(_1\) ≈ I\(^B\)\(_0\) + ( dθ x I\(^B\)\(_0\))<br>  J\(^B\)\(_1\) ≈ J\(^B\)\(_0\) + ( dθ x J\(^B\)\(_0\))<br>  由于I\(^B\), J\(^B\), K\(^B\)是相互联系的，所以跟踪相同的dθ。<br>  到目前为止，我们都没有提及磁力计，一个原因是6DOF的IMU是没有磁力计的，这样也可以使用，只是航向会产生飘移，因此我们可以使用一个虚拟的磁力计，代码中会有体现的。磁力计与加速度计相似：<br>  dθ\(_m\) ­= dt w\(_m\) = I\(^B\)\(_0\) x (I\(^B\)\(_{1M}­\) – I\(^B\)\(_0\))<br>  算入加权平均为：<br>  dθ = (s\(_a\) dθ\(_a\) + s\(_g\) dθ\(_g\) + s\(_m\) dθ\(_m\)) / (s\(_a\) + s\(_g\) +­ s\(_m\))<br>  更新DCM矩阵：<br>  I\(^B\)\(_1\) ≈ I\(^B\)\(_0\) + ( dθ x I\(^B\)\(_0\)) , K\(^B\)\(_1\) ≈ K\(^B\)\(_0\) + ( dθ x K\(^B\)\(_0\)) 和 J\(^B\)\(_1\) ≈ J\(^B\)\(_0\) + ( dθ x J\(^B\)\(_0\))<br>  下面通过计算J\(^B\)\(_1\) = K\(^B\)\(_1\) x I\(^B\)\(_1\)，判断估算后的值K\(^B\)\(_1\)是否垂直I\(^B\)\(_1\)。</p>
</li>
<li><p>了确保估算后的值是否还是正交的，如下图，假设向量a，b是几乎垂直的，但不是90°，我们可以找到一个向量b’ 与a垂直，这个b’向量可以通过求 c = a x b，再求 b’ = c x a 得到，可以看出b’是正交于a和c的，因此b’是校正后的向量。</p>
<p>  <img src="http://www.starlino.com/wp-content/uploads/2011/11/clip_image0224.jpg"></p>
<p>  利用向量的三重积公式展开，且a.a = |a| = 1：<br>  b’ = c x a = (a x b) x a = –a (a.b) + b(a.a) = b – a (a.b) = b + d，其中d = – a (a.b)是校正量，平行于a，方向取决于a和b的夹角。<br>  上面的情况是a向量固定，b向量得到校正，下面分析对称的情况，a得到校正，b固定：<br>  a’ = a – b (b.a) = a – b (a.b) = a + e，其中e = – b (a.b)<br>  再下面考虑这两个向量都有误差，都得到一半的校正得：<br>  a’ = a – b (a.b) / 2<br>  b’ = b – a (a.b) / 2<br>  所以得到一个相对简单的公式：<br>  Err = (a.b)/2<br>  a’ = a – Err <em> b<br>  b’ = b – Err </em> a<br>  现在我们可以更新DCM矩阵的 IB1, JB1向量。<br>  Err = ( I\(^B\)\(_1\) . J\(^B\)\(_1\) ) / 2<br>  I\(^B\)\(_1\)’ = I\(^B\)\(_1\) – Err <em> J\(^B\)\(_1\)<br>  J\(^B\)\(_1\)’ = J\(^B\)\(_1\) – Err </em> I\(^B\)\(_1\)<br>  I\(^B\)\(_1\)’’ = Normalize[I\(^B\)\(_1\)’]<br>  J\(^B\)\(_1\)’’ = Normalize[J\(^B\)\(_1\)’]<br>  K\(^B\)\(_1\)’’ = I\(^B\)\(_1\)’’ x J\(^B\)\(_1\)’’<br>  其中Normalize[a] = a / |a|，单位化。   </p>
<p>  代码如下：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bring dcm matrix in order - adjust values to make orthonormal (or at least closer to orthonormal)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dcm_orthonormalize</span><span class="params">(<span class="keyword">float</span> dcm[<span class="number">3</span>][<span class="number">3</span>])</span></span>&#123;</span><br><span class="line">	<span class="comment">//err = X . Y ,  X = X - err/2 * Y , Y = Y - err/2 * X  (DCMDraft2 Eqn.19)</span></span><br><span class="line">	<span class="keyword">float</span> err = vector3d_dot((<span class="keyword">float</span>*)(dcm[<span class="number">0</span>]),(<span class="keyword">float</span>*)(dcm[<span class="number">1</span>]));</span><br><span class="line">	<span class="keyword">float</span> delta[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">	vector3d_scale(-err/<span class="number">2</span>,(<span class="keyword">float</span>*)(dcm[<span class="number">1</span>]),(<span class="keyword">float</span>*)(delta[<span class="number">0</span>]));</span><br><span class="line">	vector3d_scale(-err/<span class="number">2</span>,(<span class="keyword">float</span>*)(dcm[<span class="number">0</span>]),(<span class="keyword">float</span>*)(delta[<span class="number">1</span>]));</span><br><span class="line">	vector3d_add((<span class="keyword">float</span>*)(dcm[<span class="number">0</span>]),(<span class="keyword">float</span>*)(delta[<span class="number">0</span>]),(<span class="keyword">float</span>*)(dcm[<span class="number">0</span>]));</span><br><span class="line">	vector3d_add((<span class="keyword">float</span>*)(dcm[<span class="number">1</span>]),(<span class="keyword">float</span>*)(delta[<span class="number">1</span>]),(<span class="keyword">float</span>*)(dcm[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Z = X x Y  (DCMDraft2 Eqn. 20) , </span></span><br><span class="line">	vector3d_cross((<span class="keyword">float</span>*)(dcm[<span class="number">0</span>]),(<span class="keyword">float</span>*)(dcm[<span class="number">1</span>]),(<span class="keyword">float</span>*)(dcm[<span class="number">2</span>]));</span><br><span class="line">	<span class="comment">//re-nomralization</span></span><br><span class="line">	vector3d_normalize((<span class="keyword">float</span>*)(dcm[<span class="number">0</span>]));</span><br><span class="line">	vector3d_normalize((<span class="keyword">float</span>*)(dcm[<span class="number">1</span>]));</span><br><span class="line">	vector3d_normalize((<span class="keyword">float</span>*)(dcm[<span class="number">2</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="DCM理论"><a href="#DCM理论" class="headerlink" title="DCM理论"></a>DCM理论</h2><blockquote>
<p><code>注意</code>：这部分属于APM源码里px4姿态解算部分。<br>资料翻译解读自<a href="http://api.ning.com/files/BhCgAMpEVgsY6Ag26S3qH9M-vAfI5HDYJWywCrNw5DC5iVUJ8EZMlcymLZ-6A6EaRCl82BVEl-7lwLa8E-z8QedqzNfL-ji1/DCMDraft2.pdf" target="_blank" rel="noopener">DMCDraft2.pdf</a>（翻译不妥请谅解，欢迎提意见，另外该理论文档已启动翻译，如果你想参与请点击<a href="https://nephen.gitbooks.io/direction-cosine-matrix-imu-theory/content/index.html" target="_blank" rel="noopener">这里</a>），并结合文档分析了APM的姿态源码部分，目前还有<code>drift_correction</code>函数未进行整理！</p>
</blockquote>
<p><strong>前言</strong></p>
<ul>
<li>使用矩阵来控制和导航，元素包括陀螺仪，加速度计和gps信息。</li>
<li><p>总的来说，DCM工作如下：</p>
<ul>
<li>陀螺仪作为主要的方向信息来源，通过整合一个非线性微分运动方程，表明飞机方向的变化率与旋转速率及它当前的方向之间的关系。</li>
<li>意识到积分过程中的积分误差将渐渐的违反DCM必须满足的正交约束，我们对矩阵的元素进行规则的小调整满足约束。</li>
<li><p>由于数字误差，陀螺仪漂移，陀螺仪偏移量将逐渐积累在DCM中的元素的误差，我们使用参考向量来检测误差，以及在检测到的误差和和第一步的陀螺仪输入中加一个比例积分负反馈控制器来在建立之前消除误差。gps是用来检测偏航误差，加速度计被用来检测俯仰和滚动。<br><code>整个过程</code>如下：</p>
<p> <img src="/images/dcm.png"></p>
<p> 代码实现概览：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Integrate the DCM matrix using gyro inputs</span></span><br><span class="line">matrix_update(<span class="keyword">delta_t</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Normalize the DCM matrix</span></span><br><span class="line">normalize();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Perform drift correction</span></span><br><span class="line">drift_correction(<span class="keyword">delta_t</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p><strong>方向余弦矩阵介绍</strong></p>
<ul>
<li>所有这一切都与旋转有关。</li>
<li>有几种方法可以做到，比如旋转矩阵和四元数。这两种方法在实现上具有相似的地方，都是尽量准确的表示旋转。四元数只需要4个值，而旋转矩阵需要9个，在这方面四元数具有优势。而旋转矩阵很适合用来导航和控制。</li>
<li><p>旋转矩阵用来描述一个坐标系相对于另一个坐标系的方向。在一个系统中的向量可以通过乘以旋转矩阵转变到另一个系统中，如果是相反方向旋转则乘以旋转矩阵的逆矩阵，也是它的转置（交换行和列）。单位向量在控制和导航运算中将非常有用，因为它们的长度为1。因此他们能被用于交积和叉积中来获得各种正弦或余弦角。</p>
<p>  <img src="/images/R.png"><br>  <img src="/images/RR.png"></p>
</li>
<li>随着飞机的飞行，我们可以用位置（重心的移动）和朝向（绕着重心方向的变化）了描述它的运动，类似这种变换我们称为刚体变换。通过指定一个轴的旋转来描述其相对于地球的方向。例如将飞机开始放在一个标准方向，然后将其旋转，它将指向另外一个实际的方向，也就是说任何其他的方向都可以通过标准方向的旋转描述。<br>旋转组是所有可能的旋转的组。它被称为一组，因为在该组中的任何2个旋转可以组成一个组中的另一个旋转，每一个旋转有一个逆旋转。这里有一个单位旋转。<br>旋转组应该得到重视的原因是，你能通过最少的近似来在各个方向控制和导航飞机，包括各种特技。<br>基本的想法是，定义了你的飞机的方向的旋转矩阵，可以通过结合描述旋转运动学的非线性微分方程得到。这个结合可以通过一系列的旋转组合完成，也就是两矩阵相乘，这是两个矩阵依次执行的结果。<br>然而，数值积分引入的数值误差，并不会产生与符号积分相同的结果。精确的陀螺仪信号的符号积分将产生完全正确的旋转矩阵。数值积分，即使我们有精确的陀螺仪信号，也会引入2种数值误差：<ul>
<li>积分误差。数值积分采用有限时间步长和在有限采样速率下采样数据。因为是假定在时间步长内旋转速度是恒定的，这将引入了一个与旋转加速度成比例的误差。</li>
<li>量化误差。不管你用什么代表值，数字表示是有限的，所以有一个量化误差，从模数转换开始，以及所有计算没有保留结果所有位时。</li>
</ul>
</li>
<li><p><a href="http://blog.csdn.net/zhang11wu4/article/details/49761121" target="_blank" rel="noopener">旋转矩阵</a>的一个关键特性是它的正交性，这意味着如果2个向量在一个参照系中是垂直的，它们在每一个参照系中都是垂直的。另外，在每一个参照系中向量的长度是一样的。数值误差可能违反此特性。在许多空间系统中,利用方向余弦矩阵把矢量从一个笛卡尔坐标系变换到另一个笛卡尔坐标系。理想的方向余弦矩阵应当是正交的,而实际上,通过计算得到的矩阵由于种种误差(如计算方法误差、舍入误差等)而失去了正交性,造成变换误差,影响系统精度。于是有必要按某种最优方式,恢复其正交性。矩阵正交化的迭代法有多种,但都计算较繁、运算量大。对于需要把计算得到的方向余弦矩阵周期性地正交化的场合(如捷联式惯导系统),大的运算量将给计算机实时计算带来困难。例如，即使行和列都应该代表单位向量，它们的大小应该等于1，但数值误差可能导致它们变得更小或更大。最终他们可以缩小到零，或去无限。行和列应该是垂直于彼此，数值误差可能导致他们“倾斜”到对方，如下图所示：</p>
<p>  <img src="/images/lean.png"></p>
</li>
<li><p>旋转矩阵有9个元素。实际上，只有3个是独立的。旋转矩阵的正交特性在数学术语方面意味着矩阵的任何一对行或列都是垂直的。并且在每个列（或行）的元素的平方和等于1。所以这九个元素中有六个约束条件。</p>
<p>  <img src="/images/cons.png"></p>
</li>
<li><p>反对称矩阵定义是：A=-A’（A的转置前加负号），它的第Ⅰ行和第Ⅰ列各数绝对值相等，符号相反。且主对角线上的元素为均为零。一个小的旋转可以用如下的反对称矩阵来描述：</p>
<p>  <img src="/images/anti.png"></p>
</li>
<li>在我们的例子中，运动学与刚体旋转的含义有关。它的结果是一个非线性微分方程，描述了刚体在其向量旋转速度方面的时间演化。方向余弦矩阵都是关于运动学的。</li>
<li>控制和导航可以在笛卡尔坐标系使用DCM完成叉积和点积运算。下面是具体步骤：<ul>
<li>要控制飞机的俯仰，你需要知道这架飞机的俯仰姿态，你可以通过把飞机的翻滚轴与地面垂直做点积。</li>
<li>要控制飞机的翻滚，你需要知道这架飞机的倾斜姿态，你可以通过把飞机的俯仰轴与地面垂直做点积。</li>
<li>要航向，你需要知道你这架飞机相对于你想要去的方向的偏航姿态，可以通过飞机的翻滚轴与想要去的方向的向量做叉积得到。如果是去相反的方向，则是点积运算。</li>
<li>判断飞机是否倒过来，可以通过判断飞机偏航轴与垂直的点积符号，如果小于0，则是朝下的。</li>
<li>计算飞机绕垂直轴的旋转速度，将陀螺仪的旋转矢量转换为地理参考坐标系，然后与垂直轴做点积。</li>
</ul>
</li>
<li>下面将进行深入的理论研究。</li>
<li><p>确定一个合适的坐标系统描述飞机的运动是必要的。对于大多数处理飞机运动的问题，采用了双坐标系。一个坐标系是固定在地球上的，可以被认为是是一个惯性坐标系，是为了飞机运动分析的目的。另一个坐标系是固定在飞机上的，被称为机体坐标系。图2显示了两右手坐标系：</p>
<p>  <img src="/images/frame.png"></p>
<p>  其中 xe、ye、ze 是地球坐标系统,ze 指向地心,xe 指向正东方,ye 指向正北方;<br>xb、yb、zb 为机体坐标系。</p>
</li>
<li><p>飞机的方向经常被描述为三个连续的旋转，其顺序是重要的。旋转角被称为欧拉角。假设机体坐标如下：</p>
<p>  <img src="/images/body.png"></p>
<p>  进行如下的旋转就可以得到上面图2的结果：</p>
<p>  <img src="/images/rotate.png"></p>
<p>  <code>分析</code>：第一步:假设我站在机体坐标中,我需要通过先绕 Xb 轴旋转 \(\Phi\) ，再旋转 Yb 轴旋转 \(\theta\)，最后绕 Zb 轴旋转 \(\psi\)，回到地球坐标系;先求出每次旋转的矩阵。<br>  如果绕机体 X 轴旋转的角度为 \(\Phi\)，那么</p>
<p>  <img src="/images/L1.png"></p>
<p>  这里是怎么得来的呢？先说一下什么是旋转矩阵？如下图所示，我们假设最开始空间的坐标系也就是机体坐标系X\(_A\)，Y\(_A\)，Z\(_A\)就是笛卡尔坐标系，这样我们得到空间A的矩阵V\(_A\)={X\(_A\)，Y\(_A\)，Z\(_A\)}\(^T\)，其实也可以看做是<code>单位阵E</code>。进过旋转后，空间A的三个坐标系变成了图1中红色的三个坐标系X\(_B\)，Y\(_B\)，Z\(_B\)，得到空间B的矩阵V\(_B\)={X\(_B\)，Y\(_B\)，Z\(_B\)}\(^T\)。我们将两个空间联系起来可以得到V\(_B\)=R•V\(_A\)，这里R就是我们所说的旋转矩阵。</p>
<p>  <img src="/images/方向余弦矩阵R.png"></p>
<p>  由于X\(_A\)={1,0,0}\(^T\)，Y\(_A\)={0,1,0}\(^T\)，Z\(_A\)={0,0,1}\(^T\)，结合下图可以看出，旋转矩阵R就是由X\(_B\)，Y\(_B\)，Z\(_B\) 三个向量组成的。讲到这里，大家应该会发现旋转矩阵R满足第一个条件，因为单位向量无论怎么旋转长度肯定不会变而且向量之间的正交性质也不会变。那么旋转矩阵就是正交阵！不过这还不能说明问题，下面我更进一步利用数学公式进行证明。</p>
<p>  <img src="/images/正交矩阵.png"></p>
<p>  进一步讨论之前，我们先说两点数学知识。（1）点乘（dot product）的几何意义：如下图，我们从点乘的公式可以得到α•β相当于β的模乘上α在β上投影的模，所以当|β|=1时，<code>α•β就是指α在β上投影的模</code>。这一点在下面的内容中非常重要，之所以叫余弦矩阵的原因就是这个。（2）旋转矩阵逆的几何意思：这个比较抽象，不过也好理解。旋转矩阵相当于把一个向量（空间）旋转成新的向量（空间），那么逆可以理解为由新的向量（空间）转回原来的向量（空间）。（3）向量是特殊的矩阵，只有一行或一列的矩阵称为向量。向量有叉乘和点乘。矩阵也有，但意义不一样，矩阵还有反对称，逆矩阵等。</p>
<p>  <img src="/images/矩阵推理.png"></p>
<p>  所以上面的公式解析如下：</p>
<p>  <img src="/images/060231194231745.png"></p>
<p>  <img src="/images/061036414865256.png"></p>
<p>  同理，其他方向的旋转计算如下：<br>  如果绕机体 Y 轴旋转的角度为 \(\theta\)，那么</p>
<p>  <img src="/images/L2.png"></p>
<p>  如果绕机体 Z 轴旋转的角度为 \(\psi\)，那么</p>
<p>  <img src="/images/L3.png"></p>
<p>  第二步:由于站在机体坐标上需要按照 X-&gt;Y-&gt;Z 轴的顺序,经过 3 次旋转,才能回到地球坐标系;反过来如果站在地球坐标系,则需要经过 Z-&gt;Y-&gt;X 的三次旋转才能到达机体坐标系。因此我们可以列出从地球坐标系到机体坐标系的<code>DCM矩阵</code>，换句话说此DCM矩阵就是机体坐标在地理坐标系中的表示，其中\(\Phi, \theta, \psi\)为机体在地理坐标系中的姿态角。<br>  $$L(\Phi, \theta, \psi) = L(\psi) <em> L(\theta) </em> L(\Phi);$$<br>  <a href="http://www.ruanyifeng.com/blog/2015/09/matrix-multiplication.html" target="_blank" rel="noopener">矩阵的乘法</a>计算得：</p>
<p>  <img src="/images/endl.png"></p>
</li>
<li><p>方向余弦矩阵：向量的某些类型，如方向，速度，加速度，和转换，（动作）可以转化为旋转参考系中的一个3x3的矩阵。我们感兴趣的是机体参考系和地面参考系。它可以乘以一个向量的方向余弦矩阵旋转：</p>
<p>  <img src="/images/eqn1.png"></p>
</li>
<li><p>由上面的分析可知，方向余弦矩阵与欧拉角之间的关系为：</p>
<p>  <img src="/images/eqn2.png"></p>
</li>
<li><p>方程1方程2表明了如何将机体坐标系中测得的向量转换的地理坐标系中。方程1是以方向余弦角的形式，而2为欧拉角。</p>
<p>  <img src="/images/LLL.png"></p>
<p>  以上整个求解过程是对 matrix3.cpp 代码中 from_euler 函数的解析：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create a rotation matrix given some euler angles</span></span><br><span class="line"><span class="comment">// this is based on http://gentlenav.googlecode.com/files/EulerAngles.pdf</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Matrix3&lt;T&gt;::from_euler(<span class="keyword">float</span> roll, <span class="keyword">float</span> pitch, <span class="keyword">float</span> yaw)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">float</span> cp = cosf(pitch);<span class="comment">//pitch 表示俯仰相对于地球坐标系的角度值</span></span><br><span class="line">    <span class="keyword">float</span> sp = sinf(pitch);</span><br><span class="line">    <span class="keyword">float</span> sr = sinf(roll);<span class="comment">//roll 表示横滚相对于地球坐标系的角度值</span></span><br><span class="line">    <span class="keyword">float</span> cr = cosf(roll);</span><br><span class="line">    <span class="keyword">float</span> sy = sinf(yaw);<span class="comment">//yaw 表示偏航相对于地球坐标的角度值</span></span><br><span class="line">    <span class="keyword">float</span> cy = cosf(yaw);</span><br><span class="line"></span><br><span class="line">    a.x = cp * cy;</span><br><span class="line">    a.y = (sr * sp * cy) - (cr * sy);</span><br><span class="line">    a.z = (cr * sp * cy) + (sr * sy);</span><br><span class="line">    b.x = cp * sy;</span><br><span class="line">    b.y = (sr * sp * sy) + (cr * cy);</span><br><span class="line">    b.z = (cr * sp * sy) - (sr * cy);</span><br><span class="line">    c.x = -sp;</span><br><span class="line">    c.y = sr * cp;</span><br><span class="line">    c.z = cr * cp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  其中a，b，c为类定义的私有变量—向量。<br>  通过不同的旋转顺序可以得到不同的旋转矩阵，如果从地球坐标系到体坐标系,按照 Z-&gt;X-&gt;Y 轴的顺序旋转可以得到from_euler312函数，这里就没做具体讲解。</p>
<p>  <code>问题</code>：反过来也就可以通过方向余弦矩阵来求出旋转角</p>
<p>  <img src="/images/3r.png"></p>
<p>  函数 to_euler 式通过上面的 3 个公式求出对应的角度的</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// calculate euler angles from a rotation matrix</span></span><br><span class="line"><span class="comment">// this is based on http://gentlenav.googlecode.com/files/EulerAngles.pdf</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Matrix3&lt;T&gt;::to_euler(<span class="keyword">float</span> *roll, <span class="keyword">float</span> *pitch, <span class="keyword">float</span> *yaw) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pitch != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *pitch = -safe_asin(c.x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (roll != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *roll = atan2f(c.y, c.z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (yaw != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *yaw = atan2f(b.x, a.x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>地理坐标系中向量的每个分量等于相对应的旋转矩阵的行与机体坐标向量的点积。计算旋转矩阵需要9个乘法和6个加法运算。方程3是方程1的复述，用乘法展开向量和矩阵的元素。所以如果知道机体坐标向量，即可得地理坐标向量的大小：</p>
<p>  <img src="/images/eqn3.png"></p>
</li>
<li>需要注意的是，矩阵R不一定是对称的。R矩阵的三列对应于机体坐标的三个轴向量到地理坐标的变换。R矩阵的三行则对应于地理坐标三个轴向量到机体坐标的变换。该R矩阵描述了所有机体相对于地球方向的信息。R矩阵也称为方向余弦矩阵，因为每个分量都是机体坐标轴与地理坐标轴夹角的余弦，通过看推理余弦矩阵部分可以看出来。</li>
<li><p>矩阵的转置，特别在旋转矩阵中，表示为\(R^T\)，通过交换行和列得到。一般来说，一个方形矩阵的逆矩阵如果存在的话，表示为\(R^{−1}\)。矩阵的逆乘以矩阵得到的是单位矩阵。（单位矩阵就是对角线上元素为1,其余为0,单位矩阵乘以任何矩阵得到它本身），对于旋转矩阵来说，逆就等于它的转置。</p>
<p>  <img src="/images/eqn4.png"></p>
</li>
<li><p>之所以旋转矩阵逆就等于它的转置考虑到了对称性的情况。旋转矩阵的元素都是机体轴与地理坐标轴之间的余弦值，相反的情况就相当于交换地理坐标和机体坐标的角色，也就是说交换行与列，这跟转置是一样的。实际上这又和正交条件达成一致：</p>
<ul>
<li>正交矩阵每一列都是单位矩阵，并且两两正交。最简单的正交矩阵就是单位阵。</li>
<li>正交矩阵的逆（inverse）等于正交矩阵的转置（transpose）。同时可以推论出正交矩阵的行列式的值肯定为正负1的。</li>
<li><p>正交矩阵满足很多矩阵性质，比如可以相似于对角矩阵等等。</p>
<p>如下：</p>
<p><img src="/images/eqn5.png"></p>
<p>这个方程用来证明矩阵的逆的矩阵的转置。</p>
</li>
</ul>
</li>
<li><p>旋转矩阵的一个非常有用的特性是，我们可以组成旋转。</p>
<p>  <img src="/images/eqn6.png"></p>
<p>  这里特别需要小心运算顺序，因为它的效果是完全不一样的。</p>
</li>
<li><p>另外这里还有一些有用的特性，如：</p>
<p>  <img src="/images/eqn7.png"></p>
</li>
<li><p>下面介绍一下点乘和叉乘。</p>
</li>
<li><p>这里有两个DCM计算里边用到的向量运算——点乘和叉乘。点乘是表量运算，A向量作为行向量，B向量作为列向量。</p>
<p>  <img src="/images/eqn8.png"></p>
<p>  可以证明向量的点乘等于两个向量的长度乘以它们角度的余弦值。</p>
<p>  <img src="/images/eqn9.png"></p>
<p>  所以向量的点乘是对称的。A \(\cdot\) B = B \(\cdot\) A</p>
<p>  而两个向量的叉乘是一个向量。它的元素是这样计算的：</p>
<p>  <img src="/images/eqn10.png"></p>
<p>  从物理意义上来分析：</p>
<p>  <img src="/images/eqn11.png"></p>
<p>  所以叉乘是反对称的，A \(\times\) B = - B \(\times\) A</p>
</li>
</ul>
<p><strong>方向余弦矩阵的更新</strong></p>
<ul>
<li>下面到了DCM算法的核心部分——由陀螺仪计算方向余弦矩阵。</li>
<li><p>核心概念：非线性微分方程——方向余弦的变化速率与陀螺仪之间的关系。我们的目标是计算方向余弦而不是任何违反方程非线性的近似解。目前，我们假设陀螺仪信号没有错误。稍后我们将解决陀螺仪漂移问题。<br>不像机械陀螺，我们不能通过简单地积分陀螺仪信号得到角度。一个有名的运动学公式，关于旋转向量的变化率和它的旋转之间的关系：</p>
<p>  <img src="/images/eqn12.png"></p>
<p>  下面解释一下这个公式，如下图所示，r为任意的旋转向量，t时刻的坐标为r(t)。时间间隔dt后：r = r (t) , r’= r (t+dt) and dr = r’ – r。<br>  dt时间后向量r绕着与单位向量u同向的轴旋转了d\(\theta\)，停到了向量r’的位置。其中u垂直与旋转的机身，因此u正交于r与r’，图中显示了u与u’，它们与r和r‘的叉乘结果方向相同。故有<br>  u = (r x r’) / |r x r’| = (r x r’) / (|r|| r’|sin(dθ)) = (r x r’) / (|r|2 sin(dθ))<br>  由于旋转并不改变向量的长度，因此有| r’| = |r|。<br>  向量r的线速度可以表示如下：<br>  v = dr / dt = ( r’ – r) / dt<br>  v = w x r<br>  故可以得出上面的公式。</p>
<p>  <img src="http://www.starlino.com/wp-content/uploads/2011/11/clip_image0144_thumb.jpg"></p>
<p>  有一个需要注意的地方：</p>
<ul>
<li>微分方程是非线性的。旋转向量输入是与我们要进行积分的变量进行叉乘。因此，任何线性的方法都只是一种近似。</li>
<li>两个向量都应该在同一个坐标系中测量。</li>
<li>因为叉乘是不对称的，所以我们需要保存结果，然后改变它的方向。</li>
</ul>
</li>
<li><p>如果知道了初始状态和旋转向量的时间，我们可以通过方程11的数值积分来跟踪旋转向量。</p>
<p>  <img src="/images/eqn13.png"></p>
<p>  将方程13用于R矩阵的行或列中，可看作成旋转向量。<br>  这里遇到的第一个问题是，我们要跟踪的向量和旋转向量不是在同一坐标系做测量的。理想情况下，我们都是在地理坐标轴中跟踪机体坐标轴，但是陀螺仪是在机体坐标中测量的。一个简单的方法是通过对称性解决，地理坐标在机体坐标中旋转和机体坐标在地理坐标中旋转是相反的，所以只要改变陀螺仪的符号就好了，更加方便的方法是，交换叉乘的顺序就好了。</p>
<p>  <img src="/images/eqn14.png"></p>
<p>  这里的向量代表的是方程1中R矩阵的行。下面的问题是怎么实施方程14，回归到方程14的微分方程形式：</p>
<p>  <img src="/images/eqn15.png"></p>
<p>  由这里可知方向余弦矩阵R的行都是通过\(r_{earth}(t) \times d\theta(t)\)积分得到的。<br>  所以<code>根据陀螺仪的角度值,来计算当前机体的姿态 DCM矩阵</code>，其使用的方法是：机体坐标的每个轴的向量与 g(陀螺仪改变的角度向量)求叉积，这里求的是角度改变后,姿态在各个方向上的变化量，所以最后使用了矩阵的加法。源码matrix3.cpp中的函数体现如下：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// apply an additional rotation from a body frame gyro vector</span></span><br><span class="line"><span class="comment">// to a rotation matrix.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Matrix3&lt;T&gt;::rotate(<span class="keyword">const</span> Vector3&lt;T&gt; &amp;g)</span><br><span class="line">&#123;</span><br><span class="line">    Matrix3&lt;T&gt; temp_matrix;</span><br><span class="line">    temp_matrix.a.x = a.y * g.z - a.z * g.y;</span><br><span class="line">    temp_matrix.a.y = a.z * g.x - a.x * g.z;</span><br><span class="line">    temp_matrix.a.z = a.x * g.y - a.y * g.x;</span><br><span class="line">    temp_matrix.b.x = b.y * g.z - b.z * g.y;</span><br><span class="line">    temp_matrix.b.y = b.z * g.x - b.x * g.z;</span><br><span class="line">    temp_matrix.b.z = b.x * g.y - b.y * g.x;</span><br><span class="line">    temp_matrix.c.x = c.y * g.z - c.z * g.y;</span><br><span class="line">    temp_matrix.c.y = c.z * g.x - c.x * g.z;</span><br><span class="line">    temp_matrix.c.z = c.x * g.y - c.y * g.x;</span><br><span class="line"></span><br><span class="line">    (*<span class="keyword">this</span>) += temp_matrix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>还有一件事需要做，陀螺仪漂移将在后面进行。我们需要通过比例积分补偿反馈控制器来添加旋转速率校准到陀螺仪测量的数据上，以此产生最优的角速率估计。</p>
<p>  <img src="/images/eqn16.png"></p>
<p>  基本上，我们的GPS和加速度计的参考向量被用来计算旋转误差，并通过反馈控制器输入计算，然后更新原有计算。</p>
</li>
<li><p>我们可以把方程15转化为矩阵的形式，这里推导有点复杂，可以了解下矢量阵或者<a href="http://blog.csdn.net/qq_21842557/article/details/50993809" target="_blank" rel="noopener">summer的文章</a>，如下：</p>
<p>  <img src="/images/eqn17.png"></p>
<p>  方程17就是从陀螺仪信号更新方向余弦矩阵，其对角线上的1就为方程15的第一个条目，其余的为第二个条目，这种方法是用矩阵的乘法实现的，它包含27个乘法和18个加法。正好适合dsPIC30F4011，因为它支持矩阵乘法运算，如果芯片不支持，也可以用方程15的积分形式实现。故在apm里采用的是积分形式累加的。矩阵更新的源码体现如下：   </p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// update the DCM matrix using only the gyros</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">AP_AHRS_DCM::matrix_update(<span class="keyword">float</span> _G_Dt)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// note that we do not include the P terms in _omega. This is</span></span><br><span class="line">    <span class="comment">// because the spin_rate is calculated from _omega.length(),</span></span><br><span class="line">    <span class="comment">// and including the P terms would give positive feedback into</span></span><br><span class="line">    <span class="comment">// the _P_gain() calculation, which can lead to a very large P</span></span><br><span class="line">    <span class="comment">// value</span></span><br><span class="line">    _omega.zero();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// average across first two healthy gyros. This reduces noise on</span></span><br><span class="line">    <span class="comment">// systems with more than one gyro. We don't use the 3rd gyro</span></span><br><span class="line">    <span class="comment">// unless another is unhealthy as 3rd gyro on PH2 has a lot more</span></span><br><span class="line">    <span class="comment">// noise</span></span><br><span class="line">    <span class="keyword">uint8_t</span> healthy_count = <span class="number">0</span>;</span><br><span class="line">    Vector3f delta_angle;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint8_t</span> i=<span class="number">0</span>; i&lt;_ins.get_gyro_count(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_ins.get_gyro_health(i) &amp;&amp; healthy_count &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            Vector3f dangle;</span><br><span class="line">            <span class="keyword">if</span> (_ins.get_delta_angle(i, dangle)) &#123;</span><br><span class="line">                healthy_count++;</span><br><span class="line">                delta_angle += dangle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (healthy_count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        delta_angle /= healthy_count; <span class="comment">//获取角度变化量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (_G_Dt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        _omega = delta_angle / _G_Dt;</span><br><span class="line">        _omega += _omega_I;</span><br><span class="line">        _dcm_matrix.rotate((_omega + _omega_P + _omega_yaw_P) * _G_Dt); <span class="comment">//将角度变化量与旋转向量进行叉乘，然后累加</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>再归一化重整</strong></p>
<ul>
<li>由于上述的公式是在dt非常小的情况下才误差比较小，这种数字误差将驱使方程4的正交条件逐渐不满足，导致坐标系的两个轴不再能描述刚体。值得幸运的是，数字误差累加的很慢，我们完全可以提前采取办法解决它。<br>我们将这种解决办法称为归一化，我们设计了几种方法，模拟实现都可行，最后选择了一种最优的方法。   </li>
<li><p>首先计算矩阵列向量X、Y的点乘，理论上应该等于0，所以它的结果可以看出向量偏了多少。</p>
<p>  <img src="/images/eqn18.png"></p>
<p>  将这个误差平分到X、Y向量：   </p>
<p>  <img src="/images/eqn19.png"></p>
<p>  可以将方程19代人方程18中，验证正交性误差大大减少了。记住R矩阵的行与列的范数为1，将误差平分给两个轴比只分个一个产生较低的残余误差。    </p>
</li>
<li><p>下一步就是调整Z列向量正交于X和Y。这个很简单，只要进行叉乘就可以了：   </p>
<p>  <img src="/images/eqn20.png"></p>
</li>
<li><p>最后一步为，确保R矩阵的各列向量的模为1，一种方法可以通过平方根来求，但是这里有一种更加简单的办法，考虑到这个模不会与1有太大差别，这里可以使用泰勒展开。   </p>
<p>  <img src="/images/eqn21.png"></p>
<p>  方程21做的事情就是调整各列向量的模为1。展开为3减去向量模的平方，乘以1/2，再乘以这个向量。所以计算更加简单。<br>  源码实现如下：   </p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************</span></span><br><span class="line"><span class="comment">	-  Direction Cosine Matrix IMU: Theory</span></span><br><span class="line"><span class="comment">	-  William Premerlani and Paul Bizard</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment">	-  Numerical errors will gradually reduce the orthogonality conditions expressed by equation 5</span></span><br><span class="line"><span class="comment">	-  to approximations rather than identities. In effect, the axes in the two frames of reference no</span></span><br><span class="line"><span class="comment">	-  longer describe a rigid body. Fortunately, numerical error accumulates very slowly, so it is a</span></span><br><span class="line"><span class="comment">	-  simple matter to stay ahead of it.</span></span><br><span class="line"><span class="comment">	-  We call the process of enforcing the orthogonality conditions ÒrenormalizationÓ.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">AP_AHRS_DCM::normalize(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">float</span> error;</span><br><span class="line">    Vector3f t0, t1, t2;</span><br><span class="line"></span><br><span class="line">    error = _dcm_matrix.a * _dcm_matrix.b;                                              <span class="comment">// eq.18</span></span><br><span class="line"></span><br><span class="line">    t0 = _dcm_matrix.a - (_dcm_matrix.b * (<span class="number">0.5f</span> * error));              <span class="comment">// eq.19</span></span><br><span class="line">    t1 = _dcm_matrix.b - (_dcm_matrix.a * (<span class="number">0.5f</span> * error));              <span class="comment">// eq.19</span></span><br><span class="line">    t2 = t0 % t1;                                                       <span class="comment">// c= a x b // eq.20</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!renorm(t0, _dcm_matrix.a) ||</span><br><span class="line">            !renorm(t1, _dcm_matrix.b) ||</span><br><span class="line">            !renorm(t2, _dcm_matrix.c)) &#123;</span><br><span class="line">        <span class="comment">// Our solution is blowing up and we will force back</span></span><br><span class="line">        <span class="comment">// to last euler angles</span></span><br><span class="line">        _last_failure_ms = AP_HAL::millis();</span><br><span class="line">        AP_AHRS_DCM::reset(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// renormalise one vector component of the DCM matrix</span></span><br><span class="line"><span class="comment">// this will return false if renormalization fails</span></span><br><span class="line"><span class="keyword">bool</span></span><br><span class="line">AP_AHRS_DCM::renorm(Vector3f <span class="keyword">const</span> &amp;a, Vector3f &amp;result)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">float</span> renorm_val;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// numerical errors will slowly build up over time in DCM,</span></span><br><span class="line">    <span class="comment">// causing inaccuracies. We can keep ahead of those errors</span></span><br><span class="line">    <span class="comment">// using the renormalization technique from the DCM IMU paper</span></span><br><span class="line">    <span class="comment">// (see equations 18 to 21).</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// For APM we don't bother with the taylor expansion</span></span><br><span class="line">    <span class="comment">// optimisation from the paper as on our 2560 CPU the cost of</span></span><br><span class="line">    <span class="comment">// the sqrt() is 44 microseconds, and the small time saving of</span></span><br><span class="line">    <span class="comment">// the taylor expansion is not worth the potential of</span></span><br><span class="line">    <span class="comment">// additional error buildup.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Note that we can get significant renormalisation values</span></span><br><span class="line">    <span class="comment">// when we have a larger delta_t due to a glitch eleswhere in</span></span><br><span class="line">    <span class="comment">// APM, such as a I2c timeout or a set of EEPROM writes. While</span></span><br><span class="line">    <span class="comment">// we would like to avoid these if possible, if it does happen</span></span><br><span class="line">    <span class="comment">// we don't want to compound the error by making DCM less</span></span><br><span class="line">    <span class="comment">// accurate.</span></span><br><span class="line"></span><br><span class="line">    renorm_val = <span class="number">1.0f</span> / a.length(); <span class="comment">//这里并没有使用泰勒展开，考虑的节省的时间不多</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// keep the average for reporting</span></span><br><span class="line">    _renorm_val_sum += renorm_val;</span><br><span class="line">    _renorm_val_count++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(renorm_val &lt; <span class="number">2.0f</span> &amp;&amp; renorm_val &gt; <span class="number">0.5f</span>)) &#123;</span><br><span class="line">        <span class="comment">// this is larger than it should get - log it as a warning</span></span><br><span class="line">        <span class="keyword">if</span> (!(renorm_val &lt; <span class="number">1.0e6</span>f &amp;&amp; renorm_val &gt; <span class="number">1.0e-6</span>f)) &#123;</span><br><span class="line">            <span class="comment">// we are getting values which are way out of</span></span><br><span class="line">            <span class="comment">// range, we will reset the matrix and hope we</span></span><br><span class="line">            <span class="comment">// can recover our attitude using drift</span></span><br><span class="line">            <span class="comment">// correction before we hit the ground!</span></span><br><span class="line">            <span class="comment">//Serial.printf("ERROR: DCM renormalisation error. renorm_val=%f\n",</span></span><br><span class="line">            <span class="comment">//	   renorm_val);</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result = a * renorm_val;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="EKF设计与实现"><a href="#EKF设计与实现" class="headerlink" title="EKF设计与实现"></a>EKF设计与实现</h2><p>资料搜集</p>
<ul>
<li><a href="https://pixhawk.org/_media/firmware/apps/attitude_estimator_ekf/ekf_excerptmasterthesis.pdf" target="_blank" rel="noopener">pixhawk ekf</a></li>
<li><a href="http://www.goddardconsulting.ca/simulink-extended-kalman-filter-quarter-car.html" target="_blank" rel="noopener">Matlab仿真EKF</a></li>
<li><a href="http://www.mathworks.com/matlabcentral/fileexchange/18189-learning-the-extended-kalman-filter" target="_blank" rel="noopener">Learning the Extended Kalman Filter</a></li>
<li><a href="https://www.politesi.polimi.it/handle/10589/80681?locale=en" target="_blank" rel="noopener">An application of the extended Kalman filter to the attitude control of a quadrotor</a></li>
<li><a href="http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=4052858&amp;queryText=kalman%20uav&amp;newsearch=true" target="_blank" rel="noopener">UAV Linear and Nonlinear Estimation Using Extended Kalman Filter</a>/<a href="https://www.researchgate.net/profile/SG_Anavatti/publication/224683270_UAV_Linear_and_Nonlinear_Estimation_Using_Extended_Kalman_Filter/links/5403c4ad0cf2c48563b030e7.pdf" target="_blank" rel="noopener">pdf</a></li>
<li><a href="http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=5676596&amp;queryText=kalman%20uav&amp;newsearch=true" target="_blank" rel="noopener">Performance analysis of a Kalman Filter based attitude estimator for a Quad Rotor UAV</a>/<a href="https://www.researchgate.net/profile/R_Munasinghe/publication/224208354_Performance_analysis_of_a_Kalman_Filter_based_attitude_estimator_for_a_Quad_Rotor_UAV/links/55cf1a1408aee19936fc6bb3.pdf" target="_blank" rel="noopener">pdf</a></li>
<li><a href="http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=7101625&amp;queryText=kalman%20uav&amp;sortType=desc_p_Publication_Year&amp;searchField=Search_All" target="_blank" rel="noopener">Stabilization and Altitude Control of an Indoor Low-Cost Quadrotor: Design and Experimental Results</a>/<a href="https://www.researchgate.net/profile/Alexandra_Moutinho/publication/275348356_Stabilization_and_altitude_control_of_an_indoor_low-cost_quadrotor_design_and_experimental_results/links/553a04c10cf2239f4e7dbc36.pdf" target="_blank" rel="noopener">pdf</a></li>
</ul>
<p>APM的EKF源码流分析：<br>ArduCopter.cpp里fast_loop函数里的姿态更新部分如下：    </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> AP_AHRS_NavEKF::update(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    update_DCM();</span><br><span class="line">    update_EKF1();</span><br><span class="line">    update_EKF2();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CONFIG_HAL_BOARD == HAL_BOARD_SITL</span></span><br><span class="line">    update_SITL();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里看出姿态估算使用了DCM和EKF算法，而EKF由分为两种，第一种为默认推荐的稳定版代码飞行的，第二种为git上master的，是另外一种形式的升级版EKF，这种EKF可以通过一个移动的平台起飞。下面以master版本分析，具体解释如下：   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> AP_AHRS_NavEKF::update_EKF2(<span class="keyword">void</span>) <span class="comment">//master版（即开发版）实验表明，最后是由这个函数生成的姿态角</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!ekf2_started) &#123;</span><br><span class="line">        <span class="comment">// wait 1 second for DCM to output a valid tilt error estimate</span></span><br><span class="line">        <span class="keyword">if</span> (start_time_ms == <span class="number">0</span>) &#123;</span><br><span class="line">            start_time_ms = AP_HAL::millis();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (AP_HAL::millis() - start_time_ms &gt; startup_delay_ms) &#123;</span><br><span class="line">            ekf2_started = EKF2.InitialiseFilter(); <span class="comment">//使用了DCM的_error_rp = 0.8f * _error_rp + 0.2f * best_error;，来源drift_correction，所以EKF依赖于DCM</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ekf2_started) &#123;</span><br><span class="line">        EKF2.UpdateFilter();</span><br><span class="line">        <span class="keyword">if</span> (active_EKF_type() == EKF_TYPE2) &#123;</span><br><span class="line">            Vector3f eulers;</span><br><span class="line">            EKF2.getRotationBodyToNED(_dcm_matrix); <span class="comment">////这里的矩阵重新赋值了DCM矩阵，即姿态</span></span><br><span class="line">            EKF2.getEulerAngles(<span class="number">-1</span>,eulers);</span><br><span class="line">            roll  = eulers.x; <span class="comment">//生成roll</span></span><br><span class="line">            pitch = eulers.y;</span><br><span class="line">            yaw   = eulers.z;</span><br><span class="line"></span><br><span class="line">            update_cd_values(); <span class="comment">//生成roll_sensor</span></span><br><span class="line">            update_trig(); <span class="comment">//生成_cos_roll</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// keep _gyro_bias for get_gyro_drift()</span></span><br><span class="line">            EKF2.getGyroBias(<span class="number">-1</span>,_gyro_bias);</span><br><span class="line">            _gyro_bias = -_gyro_bias;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// calculate corrected gryo estimate for get_gyro()</span></span><br><span class="line">            _gyro_estimate.zero();</span><br><span class="line">            <span class="keyword">uint8_t</span> healthy_count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">uint8_t</span> i=<span class="number">0</span>; i&lt;_ins.get_gyro_count(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (_ins.get_gyro_health(i) &amp;&amp; healthy_count &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                    _gyro_estimate += _ins.get_gyro(i);</span><br><span class="line">                    healthy_count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (healthy_count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                _gyro_estimate /= healthy_count;</span><br><span class="line">            &#125;</span><br><span class="line">            _gyro_estimate += _gyro_bias;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">float</span> abias;</span><br><span class="line">            EKF2.getAccelZBias(<span class="number">-1</span>,abias);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// This EKF uses the primary IMU</span></span><br><span class="line">            <span class="comment">// Eventually we will run a separate instance of the EKF for each IMU and do the selection and blending of EKF outputs upstream</span></span><br><span class="line">            <span class="comment">// update _accel_ef_ekf</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">uint8_t</span> i=<span class="number">0</span>; i&lt;_ins.get_accel_count(); i++) &#123;</span><br><span class="line">                Vector3f accel = _ins.get_accel(i);</span><br><span class="line">                <span class="keyword">if</span> (i==_ins.get_primary_accel()) &#123;</span><br><span class="line">                    accel.z -= abias;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (_ins.get_accel_health(i)) &#123;</span><br><span class="line">                    _accel_ef_ekf[i] = _dcm_matrix * accel;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            _accel_ef_ekf_blended = _accel_ef_ekf[_ins.get_primary_accel()];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>概要：</code>在这个函数里有一个active_EKF_type()函数，通过分析可知它的值为EKF_TYPE2，故使用的是EKF2算法。具体分析如下   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">AP_AHRS_NavEKF::EKF_TYPE AP_AHRS_NavEKF::active_EKF_type(<span class="keyword">void</span>) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    EKF_TYPE ret = EKF_TYPE_NONE;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    enum EKF_TYPE &#123;EKF_TYPE_NONE=0,</span></span><br><span class="line"><span class="comment">                   EKF_TYPE1=1,</span></span><br><span class="line"><span class="comment">                   EKF_TYPE2=2</span></span><br><span class="line"><span class="comment">#if CONFIG_HAL_BOARD == HAL_BOARD_SITL</span></span><br><span class="line"><span class="comment">                   ,EKF_TYPE_SITL=10</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">    &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">switch</span> (ekf_type()) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> EKF_TYPE_NONE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: &#123; </span><br><span class="line">        <span class="comment">// do we have an EKF yet?</span></span><br><span class="line">        <span class="keyword">if</span> (!ekf1_started) &#123;</span><br><span class="line">            <span class="keyword">return</span> EKF_TYPE_NONE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (always_use_EKF()) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    bool always_use_EKF() const &#123;</span></span><br><span class="line"><span class="comment">        return _ekf_flags &amp; FLAG_ALWAYS_USE_EKF; //下面分析这两个数据,结果为0</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// constructor</span></span><br><span class="line"><span class="comment">AP_AHRS_NavEKF::AP_AHRS_NavEKF(AP_InertialSensor &amp;ins, AP_Baro &amp;baro, AP_GPS &amp;gps, RangeFinder &amp;rng,</span></span><br><span class="line"><span class="comment">                               NavEKF &amp;_EKF1, NavEKF2 &amp;_EKF2, Flags flags) :</span></span><br><span class="line"><span class="comment">    AP_AHRS_DCM(ins, baro, gps),</span></span><br><span class="line"><span class="comment">    EKF1(_EKF1),</span></span><br><span class="line"><span class="comment">    EKF2(_EKF2),</span></span><br><span class="line"><span class="comment">    _ekf_flags(flags)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    _dcm_matrix.identity();</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">enum Flags &#123;</span></span><br><span class="line"><span class="comment">        FLAG_NONE = 0,</span></span><br><span class="line"><span class="comment">        FLAG_ALWAYS_USE_EKF = 0x1, //FLAG_ALWAYS_USE_EKF = 0x1</span></span><br><span class="line"><span class="comment">    &#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // Constructor</span></span><br><span class="line"><span class="comment">    AP_AHRS_NavEKF(AP_InertialSensor &amp;ins, AP_Baro &amp;baro, AP_GPS &amp;gps, RangeFinder &amp;rng,</span></span><br><span class="line"><span class="comment">                   NavEKF &amp;_EKF1, NavEKF2 &amp;_EKF2, Flags flags = FLAG_NONE); //所以_ekf_flags = FLAG_NONE = 0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        	<span class="keyword">uint8_t</span> ekf_faults;</span><br><span class="line">            EKF1.getFilterFaults(ekf_faults);</span><br><span class="line">            <span class="keyword">if</span> (ekf_faults == <span class="number">0</span>) &#123;</span><br><span class="line">                ret = EKF_TYPE1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (EKF1.healthy()) &#123;</span><br><span class="line">            ret = EKF_TYPE1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: &#123; <span class="comment">//由下面的函数分析可知，应该会跳到这里</span></span><br><span class="line">        <span class="comment">// do we have an EKF2 yet?</span></span><br><span class="line">        <span class="keyword">if</span> (!ekf2_started) &#123;</span><br><span class="line">            <span class="keyword">return</span> EKF_TYPE_NONE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (always_use_EKF()) &#123;</span><br><span class="line">            <span class="keyword">uint8_t</span> ekf2_faults;</span><br><span class="line">            EKF2.getFilterFaults(<span class="number">-1</span>,ekf2_faults);</span><br><span class="line">            <span class="keyword">if</span> (ekf2_faults == <span class="number">0</span>) &#123;</span><br><span class="line">                ret = EKF_TYPE2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (EKF2.healthy()) &#123;</span><br><span class="line">            ret = EKF_TYPE2; <span class="comment">//最终的返回结果</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CONFIG_HAL_BOARD == HAL_BOARD_SITL</span></span><br><span class="line">    <span class="keyword">case</span> EKF_TYPE_SITL:</span><br><span class="line">        ret = EKF_TYPE_SITL;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      fixed wing and rover when in fly_forward mode will fall back to</span></span><br><span class="line"><span class="comment">      DCM if the EKF doesn't have GPS. This is the safest option as</span></span><br><span class="line"><span class="comment">      DCM is very robust</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (ret != EKF_TYPE_NONE &amp;&amp;</span><br><span class="line">        (_vehicle_class == AHRS_VEHICLE_FIXED_WING ||</span><br><span class="line">         _vehicle_class == AHRS_VEHICLE_GROUND) &amp;&amp;</span><br><span class="line">        _flags.fly_forward) &#123;</span><br><span class="line">        nav_filter_status filt_state;</span><br><span class="line">        <span class="keyword">if</span> (ret == EKF_TYPE1) &#123;</span><br><span class="line">            EKF1.getFilterStatus(filt_state);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CONFIG_HAL_BOARD == HAL_BOARD_SITL</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == EKF_TYPE_SITL) &#123;</span><br><span class="line">            get_filter_status(filt_state);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            EKF2.getFilterStatus(<span class="number">-1</span>,filt_state);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (hal.util-&gt;get_soft_armed() &amp;&amp; !filt_state.flags.using_gps &amp;&amp; _gps.status() &gt;= AP_GPS::GPS_OK_FIX_3D) &#123;</span><br><span class="line">            <span class="comment">// if the EKF is not fusing GPS and we have a 3D lock, then</span></span><br><span class="line">            <span class="comment">// plane and rover would prefer to use the GPS position from</span></span><br><span class="line">            <span class="comment">// DCM. This is a safety net while some issues with the EKF</span></span><br><span class="line">            <span class="comment">// get sorted out</span></span><br><span class="line">            <span class="keyword">return</span> EKF_TYPE_NONE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (hal.util-&gt;get_soft_armed() &amp;&amp; filt_state.flags.const_pos_mode) &#123;</span><br><span class="line">            <span class="keyword">return</span> EKF_TYPE_NONE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!filt_state.flags.attitude ||</span><br><span class="line">                !filt_state.flags.horiz_vel ||</span><br><span class="line">                !filt_state.flags.vert_vel ||</span><br><span class="line">                !filt_state.flags.horiz_pos_abs ||</span><br><span class="line">                !filt_state.flags.vert_pos) &#123;</span><br><span class="line">            <span class="keyword">return</span> EKF_TYPE_NONE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中又涉及到了ekf_type函数，可知返回值为2：   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//canonicalise _ekf_type, forcing it to be 0, 1 or 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint8_t</span> AP_AHRS_NavEKF::ekf_type(<span class="keyword">void</span>) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> type = _ekf_type; <span class="comment">//由下面的分析，默认_ekf_type的值为2</span></span><br><span class="line">    <span class="keyword">if</span> (always_use_EKF() &amp;&amp; type == <span class="number">0</span>) &#123; <span class="comment">//如果总是使用EKF且默认type为0时，那么type就强制为1</span></span><br><span class="line">        type = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  bool always_use_EKF() const &#123;</span></span><br><span class="line"><span class="comment">//      return _ekf_flags &amp; FLAG_ALWAYS_USE_EKF; //位运算，结果为0</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// check for invalid type</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CONFIG_HAL_BOARD == HAL_BOARD_SITL</span></span><br><span class="line">    <span class="keyword">if</span> (type &gt; <span class="number">2</span> &amp;&amp; type != EKF_TYPE_SITL) &#123; <span class="comment">//检查type是否有效，只有为SIL的时候才能大于2</span></span><br><span class="line">        type = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">if</span> (type &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        type = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>_ekf_type的默认取值分析。   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> AP_AHRS_NAVEKF_AVAILABLE <span class="comment">//_ekf_type的默认取值为2</span></span></span><br><span class="line">    <span class="comment">// @Param: EKF_TYPE</span></span><br><span class="line">    <span class="comment">// @DisplayName: Use NavEKF Kalman filter for attitude and position estimation</span></span><br><span class="line">    <span class="comment">// @Description: This controls whether the NavEKF Kalman filter is used for attitude and position estimation and whether fallback to the DCM algorithm is allowed. Note that on copters "disabled" is not available, and will be the same as "enabled - no fallback"</span></span><br><span class="line">    <span class="comment">// @Values: 0:Disabled,1:Enabled,2:Enable EKF2</span></span><br><span class="line">    <span class="comment">// @User: Advanced</span></span><br><span class="line">    AP_GROUPINFO(<span class="string">"EKF_TYPE"</span>,  <span class="number">14</span>, AP_AHRS, _ekf_type, <span class="number">2</span>),</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>在DCM算法里，与ekf算法一样，最后都生成了roll, roll_sensor， _cos_roll。   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// calculate the euler angles and DCM matrix which will be used for high level</span></span><br><span class="line"><span class="comment">// navigation control. Apply trim such that a positive trim value results in a</span></span><br><span class="line"><span class="comment">// positive vehicle rotation about that axis (ie a negative offset)</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">AP_AHRS_DCM::euler_angles(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    _body_dcm_matrix = _dcm_matrix;</span><br><span class="line">    _body_dcm_matrix.rotateXYinv(_trim);</span><br><span class="line">    _body_dcm_matrix.to_euler(&amp;roll, &amp;pitch, &amp;yaw);</span><br><span class="line"></span><br><span class="line">    update_cd_values();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  update the centi-degree values</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> AP_AHRS::update_cd_values(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    roll_sensor  = degrees(roll) * <span class="number">100</span>;</span><br><span class="line">    pitch_sensor = degrees(pitch) * <span class="number">100</span>;</span><br><span class="line">    yaw_sensor   = degrees(yaw) * <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">if</span> (yaw_sensor &lt; <span class="number">0</span>)</span><br><span class="line">        yaw_sensor += <span class="number">36000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// update trig values including _cos_roll, cos_pitch</span></span><br><span class="line">update_trig();</span><br></pre></td></tr></table></figure>
<p><code>EKF1与EKF2的切换</code>：这里假设你自己在开发版代码中想使用EKF1怎么办？<br>直接进行参数配置或者在地面站修改EKF相关的参数即可，具体如下修改即可   </p>
<ol>
<li><p>源码修改，全局搜索到如下地方，更改成下面的样子。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AP_GROUPINFO_FLAGS(<span class="string">"ENABLE"</span>, <span class="number">0</span>, NavEKF2, _enable, <span class="number">0</span>, AP_PARAM_FLAG_ENABLE),</span><br><span class="line">AP_GROUPINFO_FLAGS(<span class="string">"ENABLE"</span>, <span class="number">34</span>, NavEKF, _enable, <span class="number">1</span>, AP_PARAM_FLAG_ENABLE),</span><br><span class="line">AP_GROUPINFO(<span class="string">"EKF_TYPE"</span>,  <span class="number">14</span>, AP_AHRS, _ekf_type, <span class="number">1</span>),</span><br></pre></td></tr></table></figure>
</li>
<li><p>地面站也是要修改三个地方。</p>
<p> <img src="/images/ahrs.png"></p>
<p> <img src="/images/ek.png"></p>
<p> <img src="/images/ekfenable.png"></p>
</li>
</ol>
<p>可以总结出各个参数都在各自的cpp文件中有默认值<br>如AP_MotorsMulticopter.cpp中的AP_GROUPINFO(“CURR_MAX”, 12, AP_MotorsMulticopter, _batt_current_max, AP_MOTORS_CURR_MAX_DEFAULT),设置解锁时电机的转速。</p>
<p><br></p>
<h1 id="姿态控制"><a href="#姿态控制" class="headerlink" title="姿态控制"></a>姿态控制</h1><blockquote>
<p>预习材料：<a href="www.nephen.com/2015/12/pixhawk试飞报告#pid调节">PID参数调节</a>/<a href="http://www.anotc.com/Articles/Browse/3" target="_blank" rel="noopener">串级PID</a>/<a href="http://blog.csdn.net/nemol1990/article/details/45131603" target="_blank" rel="noopener">串级PID1</a></p>
</blockquote>
<p>下面将先进行APM源码自稳模式的PID数据流分析：<br>在AC_AttitudeControl.cpp里   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> AC_AttitudeControl::attitude_controller_run_quat(<span class="keyword">const</span> Quaternion&amp; att_target_quat, <span class="keyword">const</span> Vector3f&amp; att_target_ang_vel_rads)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Update euler attitude target and angular velocity target</span></span><br><span class="line">    att_target_quat.to_euler(_att_target_euler_rad.x,_att_target_euler_rad.y,_att_target_euler_rad.z); <span class="comment">//将四元数的目标姿态角装换为欧拉角</span></span><br><span class="line">    _att_target_ang_vel_rads = att_target_ang_vel_rads;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Retrieve quaternion vehicle attitude</span></span><br><span class="line">    <span class="comment">// TODO add _ahrs.get_quaternion()</span></span><br><span class="line">    Quaternion att_vehicle_quat;</span><br><span class="line">    att_vehicle_quat.from_rotation_matrix(_ahrs.get_rotation_body_to_ned()); <span class="comment">//获得机体姿态角</span></span><br><span class="line">    <span class="comment">// Compute attitude error</span></span><br><span class="line">    (att_vehicle_quat.inverse()*att_target_quat).to_axis_angle(_att_error_rot_vec_rad); <span class="comment">//计算角度误差</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compute the angular velocity target from the attitude error</span></span><br><span class="line">    update_ang_vel_target_from_att_error(); <span class="comment">//内环P控制，更新_ang_vel_target_rads外环控制值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add the angular velocity feedforward, rotated into vehicle frame</span></span><br><span class="line">    Matrix3f Trv;</span><br><span class="line">    get_rotation_reference_to_vehicle(Trv);</span><br><span class="line">    _ang_vel_target_rads += Trv * _att_target_ang_vel_rads; <span class="comment">//更新_ang_vel_target_rads外环控制值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中get_rotation_body_to_ned函数的原型为：    </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Matrix3f &amp;AP_AHRS_NavEKF::get_rotation_body_to_ned(<span class="keyword">void</span>) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!active_EKF_type()) &#123; <span class="comment">//如果没有使用EKF,则使用DCM算法生成的矩阵</span></span><br><span class="line">        <span class="keyword">return</span> AP_AHRS_DCM::get_rotation_body_to_ned();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _dcm_matrix; <span class="comment">//否则使用EKF2生成的矩阵</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// return rotation matrix representing rotaton from body to earth axes</span></span><br><span class="line"><span class="function">onst Matrix3f &amp;<span class="title">get_rotation_body_to_ned</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _body_dcm_matrix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另为，内环P控制，输出值_ang_vel_target_rads为外环PID目标控制值。   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> AC_AttitudeControl::update_ang_vel_target_from_att_error()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Compute the roll angular velocity demand from the roll angle error</span></span><br><span class="line">    <span class="keyword">if</span> (_att_ctrl_use_accel_limit &amp;&amp; _accel_roll_max &gt; <span class="number">0.0f</span>) &#123;</span><br><span class="line">        _ang_vel_target_rads.x = sqrt_controller(_att_error_rot_vec_rad.x, _p_angle_roll.kP(), constrain_float(get_accel_roll_max_radss()/<span class="number">2.0f</span>,  AC_ATTITUDE_ACCEL_RP_CONTROLLER_MIN_RADSS, AC_ATTITUDE_ACCEL_RP_CONTROLLER_MAX_RADSS));</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        _ang_vel_target_rads.x = _p_angle_roll.kP() * _att_error_rot_vec_rad.x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compute the pitch angular velocity demand from the roll angle error</span></span><br><span class="line">    <span class="keyword">if</span> (_att_ctrl_use_accel_limit &amp;&amp; _accel_pitch_max &gt; <span class="number">0.0f</span>) &#123;</span><br><span class="line">        _ang_vel_target_rads.y = sqrt_controller(_att_error_rot_vec_rad.y, _p_angle_pitch.kP(), constrain_float(get_accel_pitch_max_radss()/<span class="number">2.0f</span>,  AC_ATTITUDE_ACCEL_RP_CONTROLLER_MIN_RADSS, AC_ATTITUDE_ACCEL_RP_CONTROLLER_MAX_RADSS));</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        _ang_vel_target_rads.y = _p_angle_pitch.kP() * _att_error_rot_vec_rad.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compute the yaw angular velocity demand from the roll angle error</span></span><br><span class="line">    <span class="keyword">if</span> (_att_ctrl_use_accel_limit &amp;&amp; _accel_yaw_max &gt; <span class="number">0.0f</span>) &#123;</span><br><span class="line">        _ang_vel_target_rads.z = sqrt_controller(_att_error_rot_vec_rad.z, _p_angle_yaw.kP(), constrain_float(get_accel_yaw_max_radss()/<span class="number">2.0f</span>,  AC_ATTITUDE_ACCEL_Y_CONTROLLER_MIN_RADSS, AC_ATTITUDE_ACCEL_Y_CONTROLLER_MAX_RADSS));</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        _ang_vel_target_rads.z = _p_angle_yaw.kP() * _att_error_rot_vec_rad.z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add feedforward term that attempts to ensure that the copter yaws about the reference</span></span><br><span class="line">    <span class="comment">// Z axis, rather than the vehicle body Z axis.</span></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> This is a small-angle approximation.</span></span><br><span class="line">    _ang_vel_target_rads.x += _att_error_rot_vec_rad.y * _ahrs.get_gyro().z;</span><br><span class="line">    _ang_vel_target_rads.y += -_att_error_rot_vec_rad.x * _ahrs.get_gyro().z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>外环PID控制并设置电机值。   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> AC_AttitudeControl::rate_controller_run()</span><br><span class="line">&#123;</span><br><span class="line">    _motors.set_roll(rate_bf_to_motor_roll(_ang_vel_target_rads.x));</span><br><span class="line">    _motors.set_pitch(rate_bf_to_motor_pitch(_ang_vel_target_rads.y));</span><br><span class="line">    _motors.set_yaw(rate_bf_to_motor_yaw(_ang_vel_target_rads.z));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数位于ArduCopter.cpp里的fast_loop函数里，它是放于内环控制之前的。如下：   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Main loop - 400hz</span></span><br><span class="line"><span class="keyword">void</span> Copter::fast_loop()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IMU DCM Algorithm</span></span><br><span class="line">    <span class="comment">// --------------------</span></span><br><span class="line">    read_AHRS();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// run low level rate controllers that only require IMU data</span></span><br><span class="line">    attitude_control.rate_controller_run(); <span class="comment">//外环并赋值给电机</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FRAME_CONFIG == HELI_FRAME</span></span><br><span class="line">    update_heli_control_dynamics();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//HELI_FRAME</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// send outputs to the motors library</span></span><br><span class="line">    motors_output();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inertial Nav</span></span><br><span class="line">    <span class="comment">// --------------------</span></span><br><span class="line">    read_inertia();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check if ekf has reset target heading</span></span><br><span class="line">    check_ekf_yaw_reset();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// run the attitude controllers</span></span><br><span class="line">    update_flight_mode(); <span class="comment">//如果仅考虑自稳模式，内环控制在这个里边</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// update home from EKF if necessary</span></span><br><span class="line">    update_home_from_EKF();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check if we've landed or crashed</span></span><br><span class="line">    update_land_and_crash_detectors();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> MOUNT == ENABLED</span></span><br><span class="line">    <span class="comment">// camera mount's fast update</span></span><br><span class="line">    camera_mount.update_fast();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// log sensor health</span></span><br><span class="line">    <span class="keyword">if</span> (should_log(MASK_LOG_ANY)) &#123;</span><br><span class="line">        Log_Sensor_Health();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看看rate_controller_run函数其中的rate_bf_to_motor_roll函数，这里进行了外环控制。   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> AC_AttitudeControl::rate_bf_to_motor_roll(<span class="keyword">float</span> rate_target_rads)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">float</span> current_rate_rads = _ahrs.get_gyro().x;</span><br><span class="line">    <span class="keyword">float</span> rate_error_rads = rate_target_rads - current_rate_rads;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For legacy reasons, we convert to centi-degrees before inputting to the PID</span></span><br><span class="line">    _pid_rate_roll.set_input_filter_d(degrees(rate_error_rads)*<span class="number">100.0f</span>);</span><br><span class="line">    _pid_rate_roll.set_desired_rate(degrees(rate_target_rads)*<span class="number">100.0f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> integrator = _pid_rate_roll.get_integrator();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensure that integrator can only be reduced if the output is saturated</span></span><br><span class="line">    <span class="keyword">if</span> (!_motors.limit.roll_pitch || ((integrator &gt; <span class="number">0</span> &amp;&amp; rate_error_rads &lt; <span class="number">0</span>) || (integrator &lt; <span class="number">0</span> &amp;&amp; rate_error_rads &gt; <span class="number">0</span>))) &#123;</span><br><span class="line">        integrator = _pid_rate_roll.get_i();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compute output</span></span><br><span class="line">    <span class="keyword">float</span> output = _pid_rate_roll.get_p() + integrator + _pid_rate_roll.get_d();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Constrain output</span></span><br><span class="line">    <span class="keyword">return</span> constrain_float(output, -AC_ATTITUDE_RATE_RP_CONTROLLER_OUT_MAX, AC_ATTITUDE_RATE_RP_CONTROLLER_OUT_MAX);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="串口、GCS及LOG调试"><a href="#串口、GCS及LOG调试" class="headerlink" title="串口、GCS及LOG调试"></a>串口、GCS及LOG调试</h1><p>由于我们在姿态算法测试的过程当中需要及时查看相关数据的变化情况或者波形图，在APM里主要有几种方法可以实现我们的目的。<br>第一种为串口：这种方式不仅在姿态算法测试而且在系统调试的过程当中都很起作用，假如你的Pixhawk突然启动出错，这个时候你就可以通过串口查看板子上电后rcS（输出信息都使用echo）的启动过程。另一方面，在APM的代码里，有独立的库文件可以进行编译学习，目的是可以让你单独快速的学习这个模块，如下，而这个里边的输出信息直接打印到了串口。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hal.console-&gt;println(<span class="string">"OpticalFlow library test ver 1.6"</span>);</span><br><span class="line"></span><br><span class="line">    hal.scheduler-&gt;delay(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// flowSensor initialization</span></span><br><span class="line">    optflow.init();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!optflow.healthy()) &#123;</span><br><span class="line">        hal.console-&gt;print(<span class="string">"Failed to initialise PX4Flow "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hal.scheduler-&gt;delay(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hal.console-&gt;println(<span class="string">"this only tests compilation succeeds"</span>);</span><br><span class="line"></span><br><span class="line">    hal.scheduler-&gt;delay(<span class="number">5000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AP_HAL_MAIN</span><br></pre></td></tr></table></figure>
<p>串口的连接方式如下：<br><img src="http://ardupilot.org/dev/_images/Pixhawk_FTDICable_NSH.jpg"></p>
<p>第二种方式为GCS：即通过飞控与地面站建立通信，在地面站上显示图形界面来显示波形。下面结合源码简单分析一下GCS：<br>从Arducopter.cpp可以看出，与地面站通信的主要线程为：   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SCHED_TASK(gcs_check_input,      <span class="number">400</span>,    <span class="number">180</span>),</span><br><span class="line">SCHED_TASK(gcs_send_heartbeat,     <span class="number">1</span>,    <span class="number">110</span>),</span><br><span class="line">SCHED_TASK(gcs_send_deferred,     <span class="number">50</span>,    <span class="number">550</span>),</span><br><span class="line">SCHED_TASK(gcs_data_stream_send,  <span class="number">50</span>,    <span class="number">550</span>),</span><br></pre></td></tr></table></figure>
<p>但是有一个地方需要注意，在void Copter::init_ardupilot()函数中，有一个设置：   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Register the mavlink service callback. This will run</span></span><br><span class="line"><span class="comment">// anytime there are more than 5ms remaining in a call to</span></span><br><span class="line"><span class="comment">// hal.scheduler-&gt;delay.</span></span><br><span class="line">hal.scheduler-&gt;register_delay_callback(mavlink_delay_cb_static, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<p>而这个函数为mavlink_delay_cb_static，追踪进去copter.mavlink_delay_cb();，再进去就是：   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  a delay() callback that processes MAVLink packets. We set this as the</span></span><br><span class="line"><span class="comment"> *  callback in long running library initialisation routines to allow</span></span><br><span class="line"><span class="comment"> *  MAVLink to process packets while waiting for the initialisation to</span></span><br><span class="line"><span class="comment"> *  complete</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> Copter::mavlink_delay_cb()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">uint32_t</span> last_1hz, last_50hz, last_5s;</span><br><span class="line">    <span class="keyword">if</span> (!gcs[<span class="number">0</span>].initialised || in_mavlink_delay) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    in_mavlink_delay = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> tnow = millis();</span><br><span class="line">    <span class="keyword">if</span> (tnow - last_1hz &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">        last_1hz = tnow;</span><br><span class="line">        gcs_send_heartbeat();</span><br><span class="line">        gcs_send_message(MSG_EXTENDED_STATUS1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tnow - last_50hz &gt; <span class="number">20</span>) &#123;</span><br><span class="line">        last_50hz = tnow;</span><br><span class="line">        gcs_check_input();</span><br><span class="line">        gcs_data_stream_send();</span><br><span class="line">        gcs_send_deferred();</span><br><span class="line">        notify.update();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tnow - last_5s &gt; <span class="number">5000</span>) &#123;</span><br><span class="line">        last_5s = tnow;</span><br><span class="line">        gcs_send_text(MAV_SEVERITY_INFO, <span class="string">"Initialising APM"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    check_usb_mux();</span><br><span class="line"></span><br><span class="line">    in_mavlink_delay = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可知在这里也进行了数据的发送，那岂不是与之前的线程冲突了？<br>仔细查看hal.scheduler-&gt;register_delay_callback这个函数:   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> PX4Scheduler::register_delay_callback(AP_HAL::Proc proc,</span><br><span class="line">                                            <span class="keyword">uint16_t</span> min_time_ms) </span><br><span class="line">&#123;</span><br><span class="line">    _delay_cb = proc;</span><br><span class="line">    _min_delay_cb_ms = min_time_ms;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而_delay_cb，_min_delay_cb_ms在delay函数里得到了调用：   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> PX4Scheduler::delay(<span class="keyword">uint16_t</span> ms)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (in_timerprocess()) &#123;</span><br><span class="line">        ::<span class="built_in">printf</span>(<span class="string">"ERROR: delay() from timer process\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    perf_begin(_perf_delay);</span><br><span class="line">	<span class="keyword">uint64_t</span> start = AP_HAL::micros64();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ((AP_HAL::micros64() - start)/<span class="number">1000</span> &lt; ms &amp;&amp; </span><br><span class="line">           !_px4_thread_should_exit) &#123;</span><br><span class="line">        delay_microseconds_semaphore(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">if</span> (_min_delay_cb_ms &lt;= ms) &#123;</span><br><span class="line">            <span class="keyword">if</span> (_delay_cb) &#123;</span><br><span class="line">                _delay_cb();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    perf_end(_perf_delay);</span><br><span class="line">    <span class="keyword">if</span> (_px4_thread_should_exit) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此可以知道这里的意思就是，如果系统有延时过长（_min_delay_cb_ms &lt;= ms）的情况，则会给gcs发送数据，这样以防止与gcs通信中断。    </p>
<p>主要发送消息流函数gcs_data_stream_send   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  send data streams in the given rate range on both links</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> Copter::gcs_data_stream_send(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint8_t</span> i=<span class="number">0</span>; i&lt;num_gcs; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (gcs[i].initialised) &#123;</span><br><span class="line">            gcs[i].data_stream_send();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们继续往里边看，可以看到这里分类进行输出。    </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">GCS_MAVLINK::data_stream_send(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (waypoint_receiving) &#123;</span><br><span class="line">        <span class="comment">// don't interfere with mission transfer</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!copter.in_mavlink_delay &amp;&amp; !copter.motors.armed()) &#123;</span><br><span class="line">        handle_log_send(copter.DataFlash);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    copter.gcs_out_of_time = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_queued_parameter != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (streamRates[STREAM_PARAMS].get() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            streamRates[STREAM_PARAMS].<span class="built_in">set</span>(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stream_trigger(STREAM_PARAMS)) &#123;</span><br><span class="line">            send_message(MSG_NEXT_PARAM);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// don't send anything else at the same time as parameters</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copter.gcs_out_of_time) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copter.in_mavlink_delay) &#123;</span><br><span class="line">        <span class="comment">// don't send any other stream types while in the delay callback</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stream_trigger(STREAM_RAW_SENSORS)) &#123;</span><br><span class="line">        send_message(MSG_RAW_IMU1);</span><br><span class="line">        send_message(MSG_RAW_IMU2);</span><br><span class="line">        send_message(MSG_RAW_IMU3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copter.gcs_out_of_time) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stream_trigger(STREAM_EXTENDED_STATUS)) &#123;</span><br><span class="line">        send_message(MSG_EXTENDED_STATUS1);</span><br><span class="line">        send_message(MSG_EXTENDED_STATUS2);</span><br><span class="line">        send_message(MSG_CURRENT_WAYPOINT);</span><br><span class="line">        send_message(MSG_GPS_RAW);</span><br><span class="line">        send_message(MSG_NAV_CONTROLLER_OUTPUT);</span><br><span class="line">        send_message(MSG_LIMITS_STATUS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copter.gcs_out_of_time) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stream_trigger(STREAM_POSITION)) &#123;</span><br><span class="line">        send_message(MSG_LOCATION);</span><br><span class="line">        send_message(MSG_LOCAL_POSITION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copter.gcs_out_of_time) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stream_trigger(STREAM_RAW_CONTROLLER)) &#123;</span><br><span class="line">        send_message(MSG_SERVO_OUT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copter.gcs_out_of_time) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stream_trigger(STREAM_RC_CHANNELS)) &#123;</span><br><span class="line">        send_message(MSG_RADIO_OUT);</span><br><span class="line">        send_message(MSG_RADIO_IN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copter.gcs_out_of_time) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stream_trigger(STREAM_EXTRA1)) &#123;</span><br><span class="line">        send_message(MSG_ATTITUDE);</span><br><span class="line">        send_message(MSG_SIMSTATE);</span><br><span class="line">        send_message(MSG_PID_TUNING);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copter.gcs_out_of_time) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stream_trigger(STREAM_EXTRA2)) &#123;</span><br><span class="line">        send_message(MSG_VFR_HUD);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copter.gcs_out_of_time) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stream_trigger(STREAM_EXTRA3)) &#123;</span><br><span class="line">        send_message(MSG_AHRS);</span><br><span class="line">        send_message(MSG_HWSTATUS);</span><br><span class="line">        send_message(MSG_SYSTEM_TIME);</span><br><span class="line">        send_message(MSG_RANGEFINDER);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> AP_TERRAIN_AVAILABLE &amp;&amp; AC_TERRAIN</span></span><br><span class="line">        send_message(MSG_TERRAIN);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        send_message(MSG_BATTERY2);</span><br><span class="line">        send_message(MSG_MOUNT_STATUS);</span><br><span class="line">        send_message(MSG_OPTICAL_FLOW);</span><br><span class="line">        send_message(MSG_GIMBAL_REPORT);</span><br><span class="line">        send_message(MSG_MAG_CAL_REPORT);</span><br><span class="line">        send_message(MSG_MAG_CAL_PROGRESS);</span><br><span class="line">        send_message(MSG_EKF_STATUS_REPORT);</span><br><span class="line">        send_message(MSG_VIBRATION);</span><br><span class="line">        send_message(MSG_RPM);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这么多消息，它的管理方式为队列。   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// send a message using mavlink, handling message queueing</span></span><br><span class="line"><span class="keyword">void</span> GCS_MAVLINK::send_message(<span class="keyword">enum</span> ap_message id)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> i, nextid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// see if we can send the deferred messages, if any</span></span><br><span class="line">    <span class="keyword">while</span> (num_deferred_messages != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!try_send_message(deferred_messages[next_deferred_message])) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        next_deferred_message++;</span><br><span class="line">        <span class="keyword">if</span> (next_deferred_message == MSG_RETRY_DEFERRED) &#123;</span><br><span class="line">            next_deferred_message = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        num_deferred_messages--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (id == MSG_RETRY_DEFERRED) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// this message id might already be deferred</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>, nextid = next_deferred_message; i &lt; num_deferred_messages; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (deferred_messages[nextid] == id) &#123;</span><br><span class="line">            <span class="comment">// its already deferred, discard</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nextid++;</span><br><span class="line">        <span class="keyword">if</span> (nextid == MSG_RETRY_DEFERRED) &#123;</span><br><span class="line">            nextid = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (num_deferred_messages != <span class="number">0</span> ||</span><br><span class="line">        !try_send_message(id)) &#123;</span><br><span class="line">        <span class="comment">// can't send it now, so defer it</span></span><br><span class="line">        <span class="keyword">if</span> (num_deferred_messages == MSG_RETRY_DEFERRED) &#123;</span><br><span class="line">            <span class="comment">// the defer buffer is full, discard</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nextid = next_deferred_message + num_deferred_messages;</span><br><span class="line">        <span class="keyword">if</span> (nextid &gt;= MSG_RETRY_DEFERRED) &#123;</span><br><span class="line">            nextid -= MSG_RETRY_DEFERRED;</span><br><span class="line">        &#125;</span><br><span class="line">        deferred_messages[nextid] = id;</span><br><span class="line">        num_deferred_messages++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这里边有个所谓的get_secondary_attitude函数，它是另外一种算法的姿态信息，不是DCM就是EKF：   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// return secondary attitude solution if available, as eulers in radians</span></span><br><span class="line"><span class="keyword">bool</span> AP_AHRS_NavEKF::get_secondary_attitude(Vector3f &amp;eulers)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (active_EKF_type()) &#123;</span><br><span class="line">    <span class="keyword">case</span> EKF_TYPE_NONE:</span><br><span class="line">        <span class="comment">// EKF is secondary</span></span><br><span class="line">        EKF1.getEulerAngles(eulers); <span class="comment">//这个是EKF1算法生成的姿态信息</span></span><br><span class="line">        <span class="keyword">return</span> ekf1_started;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> EKF_TYPE1:</span><br><span class="line">    <span class="keyword">case</span> EKF_TYPE2:</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// DCM is secondary</span></span><br><span class="line">        eulers = _dcm_attitude; <span class="comment">//这是DCM算法生成的姿态信息，应该是返回这里</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消息由_mav_finalize_message_chan_send定制，最后由comm_send_buffer发出～<br>如果飞控出现问题如，gcs_send_text(MAV_SEVERITY_CRITICAL,”PreArm: Waiting for Nav Checks”);，是这个函数发出来的。</p>
<p>在apmplanner里查看波形如下：   </p>
<p><img src="/images/gcslog.png"></p>
<p>第三种当然是通过SD卡咯，一般来说，当我们实际飞行完成后，可以将SD里面的飞行数据进行分析，对于APM的固件，数据打包成bin格式的文件存储于SD卡中，可以使用apmplanner(如上图中的OpenLog)读取，也可以通过<a href="http://ardupilot.org/dev/docs/using-mavexplorer-for-log-analysis.html" target="_blank" rel="noopener">MAVExplorer</a>。实际操作很简单，不进行分析。<br>APM的源码体现为：   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fifty_hz_logging_loop</span></span><br><span class="line"><span class="comment">// should be run at 50hz</span></span><br><span class="line"><span class="keyword">void</span> Copter::fifty_hz_logging_loop()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> HIL_MODE != HIL_MODE_DISABLED</span></span><br><span class="line">    <span class="comment">// HIL for a copter needs very fast update of the servo values</span></span><br><span class="line">    gcs_send_message(MSG_RADIO_OUT);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> HIL_MODE == HIL_MODE_DISABLED</span></span><br><span class="line">    <span class="keyword">if</span> (should_log(MASK_LOG_ATTITUDE_FAST)) &#123;</span><br><span class="line">        Log_Write_Attitude();</span><br><span class="line">        Log_Write_Rate();</span><br><span class="line">        <span class="keyword">if</span> (should_log(MASK_LOG_PID)) &#123;</span><br><span class="line">            DataFlash.Log_Write_PID(LOG_PIDR_MSG, g.pid_rate_roll.get_pid_info() );</span><br><span class="line">            DataFlash.Log_Write_PID(LOG_PIDP_MSG, g.pid_rate_pitch.get_pid_info() );</span><br><span class="line">            DataFlash.Log_Write_PID(LOG_PIDY_MSG, g.pid_rate_yaw.get_pid_info() );</span><br><span class="line">            DataFlash.Log_Write_PID(LOG_PIDA_MSG, g.pid_accel_z.get_pid_info() );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// log IMU data if we're not already logging at the higher rate</span></span><br><span class="line">    <span class="keyword">if</span> (should_log(MASK_LOG_IMU) &amp;&amp; !(should_log(MASK_LOG_IMU_FAST) || should_log(MASK_LOG_IMU_RAW))) &#123;</span><br><span class="line">        DataFlash.Log_Write_IMU(ins);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="http://www.crazepony.com/wiki/mpu6050.html" target="_blank" rel="noopener">陀螺仪加速度计MPU6050</a></p>

      
    </div>
    
    
    

    
      <div>
        <div id="wechat_subscriber" style="display: block; padding: 10px 0; margin: 20px auto; width: 100%; text-align: center">
    <img id="wechat_subscriber_qcode" src="/images/wechat-qcode.jpg" alt="nephen wechat" style="width: 200px; max-width: 100%;">
    <div>欢迎您扫一扫上面的微信公众号，订阅我的博客！</div>
</div>

      </div>
    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.jpg" alt="nephen 微信支付">
        <p>微信支付</p>
      </div>
    

    

    

  </div>
</div>

      </div>
    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    nephen
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://nephen.cn/2017/06/16/初学PX4之飞控算法/" title="初学PX4之飞控算法">http://nephen.cn/2017/06/16/初学PX4之飞控算法/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/PX4/" rel="tag"># PX4</a>
          
            <a href="/tags/飞控算法/" rel="tag"># 飞控算法</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/06/16/C-Plus学习笔记/" rel="next" title="C Plus学习笔记">
                <i class="fa fa-chevron-left"></i> C Plus学习笔记
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/06/16/pixhawk试飞报告/" rel="prev" title="pixhawk试飞报告">
                pixhawk试飞报告 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="nephen">
            
              <p class="site-author-name" itemprop="name">nephen</p>
              <p class="site-description motion-element" itemprop="description">学而不思则罔，思而不学则殆。</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">30</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">33</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#姿态出处分析"><span class="nav-number">1.</span> <span class="nav-text">姿态出处分析</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#姿态传感器数据采集"><span class="nav-number">2.</span> <span class="nav-text">姿态传感器数据采集</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#姿态估算"><span class="nav-number">3.</span> <span class="nav-text">姿态估算</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#DCM-tutorial"><span class="nav-number">3.1.</span> <span class="nav-text">DCM_tutorial</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DCM理论"><span class="nav-number">3.2.</span> <span class="nav-text">DCM理论</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#EKF设计与实现"><span class="nav-number">3.3.</span> <span class="nav-text">EKF设计与实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#姿态控制"><span class="nav-number">4.</span> <span class="nav-text">姿态控制</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#串口、GCS及LOG调试"><span class="nav-number">5.</span> <span class="nav-text">串口、GCS及LOG调试</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考文献"><span class="nav-number">6.</span> <span class="nav-text">参考文献</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2016 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">nephen</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user">本站访客数</i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人次
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye">本站总访问量</i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: true,
        notify: true,
        appId: 'gFQhzLeyVb1xPHJj6sx7wQQh-gzGzoHsz',
        appKey: '1IvxtXYSwUVutAGwcvVdGCaJ',
        placeholder: '期待你的精彩点评',
        avatar:'wavatar',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  
  


  

  

</body>
</html>
